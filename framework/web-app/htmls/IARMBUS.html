<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.contributor" content="sreelal"/><meta name="DCTERMS.modified" content="2014-10-31T21:17:49" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:10pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.ta1 { writing-mode:lr-tb; }
	.ta2 { writing-mode:lr-tb; }
	.Default { font-family:Arial; padding:0.028in; }
	.ce1 { background-color:#558ed5; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce10 { padding:0.028in; font-family:Arial; vertical-align:top; margin-left:0in; writing-mode:page; font-size:8pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce11 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:center ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce12 { padding:0.028in; font-family:Arial; vertical-align:top; margin-left:0in; writing-mode:page; font-size:8pt; font-style:italic; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce13 { padding:0.028in; font-family:Arial; vertical-align:top; margin-left:0in; writing-mode:page; font-size:8pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:bold; }
	.ce14 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:center ! important; margin-left:0in; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce15 { padding:0.028in; font-family:Arial; vertical-align:top; margin-left:0in; writing-mode:page; color:#000000; font-size:8pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce16 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce17 { padding:0.028in; font-family:Arial; font-size:8pt; font-style:italic; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce18 { background-color:#ffffff; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce19 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce2 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce20 { padding:0.028in; font-family:Arial; font-size:8pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce3 { background-color:#558ed5; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce4 { background-color:#558ed5; border-style:none; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0133cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0133cm; border-right-style:solid; border-right-color:#000000; border-top-width:0.0133cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce5 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0in; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce6 { padding:0.028in; font-family:Arial; vertical-align:middle; text-align:left ! important; margin-left:0in; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce7 { padding:0.028in; font-family:Arial; }
	.ce8 { background-color:#ffffff; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce9 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:top; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.co1 { width:1.7618in; }
	.co10 { width:1.6409in; }
	.co11 { width:1.9929in; }
	.co12 { width:2.6098in; }
	.co13 { width:1.3429in; }
	.co2 { width:1.8827in; }
	.co3 { width:1.1783in; }
	.co4 { width:0.8917in; }
	.co5 { width:3.3693in; }
	.co6 { width:3.0945in; }
	.co7 { width:1.6075in; }
	.co8 { width:3.1382in; }
	.co9 { width:1.9492in; }
	.ro1 { height:0.6335in; }
	.ro10 { height:2.4791in; }
	.ro11 { height:2.6563in; }
	.ro12 { height:3.1874in; }
	.ro13 { height:4.7811in; }
	.ro14 { height:4.0728in; }
	.ro15 { height:4.5189in; }
	.ro16 { height:4.3728in; }
	.ro17 { height:3.7839in; }
	.ro18 { height:2.1252in; }
	.ro19 { height:2.3437in; }
	.ro2 { height:2.6126in; }
	.ro20 { height:2.4898in; }
	.ro21 { height:2.3752in; }
	.ro22 { height:2.3646in; }
	.ro23 { height:2.4563in; }
	.ro24 { height:2.4146in; }
	.ro25 { height:2.4354in; }
	.ro26 { height:2.4772in; }
	.ro27 { height:2.5709in; }
	.ro28 { height:4.4272in; }
	.ro29 { height:2.461in; }
	.ro3 { height:2.7972in; }
	.ro30 { height:2.8626in; }
	.ro31 { height:2.3126in; }
	.ro32 { height:0.4374in; }
	.ro33 { height:3.5417in; }
	.ro34 { height:3.8957in; }
	.ro35 { height:0.1772in; }
	.ro4 { height:3.0992in; }
	.ro5 { height:5.689in; }
	.ro6 { height:3.5161in; }
	.ro7 { height:3.7189in; }
	.ro8 { height:4.25in; }
	.ro9 { height:3.3646in; }
	.T1 { color:#000000; font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.T2 { color:#ffffff; font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:underline; font-weight:bold; }
	.T3 { color:#ffffff; font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:bold; }
	.T4 { color:#000000; font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:underline; font-weight:normal; }
	.T5 { font-family:Times New Roman; font-size:12pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	<!-- ODF styles with no properties representable as CSS -->
	 { }
	</style></head><body dir="ltr" style="max-width:8.5in;margin-top:0.7874in; margin-bottom:0.7874in; margin-left:0.7874in; margin-right:0.7874in; writing-mode:lr-tb; "><table border="0" cellspacing="0" cellpadding="0" class="ta1"><colgroup><col width="196"/><col width="209"/><col width="131"/><col width="99"/><col width="374"/><col width="343"/><col width="178"/><col width="348"/><col width="216"/><col width="182"/><col width="221"/><col width="290"/><col width="149"/><col width="99"/><col width="99"/></colgroup><tr class="ro1"><td style="text-align:left;width:1.7618in; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:1.8827in; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:1.1783in; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:0.8917in; " class="ce1"><p>Test Setup</p></td><td style="text-align:left;width:3.3693in; " class="ce1"><p>API's / Interface Used</p></td><td style="text-align:left;width:3.0945in; " class="ce1"><p>Input Parameters</p><p>(<span class="T2">API name</span><span class="T3">: parameter type – value) / </span></p><p><span class="T3">Interface Input</span></p></td><td style="text-align:left;width:1.6075in; " class="ce1"><p>Pre-requisite</p></td><td style="text-align:left;width:3.1382in; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:1.9492in; " class="ce1"><p>Exp Output</p></td><td style="text-align:left;width:1.6409in; " class="ce1"><p>Priority</p></td><td style="text-align:left;width:1.9929in; " class="ce1"><p>Test Stub Interface</p></td><td style="text-align:left;width:2.6098in; " class="ce1"><p>Test script</p></td><td style="text-align:left;width:1.3429in; " class="ce1"><p>Remarks</p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_1</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Joining application with IARMBUS </p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.  </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Connect &amp; Disconnect test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_2</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Joining application with IARMBUS where the application is already joined with the IARMBUS.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent will try to register the application which is already registered with the Process group.</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Init Negative test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro4"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_3</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Checking process registration status with IARMDaemon Manager</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_IsConnected(const char *, int *)</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_IsConnected</span><span class="T1"> : </span></p><p><span class="T1">Char - *memberName, int * - isRegistered</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with IARMDaemon Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_IsConnected</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS IsConnected test</p></td><td style="text-align:left;width:1.3429in; " class="ce16"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_4</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – deregister event handler for removing listener for an event.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> - None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> - None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS unregisterEvt Handler test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_5</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – deregister event handler without registering event handler.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce2"><p> </p><p><span class="T4">IARM_Bus_Init</span><span class="T1"> : </span></p><p><span class="T1">char *-(test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :  </span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>4.IARMBUS_Agent deregister the event handler.</p><p>5.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for failure status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Unregister with out Register Event Handler test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro7"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_6</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Releasing acquired resource by a process.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char *, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t -  IR_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :  </span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> - None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> - None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregister the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Release Resource test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro8"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_7</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Requesting for a resource which is already allocated for another application.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon ( First application) .</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application).</p><p>4.Second application will request and acquire  “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>5.IARMBUS_Agent application will request for a resource which is currently acquired by second application.</p><p>6.Second application will release the resource and the resource will be utilized by IARMBUS_Agent application.</p><p>7.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>8.Both the applications  deregister from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Request same resource in different application test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_8</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Requesting a resource from the application for which, the same resource  is already allocated .</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> :</span><span class="T4"> </span><span class="T1">IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent request for a resource “IARM_BUS_RESOURCE_FOCUS”.</p><p>4.IARMBUS_Agent will again request for the same resource “IARM_BUS_RESOURCE_FOCUS” before releasing it.</p><p>5.IARMBUS_Agent will release the resource “IARM_BUS_RESOURCE_FOCUS”</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Request same resource from same application test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_9</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS -Request for Decoder-0 resource.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_0</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_0</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_DECODER_0.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_DECODER_0.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Request decoder-0 test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_10</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS -Request for Decoder-1 resource.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_1</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_1</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_DECODER_1.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_DECODER_1.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Request decoder-1 test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_11</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS -Request for Graphics plane-0 resource.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">Char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_PLANE_0</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_PLANE_0</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_PLANE_0.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_PLANE_0.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Request graphics plane-0 test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_12</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS -Request for Graphics plane-1 resource.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_PLANE_1</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_PLANE_1</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_PLANE_1.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_PLANE_1.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Request graphics plane-1 test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_13</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS - Request for display resolution change<span class="T1"> resource.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_RESOLUTION</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_RESOLUTION</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_RESOLUTION.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_RESOLUTION.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Request display_resolution_change  test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_14</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS - Request for power<span class="T1"> resource.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">Char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t -</span></p><p><span class="T1">IARM_BUS_RESOURCE_POWER</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_POWER</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_POWER.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_POWER.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Request power  test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro11"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_15</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Registering an RPC method that can be invoked by other applications.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterCall(const char *, IARM_BusCall_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_RegisterCall</span><span class="T1"> : </span></p><p><span class="T1">const char * -</span><span class="T4"> </span><span class="T1">IARM_BUS_COMMON_API_ReleaseOwnership</span></p><p><span class="T1">IARM_BusCall_t- releaseOwnershipHandler</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent registers a RPC methods for releasing the resource that can be invoked by other application.</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RegisterCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS RegisterCall test</p></td><td style="text-align:left;width:1.3429in; " class="ce16"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro12"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_16</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Invoke RPC methods that is registered in another application.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterCall(const char *, IARM_BusCall_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_RegisterCall</span><span class="T1"> : </span></p><p><span class="T1">const char * -</span><span class="T4"> </span><span class="T1">IARM_BUS_PWRMGR_API_GetPowerState</span></p><p><span class="T1">IARM_BusCall_t - _GetPowerStatecallback</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char *- IARM_BUS_PWRMGR_NAME,     const char * - IARM_BUS_PWRMGR_API_GetPowerState  , void * -param, size_t - sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2.“pwrMgrMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.pwrMgrMain registers a RPC methods for setting the power state and this RPC can be invoked by IARMBUS_Agent application.</p><p>5.IARMBUS_Agent Invoke the RPC method of pwrMgrMain application to get the power state of STB. </p><p>6.IARMBUS_Agent deregister from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RegisterCall</p><p>6.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS BusCall test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_17</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting the event to application through IARMBus .</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce2"><p> </p><p><span class="T4">IARM_Bus_Init</span><span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">ARM_Bus_RegisterEventHandler</span><span class="T1"> :</span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T4">IARM_Bus_BroadcastEvent</span><span class="T1"> :</span></p><p><span class="T1">const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t -  IARM_BUS_IRMGR_EVENT_IRKEY, </span></p><p><span class="T1">Void *- eventData, size_t- sizeof(eventData) </span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :</span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2.“pwrMgrMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (first application). </p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application).</p><p>4.Second application will publish “IARM_BUS_IRMGR_EVENT_IRKEY “ to the IARMBUS_Agent.</p><p>5.IARMBUS_Agent will register for IR key events.</p><p>6.The IARMBUS_Agent should receive the IR key notification. On notification, IARMBUS_Agent keeps value of last received key.</p><p>7.IARMBUS_Agent will deregisters the event handler.</p><p>8.TM makes RPC call for getting last received from first applications.</p><p>9.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>10.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2</span><span class="T1">.Check for the correct key name for the key code received for both the test applications.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>9.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Broadcast IR event</p></td><td style="text-align:left;width:1.3429in; " class="ce16"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_18</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_DISKMGR_EVENT_HWDISK</span><span class="T1">” event.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME , IARM_EventId_t - IARM_BUS_DISKMGR_EVENT_HWDISK, IARM_EventHandler_t - _evthandler </span></p><p><span class="T4">IARM_Bus_BroadcastEvent</span><span class="T1"> :</span></p><p><span class="T1">Const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_HWDISK ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char* – IARM_BUS_DISKMGR_NAME , IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_HWDISK</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "diskMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_DISKMGR_EVENT_HWDISK” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_DiskMgr_Event_HwDisk_18</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro15"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_19</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_DISKMGR_EVENT_EXTHDD” event.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME , IARM_EventId_t - IARM_BUS_DISKMGR_EVENT_EXTHDD, IARM_EventHandler_t - _evthandler </span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_DISKMGR_NAME , IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "diskMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_DISKMGR_EVENT_EXTHDD” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_DiskMgr_Event_ExtHDD_19</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro16"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_20</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_DISKMGR_EVENT_EXTHDD” event with event type DISKMGR_EVENT_EXTHDD_PAIR.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME , IARM_EventId_t - IARM_BUS_DISKMGR_EVENT_EXTHDD, IARM_EventHandler_t - _evthandler </span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_DISKMGR_NAME , IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "diskMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_DISKMGR_EVENT_EXTHDD” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>“IARM_BUS_DiskMgr_Event_ExtHDD_Pair_20</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_21</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_DISKMGR_EVENT_EXTHDD” event with event type DISKMGR_EVENT_EXTHDD_ON.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME , IARM_EventId_t - IARM_BUS_DISKMGR_EVENT_EXTHDD, IARM_EventHandler_t - _evthandler </span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_DISKMGR_NAME , IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "diskMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_DISKMGR_EVENT_EXTHDD” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>“IARM_BUS_DiskMgr_Event_ExtHDD_On_21</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_22</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_DISKMGR_EVENT_EXTHDD” event with event type DISKMGR_EVENT_EXTHDD_OFF.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME , IARM_EventId_t - IARM_BUS_DISKMGR_EVENT_EXTHDD, IARM_EventHandler_t - _evthandler </span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_DISKMGR_NAME , IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "diskMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_DISKMGR_EVENT_EXTHDD” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>“IARM_BUS_DiskMgr_Event_ExtHDD_Off_22</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_23</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying Key Repeat Interval time for STB</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME,</span></p><p><span class="T1">Const char * - IARM_BUS_IRMGR_API_GetRepeatInterval</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.IARMBUS_Agent will invoke the RPC method for querying the key repeat interval time.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Query Key Repeat Interval test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro17"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_24</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Setting Key Repeat Interval time for STB .</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME,</span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_API_GetRepeatInterval,</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_NAME  </span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_API_SetRepeatInterval</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent will invoke the RPC for getting the key repeat interval time.  </p><p>4.IARMBUS_Agent will return the Key Repeat Interval to the Test Agent.</p><p>5.IARMBUS_Agent will set key repeat time.</p><p><span class="T1">6.IARMBUS_Agent will invoke the RPC for getting the key repeat interval time.</span></p><p><span class="T1">7.IARMBUS_Agent will return the Key Repeat Interval to the Test Agent.  </span></p><p><span class="T1">8.Test Agent will compare the Key Repeat Interval time before and after setting it.</span></p><p><span class="T1">9.IARMBUS_Agent deregisters from the IARM Bus Daemon.</span></p><p><span class="T1">10.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2</span><span class="T1">.Check the Key Repeat  interval before and after setting the value.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Set Key Repeat Interval test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_25</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying the   Power state of STB from the process.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()  </span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> :</span></p><p><span class="T1">const char* - IARM_BUS_PWRMGR_NAME,     const char* - </span></p><p><span class="T1">IARM_BUS_PWRMGR_API_GetPowerState,</span></p><p><span class="T1">void * -param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p><span class="T1">2.“pwrMgrMain” process should be running.</span></p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent Invoke the RPC call for getting the Power state of STB.</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2</span><span class="T1">.Check the Power state before and after pressing the power key</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Query Power state</p></td><td style="text-align:left;width:1.3429in; " class="ce16"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_26</p></td><td style="text-align:left;width:1.8827in; " class="ce8"><p>IARMBUS- Setting the Power state of STB from the process.</p></td><td style="text-align:left;width:1.1783in; " class="ce8"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterCall<span class="T1">(const char *methodName, IARM_BusCall_t handler)</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</span></p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()  </span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_PWRMGR_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_PWRMGR_API_SetPowerState,</span></p><p><span class="T1">Void * - param,size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_PWRMGR_NAME , IARM_EventId_t - IARM_BUS_PWRMGR_EVENT_MODECHANGED ,</span></p><p><span class="T1">IARM_EventHandler_t - _handler_Powermodechanged </span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler </span><span class="T1">: </span></p><p><span class="T1">const char* - IARM_BUS_PWRMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t - IARM_BUS_PWRMGR_EVENT_MODECHANGED</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* IARM_BUS_PWRMGR_NAME, const char* - </span></p><p><span class="T1">IARM_BUS_PWRMGR_API_GetPowerState,</span></p><p><span class="T1">void * -param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>IARMDaemonMain process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce8"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “IARM_BUS_PWRMGR_EVENT_MODECHANGED” event and waits on event.</p><p>4. TM makes RPC calls for getting the power state from IARMBUS_Agent</p><p>5.TM makes RPC calls for setting the new power state from IARMBUS_Agent</p><p>6.TM makes RPC calls for querying the latest power state from IARMBUS_Agent .</p><p>7.TM  compares the two power state for successful change in the power state</p><p>8.TM queries the last received event details to get the "IARM_BUS_PWRMGR_EVENT_MODECHANGED"event.</p><p>9.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>10.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce18"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2</span><span class="T1">.Check the Power state before and after setting the power state using API.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint3:</span><span class="T1">Check whether the IARM_BUS_PWRMGR_EVENT_MODECHANGED event is received</span></p></td><td style="text-align:left;width:1.6409in; " class="ce8"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Set Power state</p></td><td style="text-align:left;width:1.3429in; " class="ce8"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro12"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_27</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Registering all the Events before publishing and receiving events.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEvent(int )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_RegisterEvent</span><span class="T1"> :</span></p><p><span class="T1">Int - IARM_BUS_IRMGR_EVENT_MAX</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register all the events ie maximum number of events that any manager can have.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RegisterEvent</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS RegisterEventMax</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_28</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Receiving “RESOURCE AVAILABLE” event.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> :</span><span class="T4"> </span><span class="T1">IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMON_NAME , IARM_EventId_t - IARM_BUS_EVENT_RESOURCEAVAILABLE, IARM_EventHandler_t - _handler_ResourceAvailable </span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_DAEMON_NAME, IARM_EventId_t – IARM_BUS_EVENT_RESOURCEAVAILABLE</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t – IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOURCEAVAILABLE” event and waits on event.</p><p>5.Second application will release the resource.</p><p>6.IARMBUS_Agent should receive “RESOURCE AVAILABLE” event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>9.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBBUS Register for Resource Available event test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_29</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">RESOLUTIONCHANGE</span><span class="T1">” event.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMON_NAME , IARM_EventId_t - IARM_BUS_EVENT_RESOLUTIONCHANGE, IARM_EventHandler_t - _handler_ResolutionChange </span></p><p><span class="T4">IARM_Bus_BroadcastEvent</span><span class="T1"> :</span></p><p><span class="T1">Const char* - IARM_BUS_DAEMON_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_EVENT_RESOLUTIONCHANGE ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char* – IARM_BUS_DAEMON_NAME , IARM_EventId_t – IARM_BUS_EVENT_RESOLUTIONCHANGE</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS Broadcast ResolutionChange Event test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro19"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_30</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) manufacture name.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_MANUFACTURER,</span></p><p><span class="T1">size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board manufacture name. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS BusCall MFR-STB Manufature Name test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro20"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_31</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) manufacture OUI(</p><p>Organizationally Unique Identifier).</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_MANUFACTUREROUI ,</span></p><p><span class="T1">size_t - sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board manufacture OUI(Originally Unique Identifier). </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS BusCall MFR-OUI test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro21"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_32</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) model name.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_MODELNAME,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board model name. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS BusCall MFR-Model Name test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro22"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_33</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) description.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_DESCRIPTION,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board description. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS BusCall MFR-Board description test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro22"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_34</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) product class.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_PRODUCTCLASS,</span></p><p><span class="T1">size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board product class. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS BusCall MFR-Board Product Class test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro23"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_35</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) serial number .</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_SERIALNUMBER,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board serial number. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS BusCall MFR-SerialNumber test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro24"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_36</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) hardware version.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_HARDWAREVERSION,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board hardware version. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS BusCall MFR-Hardware version test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro25"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_37</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) software version.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_SOFTWAREVERSION,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board software version. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS BusCall MFR-Software version test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro26"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_38</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) provisioning code.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_PROVISIONINGCODE,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board provisioning code. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS BusCall MFR- Provision Code test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_39</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) First Use Date.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_FIRSTUSEDATE,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board last use date. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS BusCall MFR-First Use Date test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_40</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Creating and Calling Dummy RPC calls for 'x' times</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_RegisterCall(const char *methodName, IARM_BusCall_t handler)</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_DUMMYMGR_NAME,</span></p><p><span class="T1">Const char * - IARM_BUS_DUMMYMGR_API_DummyAPI0</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p> </p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon(First Application). </p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which Registers the Dummy RPC calls) .</p><p>4.IARMBUS_Agent will invoke the Dummy RPC method .</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6. Repeat steps 3-5 for 'x' times</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_DummyCall_Persistent_test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro28"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_41</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving of Dummy Event for 'x' times</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_DUMMYMGR_NAME , IARM_EventId_t - IARM_BUS_DUMMYMGR_EVENT_DUMMYX, IARM_EventHandler_t - _handler_ResolutionChange </span></p><p><span class="T4">IARM_Bus_BroadcastEvent</span><span class="T1"> :</span></p><p><span class="T1">Const char* - IARM_BUS_DUMMYMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DUMMYMGR_EVENT_DUMMYX ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char* – IARM_BUS_DUMMYMGR_NAME , IARM_EventId_t – IARM_BUS_DUMMYMGR_EVENT_DUMMYX</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which broadcasts the Dummy events) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7. Repeat steps3 to 6 for 'x' times .</p><p>8.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_DummyEvt_Persistent_test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_42</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Terminating an application with IARMBUS without Initializing</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce2"><p> </p><p> </p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.  </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p> </p><p>1.TestMgr_IARMBUS_Term</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_Term_Without_Init_42</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_43</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Initializing IARMBUS with parameter as symbols</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.  </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_Init_with_Invalidparameter_test_43</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_44</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Initializing IARMBUS with invalid application as parameter</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.  </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_Init_with_Invalid_App_test_44</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_45</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Unregister event handler for removing listener for a positive event ID.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> - None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> - None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_unregisterEvtHandler_With_PosId_45</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_46</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Unregister event handler for removing listener for a invalid event ID.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - 9</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> - None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> - None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent fails to deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_unregisterEvtHandler_With_NegId_46</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_47</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Register event handler and deregistering the same for positive event ID.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t -  1</span></p><p><span class="T1"> </span><span class="T1">IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - 1 </span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> - None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> - None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for an event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_RegisterEvtHandler_With_PosId_47</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_48</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Register event handler and deregistering for negative event ID </p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - 9</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> - None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> - None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for negative invalid event and fails to register.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_RegisterEvtHandler_With_NegId_48</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro29"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_49</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS -Request for Invalid resource type</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t – IARM_BUS_RESOURCE_DECODER_10</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_0</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for an invalid resource. </p><p>4.IARMBUS_Agent will fails to release invalid resource </p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_Request_Invalid_Resource_49</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_50</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS -Request for FOCUS resource.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t – IARM_BUS_RESOURCE_MAX</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_1</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_DECODER_1.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_DECODER_1.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_Request_FOCUS_Resource_50</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_51</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Register and deregistering event handler for every 100 milli seconds for multiple times.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Stress</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t -  1</span></p><p><span class="T1"> </span><span class="T1">IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - 1 </span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> - None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> - None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for an event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p>9.Above steps 3 to 7 will repeat for  “x” number of  times and sends the result to TM.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_RegUnReg_STRESS_51</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_52</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS -Release ownership with invalid resource.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t – IARM_BUS_RESOURCE_MAX</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_1</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_DECODER_1.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_DECODER_1.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_Release_Invalid_Resource_52</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro4"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_53</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Checking process registration status without registering it with IARMDaemon Manager</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_IsConnected(const char *, int *)</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_IsConnected</span><span class="T1"> : </span></p><p><span class="T1">Char - *memberName, int * - isRegistered</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with UI Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_IsConnected</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_IsConnect_Without_Connect_53</p></td><td style="text-align:left;width:1.3429in; " class="ce16"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro4"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_54</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Checking process registration status with invalid member name, with IARMDaemon Manager</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_IsConnected(const char *, int *)</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_IsConnected</span><span class="T1"> : </span></p><p><span class="T1">Char - *memberName, int * - isRegistered</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with IARMDaemon Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_IsConnected</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_IsConnected_Invalid_Membername_54</p></td><td style="text-align:left;width:1.3429in; " class="ce16"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro4"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_55</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Checking Iarmbus disconnect without connecting.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with IARMDaemon Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_IsConnected</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_Disconnect_without_connect_55</p></td><td style="text-align:left;width:1.3429in; " class="ce16"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro30"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_56</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS -Request multiple alternate resources for multiple times with every 100 mill seconds gap.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Stress</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t – IARM_BUS_RESOURCE_MAX</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_1</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_DECODER_1.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_DECODER_1.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p>7. Above 3 to 4 steps will be repeated for n number times and the result will be passed to TM</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_Request_resource_STRESS_56</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_57</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Connecting and Disconnect  IARMBUS for multiple times with gap of every 100 milli seconds</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Stress</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.  </p><p><span class="T1">5.Above 3 and 4 steps will be repeated for n number times and the result will be passed to TM.</span></p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_IsConnect_STRESS_57</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_58</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) Device MAC</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_DEVICEMAC,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying Device Mac. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_BusCall_MFR-Device_MAC_58</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_59</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) MOCA MAC</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_MOCAMAC,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying Moca Mac data. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_BusCall_MFR-MOCA_MAC_59</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_60</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) HDMI HDCP</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GetSerializedData,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_HDMIHDCP,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying HDMI HDCP data. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_BusCall_MFR-HDMIHDCP_60</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_61</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Deleting PDRI image from box using IARM_BUS_MFRLIB_API_DeletePDRI RPC call</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_DeletePDRI,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for deleting PDRI image using IARM_BUS_MFRLIB_API_DeletePDRI.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_BusCall_MFR-DeletePDRI_image_61</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_62</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Scrub all banks from box using IARM_BUS_MFRLIB_API_ScrubAllBanks RPC call</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_ScrubAllBanks,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for scrub all banks using IARM_BUS_MFRLIB_API_ScrubAllBanks.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_BusCall_MFR-Scruballbanks_62</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_63</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Validate and write image into the flash using IARM_BUS_MFRLIB_API_WriteImage RPC call</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_WriteImage,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect –</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term –</span><span class="T1"> None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for validate and write image into the flash using IARM_BUS_MFRLIB_API_WriteImage.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_BusCall_MFR-Validateandwriteimage_into_flash_63</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro31"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_64</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Reset the box to warehouse state using IARM_BUS_PWRMGR_API_WareHouseReset RPC call</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()  </span></p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> :</span></p><p><span class="T1">const char* - IARM_BUS_PWRMGR_NAME,     const char* - </span></p><p><span class="T1">IARM_BUS_PWRMGR_API_WareHouseReset,</span></p><p><span class="T1">void * -param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p><span class="T1">2.“pwrMgrMain” process should be running.</span></p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent Invoke the RPC call for reset the box to ware house state..</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARMBUS_Reset_WareHouse_state_64</p></td><td style="text-align:left;width:1.3429in; " class="ce16"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro32"><td colspan="13" style="text-align:left;width:1.7618in; " class="ce3"><p>Sys Mgr</p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_65</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_STB_SERIAL_NO and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_STB_SERIAL_NO), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_StbSerialNo_65</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_66</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_BOOTUP and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_BOOTUP), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_BootUp_66</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro34"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_67</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS –Get and set HDCP profile using  IARM_BUS_SYSMGR_API_GetHDCPProfile RPC call.</p><p>IARM_BUS_SYSMGR_API_SetHDCPProfile RPC call</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetHDCPProfile</span></p><p><span class="T1">(&amp;IARM_BUS_SYSMGR_API_SetHDCPProfile) void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetHDCPProfile), to get the HDCP profile value.</p><p>4.Get the HDCP profile value and set it to the other HDCP profile value using IARM_BUS_SYSMGR_API_SetHDCPProfile.</p><p>5.Compare the set HDCP profile value by getting the value from  (IARM_BUS_SYSMGR_API_SetHDCPProfile)RPC call.</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the HDCP profile set and get value using the RPC call</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_GetSetHDCPProfile_67</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro28"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_68</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS –Receiving event IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE upon changing the HDCP profile </p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandle</span><span class="T1">r : </span></p><p><span class="T1">const char * - IARM_BUS_SYSMGR_NAME , IARM_EventId_t - IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE, IARM_EventHandler_t - _evthandler </span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetHDCPProfile</span></p><p><span class="T1">(&amp;IARM_BUS_SYSMGR_API_SetHDCPProfile) void * - param, size_t -sizeof(param)</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_SYSMGR_NAME , IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3..IARMBUS_Agent will register for “IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE” event and waits on event.</p><p>4.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetHDCPProfile), to get the HDCP profile value.</p><p>5.Get the HDCP profile value and set it to the other HDCP profile value using IARM_BUS_SYSMGR_API_SetHDCPProfile.</p><p>6.IARMBUS_Agent should check the last received event for IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE.</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the last received event for HDCP profile update event.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_Bus Call</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_HDCPProfileEvent_68</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_70</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler :</span><span class="T1"> </span></p><p><span class="T1">const char * - IARM_BUS_SYSMGR_NAME , IARM_EventId_t - IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE, IARM_EventHandler_t - _evthandler </span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_SYSMGR_NAME , IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_70</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_71</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_REQUEST” event.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_SYSMGR_NAME , IARM_EventId_t - IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_REQUEST, IARM_EventHandler_t - _evthandler </span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_REQUEST ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_SYSMGR_NAME , IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_REQUEST</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_REQUEST” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_XUPNP_Data_Request_71</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_72</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_UPDATE” event.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_SYSMGR_NAME , IARM_EventId_t - IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_UPDATE, IARM_EventHandler_t - _evthandler </span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_UPDATE ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_SYSMGR_NAME , IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_UPDATE</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_SYSMGR_EVENT_XUPNP_DATA_UPDATE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_XUPNP_Data_Update_72</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_73</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_SYSMGR_EVENT_CARD_FWDNLD” event.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_SYSMGR_NAME , IARM_EventId_t - IARM_BUS_SYSMGR_EVENT_CARD_FWDNLD, IARM_EventHandler_t - _evthandler </span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_CARD_FWDNLD ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_SYSMGR_NAME , IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_CARD_FWDNLD</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_SYSMGR_EVENT_CARD_FWDNLD” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_Card_FwDNLD_73</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_74</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE” event.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler : </span></p><p><span class="T1">const char * - IARM_BUS_SYSMGR_NAME , IARM_EventId_t - IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE, IARM_EventHandler_t - _evthandler </span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler : </span></p><p><span class="T1">const char* – IARM_BUS_SYSMGR_NAME , IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_SYSMGR_EVENT_HDCP_PROFILE_UPDATE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_HDCPProfile_update_74</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_75</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CHANNELMAP and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CHANNELMAP), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_ChannelMap_75</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_76</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DISCONNECTMGR and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DISCONNECTMGR), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_DisconnectMGR_76</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_77</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_TUNEREADY and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init :<span class="T1"> </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_TUNEREADY), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_TuneReady_77</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_78</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_EXIT_OK and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_EXIT_OK), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_ExitOk_78</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_79</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CMAC and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CMAC), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CMAC_79</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_80</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_MOTO_ENTITLEMENT and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_MOTO_ENTITLEMENT), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_MotoEntitlement_80</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_81</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_MOTO_HRV_RX and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_MOTO_HRV_RX), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_MotoHRVRX_81</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_82</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CARD_CISCO_STATUS and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CARD_CISCO_STATUS), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CardCisco_Status_82</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_83</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_VIDEO_PRESENTING and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_VIDEO_PRESENTING), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_VideoPresenting_83</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_84</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_HDMI_OUT and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_HDMI_OUT), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_HDMIOut_84</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_85</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_HDCP_ENABLED and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_HDCP_ENABLED), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_HDCPEnabled_85</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_86</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_HDMI_EDID_READ and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_HDMI_EDID_READ), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_HDMI_EDID_Ready_86</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_87</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_FIRMWARE_DWNLD and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_FIRMWARE_DWNLD), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_Term :</span><span class="T1"> None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_FirmwareDWLD_87</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_88</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_TIME_SOURCE and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_TIME_SOURCE), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_TimeSource_88</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_89</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_TIME_ZONE and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_TIME_ZONE), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_TimeZone_89</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_90</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CA_SYSTEM and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CA_SYSTEM), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CASystem_90</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_91</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_ESTB_IP and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_ESTB_IP), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_EstbIP_91</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_92</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_ECM_IP and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_ECM_IP), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_ECMIP_92</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_93</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_LAN_IP and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_LAN_IP), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_LANIP_93</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_94</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_MOCA and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_MOCA), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_Moca_94</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_95</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DOCSIS and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DOCSIS), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_Docsis_95</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_96</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DSG_BROADCAST_CHANNEL and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DSG_BROADCAST_CHANNEL), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_DsgBroadCastChannel_96</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_97</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DSG_CA_TUNNEL and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DSG_CA_TUNNEL), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_DSG_CATunnel_97</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_98</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CABLE_CARD and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CABLE_CARD), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CableCard_98</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_99</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CABLE_CARD_DWNLD and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CABLE_CARD_DWNLD), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CableCardDWLD_99</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_100</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CVR_SUBSYSTEM and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CVR_SUBSYSTEM), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CVRSubsystem_100</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_101</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DOWNLOAD and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DOWNLOAD), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_Download_101</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_102</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_VOD_AD and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_VOD_AD), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_VOD_AD_102</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_103</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DAC_INIT_TIMESTAMP and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DAC_INIT_TIMESTAMP), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_DAC_InitTimeStamp_103</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_104</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_CABLE_CARD_SERIAL_NO and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_CABLE_CARD_SERIAL_NO), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_CableCard_SerialNo_104</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_105</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_ECM_MAC and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_ECM_MAC), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_ECMMac_105</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_106</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_DAC_ID and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_DAC_ID), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_DACId_106</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.7618in; " class="ce2"><p>CT_IARMBUS_107</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE</span><span class="T1">” event and setting data for IARM_BUS_SYSMGR_SYSSTATE_PLANT_ID and getting back using IARM_BUS_SYSMGR_API_GetSystemStates RPC call.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce16"><p>IARM_Bus_Init : </p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect :</span><span class="T1"> None</span></p><p><span class="T4">IARM_Bus_BroadcastEvent :</span></p><p><span class="T1">Const char* - IARM_BUS_SYSMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE ,</span></p><p><span class="T1">Void * - eventdata(IARM_BUS_SYSMGR_SYSSTATE_PLANT_ID), size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_Call :</span><span class="T1"> const char * - IARM_BUS_SYSMGR_NAME, const char * - IARM_BUS_SYSMGR_API_GetSystemStates</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect : </span><span class="T1">None</span></p><p><span class="T4">IARM_Bus_Term : </span><span class="T1">None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” and "sysMgrMain" process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.IARMBUS_Agent broadcast the event IARM_BUS_SYSMGR_EVENT_SYSTEMSTATE to the bus and sysmgr sets the data sent.</p><p>5.IARMBUS_Agent calls an RPC call(IARM_BUS_SYSMGR_API_GetSystemStates), to get the data passed using Broadcast Event</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce16"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for the data set from the RPC call with the data passed through Broadcast Event</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_BusCall</p><p> </p></td><td style="text-align:left;width:2.6098in; " class="ce19"><p>IARM_BUS_SysMgr_Event_SysState_PlantId_107</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro32"><td colspan="13" style="text-align:left;width:1.7618in; " class="ce4"><p>JIRA Tickets Mapped</p></td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro34"><td style="text-align:left;width:1.7618in; " class="ce5"><p>CT_IARMBUS_108</p></td><td style="text-align:left;width:1.8827in; " class="ce9"><p>Check if sending multiple KEY_DOWN and KEY_UP events in a row and check if the events are handled successfully</p></td><td style="text-align:left;width:1.1783in; " class="ce11"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce14"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:3.3693in; " class="ce9"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce9"><p>IARM_Bus_Init : </p><p>char * - (test agent process_name)</p><p>IARM_Bus_Connect : None</p><p>ARM_Bus_RegisterEventHandler :</p><p>const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</p><p>IARM_Bus_BroadcastEvent :</p><p>const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, </p><p>Void *- eventData, size_t- sizeof(eventData) </p><p>IARM_Bus_UnRegisterEventHandler :</p><p>const char* - IARM_BUS_IRMGR_NAME,</p><p>IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</p><p>IARM_Bus_Disconnect : None</p><p>IARM_Bus_Term : None</p></td><td style="text-align:left;width:1.6075in; " class="ce9"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:3.1382in; " class="ce9"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon.</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>5.IARMBUS_Agent will broadcast digit3 key press and key release event 50 times to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce9"><p>Checkpoint 1.Check the return value of API for success status.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:1.6409in; " class="ce9"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce9"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:2.6098in; " class="ce9"><p>IARM_BUS_IRMgr_IRKey_Toggle</p></td><td style="text-align:left;width:1.3429in; " class="ce9"> </td><td style="text-align:left;width:0.8917in; " class="ce9"> </td><td style="text-align:left;width:0.8917in; " class="ce9"><p>BPV-8212 </p></td></tr><tr class="ro14"><td style="text-align:left;width:1.7618in; " class="ce5"><p>CT_IARMBUS_109</p></td><td style="text-align:left;width:1.8827in; " class="ce9"><p>Check if multiple IR event notification is received for repeated key press/release for keys: channel up, channel down, Volume Up, Volume Down</p></td><td style="text-align:left;width:1.1783in; " class="ce11"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce14"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:3.3693in; " class="ce9"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce9"><p>IARM_Bus_Init : </p><p>char * - (test agent process_name)</p><p>IARM_Bus_Connect : None</p><p>ARM_Bus_RegisterEventHandler :</p><p>const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</p><p>IARM_Bus_BroadcastEvent :</p><p>const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, </p><p>Void *- eventData, size_t- sizeof(eventData) </p><p>IARM_Bus_UnRegisterEventHandler :</p><p>const char* - IARM_BUS_IRMGR_NAME,</p><p>IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</p><p>IARM_Bus_Disconnect : None</p><p>IARM_Bus_Term : None</p></td><td style="text-align:left;width:1.6075in; " class="ce9"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:3.1382in; " class="ce9"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon.</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>5.IARMBUS_Agent will broadcast CHANNELUP/CHANNELDOWN/VOLUMEUP/VOLUMEDOWN key press and key release event 5 times to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce9"><p>Checkpoint 1.Check the return value of API for success status.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:1.6409in; " class="ce9"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce9"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:2.6098in; " class="ce9"><p>IARM_BUS_IRMgr_IRKey_ChangeChannelVol</p></td><td style="text-align:left;width:1.3429in; " class="ce9"> </td><td style="text-align:left;width:0.8917in; " class="ce9"> </td><td style="text-align:left;width:0.8917in; " class="ce9"><p>DELIA-496</p></td></tr><tr class="ro34"><td style="text-align:left;width:1.7618in; " class="ce5"><p>CT_IARMBUS_110</p></td><td style="text-align:left;width:1.8827in; " class="ce9"><p>Check if multiple IR event notification is received for repeated key press/release for trickplay keys (REW/FF/PLAY/STOP/PAUSE)</p></td><td style="text-align:left;width:1.1783in; " class="ce11"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce14"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:3.3693in; " class="ce9"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce9"><p>IARM_Bus_Init : </p><p>char * - (test agent process_name)</p><p>IARM_Bus_Connect : None</p><p>ARM_Bus_RegisterEventHandler :</p><p>const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</p><p>IARM_Bus_BroadcastEvent :</p><p>const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, </p><p>Void *- eventData, size_t- sizeof(eventData) </p><p>IARM_Bus_UnRegisterEventHandler :</p><p>const char* - IARM_BUS_IRMGR_NAME,</p><p>IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</p><p>IARM_Bus_Disconnect : None</p><p>IARM_Bus_Term : None</p></td><td style="text-align:left;width:1.6075in; " class="ce9"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:3.1382in; " class="ce9"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon.</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>5.IARMBUS_Agent will broadcast (REW/FF/PLAY/STOP/PAUSE) key press and key release event 5 times to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce9"><p>Checkpoint 1.Check the return value of API for success status.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:1.6409in; " class="ce9"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce9"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:2.6098in; " class="ce9"><p>IARM_BUS_IRMgr_IRKey_CheckTrickplay</p></td><td style="text-align:left;width:1.3429in; " class="ce9"> </td><td style="text-align:left;width:0.8917in; " class="ce9"> </td><td style="text-align:left;width:0.8917in; " class="ce9"><p>DELIA-496</p></td></tr><tr class="ro34"><td style="text-align:left;width:1.7618in; " class="ce5"><p>CT_IARMBUS_111</p></td><td style="text-align:left;width:1.8827in; " class="ce9"><p>Check if multiple IR event notification is received for repeated key press/release for Search key</p></td><td style="text-align:left;width:1.1783in; " class="ce11"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce14"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:3.3693in; " class="ce9"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce9"><p>IARM_Bus_Init : </p><p>char * - (test agent process_name)</p><p>IARM_Bus_Connect : None</p><p>ARM_Bus_RegisterEventHandler :</p><p>const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</p><p>IARM_Bus_BroadcastEvent :</p><p>const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, </p><p>Void *- eventData, size_t- sizeof(eventData) </p><p>IARM_Bus_UnRegisterEventHandler :</p><p>const char* - IARM_BUS_IRMGR_NAME,</p><p>IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</p><p>IARM_Bus_Disconnect : None</p><p>IARM_Bus_Term : None</p></td><td style="text-align:left;width:1.6075in; " class="ce9"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:3.1382in; " class="ce9"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon.</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>5.IARMBUS_Agent will broadcast SEARCH key press and key release event 50 times to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce9"><p>Checkpoint 1.Check the return value of API for success status.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:1.6409in; " class="ce9"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce9"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:2.6098in; " class="ce9"><p>IARM_BUS_IRMgr_IRKey_CheckSearch</p></td><td style="text-align:left;width:1.3429in; " class="ce9"> </td><td style="text-align:left;width:0.8917in; " class="ce9"> </td><td style="text-align:left;width:0.8917in; " class="ce9"><p>DELIA-496</p></td></tr><tr class="ro34"><td style="text-align:left;width:1.7618in; " class="ce5"><p>CT_IARMBUS_112</p></td><td style="text-align:left;width:1.8827in; " class="ce9"><p>Check if multiple IR event notification is received for repeated key press/release for Setup key</p></td><td style="text-align:left;width:1.1783in; " class="ce11"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce14"><p>XG1-1/XI3-1</p></td><td style="text-align:left;width:3.3693in; " class="ce9"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce9"><p>IARM_Bus_Init : </p><p>char * - (test agent process_name)</p><p>IARM_Bus_Connect : None</p><p>ARM_Bus_RegisterEventHandler :</p><p>const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</p><p>IARM_Bus_BroadcastEvent :</p><p>const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, </p><p>Void *- eventData, size_t- sizeof(eventData) </p><p>IARM_Bus_UnRegisterEventHandler :</p><p>const char* - IARM_BUS_IRMGR_NAME,</p><p>IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</p><p>IARM_Bus_Disconnect : None</p><p>IARM_Bus_Term : None</p></td><td style="text-align:left;width:1.6075in; " class="ce9"><p>“IARMDaemonMain” process should be running. </p></td><td style="text-align:left;width:3.1382in; " class="ce9"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon.</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>5.IARMBUS_Agent will broadcast SETUP key press and key release event 50 times to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce9"><p>Checkpoint 1.Check the return value of API for success status.</p><p>Checkpoint 2. Check for the print message.</p></td><td style="text-align:left;width:1.6409in; " class="ce9"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce9"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:2.6098in; " class="ce9"><p>IARM_BUS_IRMgr_IRKey_CheckSetup</p></td><td style="text-align:left;width:1.3429in; " class="ce9"> </td><td style="text-align:left;width:0.8917in; " class="ce9"> </td><td style="text-align:left;width:0.8917in; " class="ce9"><p>DELIA-496</p></td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce10"> </td><td style="text-align:left;width:1.1783in; " class="ce10"> </td><td style="text-align:left;width:0.8917in; " class="ce15"> </td><td style="text-align:left;width:3.3693in; " class="ce10"> </td><td style="text-align:left;width:3.0945in; " class="ce10"> </td><td style="text-align:left;width:1.6075in; " class="ce10"> </td><td style="text-align:left;width:3.1382in; " class="ce10"> </td><td style="text-align:left;width:1.9492in; " class="ce10"> </td><td style="text-align:left;width:1.6409in; " class="ce10"> </td><td style="text-align:left;width:1.9929in; " class="ce10"> </td><td style="text-align:left;width:2.6098in; " class="ce10"> </td><td style="text-align:left;width:1.3429in; " class="ce10"> </td><td style="text-align:left;width:0.8917in; " class="ce10"> </td><td style="text-align:left;width:0.8917in; " class="ce20"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce10"> </td><td style="text-align:left;width:1.1783in; " class="ce10"> </td><td style="text-align:left;width:0.8917in; " class="ce15"> </td><td style="text-align:left;width:3.3693in; " class="ce10"> </td><td style="text-align:left;width:3.0945in; " class="ce10"> </td><td style="text-align:left;width:1.6075in; " class="ce10"> </td><td style="text-align:left;width:3.1382in; " class="ce10"> </td><td style="text-align:left;width:1.9492in; " class="ce10"> </td><td style="text-align:left;width:1.6409in; " class="ce10"> </td><td style="text-align:left;width:1.9929in; " class="ce10"> </td><td style="text-align:left;width:2.6098in; " class="ce10"> </td><td style="text-align:left;width:1.3429in; " class="ce10"> </td><td style="text-align:left;width:0.8917in; " class="ce10"> </td><td style="text-align:left;width:0.8917in; " class="ce20"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce10"> </td><td style="text-align:left;width:1.1783in; " class="ce12"> </td><td style="text-align:left;width:0.8917in; " class="ce15"> </td><td style="text-align:left;width:3.3693in; " class="ce10"> </td><td style="text-align:left;width:3.0945in; " class="ce10"> </td><td style="text-align:left;width:1.6075in; " class="ce10"> </td><td style="text-align:left;width:3.1382in; " class="ce10"> </td><td style="text-align:left;width:1.9492in; " class="ce10"> </td><td style="text-align:left;width:1.6409in; " class="ce10"> </td><td style="text-align:left;width:1.9929in; " class="ce10"> </td><td style="text-align:left;width:2.6098in; " class="ce10"> </td><td style="text-align:left;width:1.3429in; " class="ce10"> </td><td style="text-align:left;width:0.8917in; " class="ce10"> </td><td style="text-align:left;width:0.8917in; " class="ce20"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce10"> </td><td style="text-align:left;width:1.1783in; " class="ce13"> </td><td style="text-align:left;width:0.8917in; " class="ce15"> </td><td style="text-align:left;width:3.3693in; " class="ce10"> </td><td style="text-align:left;width:3.0945in; " class="ce17"> </td><td style="text-align:left;width:1.6075in; " class="ce10"> </td><td style="text-align:left;width:3.1382in; " class="ce10"> </td><td style="text-align:left;width:1.9492in; " class="ce10"> </td><td style="text-align:left;width:1.6409in; " class="ce10"> </td><td style="text-align:left;width:1.9929in; " class="ce10"> </td><td style="text-align:left;width:2.6098in; " class="ce10"> </td><td style="text-align:left;width:1.3429in; " class="ce10"> </td><td style="text-align:left;width:0.8917in; " class="ce10"> </td><td style="text-align:left;width:0.8917in; " class="ce20"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce7"> </td><td style="text-align:left;width:1.1783in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:3.3693in; " class="ce7"> </td><td style="text-align:left;width:3.0945in; " class="ce7"> </td><td style="text-align:left;width:1.6075in; " class="ce7"> </td><td style="text-align:left;width:3.1382in; " class="ce7"> </td><td style="text-align:left;width:1.9492in; " class="ce7"> </td><td style="text-align:left;width:1.6409in; " class="ce7"> </td><td style="text-align:left;width:1.9929in; " class="ce7"> </td><td style="text-align:left;width:2.6098in; " class="ce7"> </td><td style="text-align:left;width:1.3429in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce7"> </td><td style="text-align:left;width:1.1783in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:3.3693in; " class="ce7"> </td><td style="text-align:left;width:3.0945in; " class="ce7"> </td><td style="text-align:left;width:1.6075in; " class="ce7"> </td><td style="text-align:left;width:3.1382in; " class="ce7"> </td><td style="text-align:left;width:1.9492in; " class="ce7"> </td><td style="text-align:left;width:1.6409in; " class="ce7"> </td><td style="text-align:left;width:1.9929in; " class="ce7"> </td><td style="text-align:left;width:2.6098in; " class="ce7"> </td><td style="text-align:left;width:1.3429in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce7"> </td><td style="text-align:left;width:1.1783in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:3.3693in; " class="ce7"> </td><td style="text-align:left;width:3.0945in; " class="ce7"> </td><td style="text-align:left;width:1.6075in; " class="ce7"> </td><td style="text-align:left;width:3.1382in; " class="ce7"> </td><td style="text-align:left;width:1.9492in; " class="ce7"> </td><td style="text-align:left;width:1.6409in; " class="ce7"> </td><td style="text-align:left;width:1.9929in; " class="ce7"> </td><td style="text-align:left;width:2.6098in; " class="ce7"> </td><td style="text-align:left;width:1.3429in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce7"> </td><td style="text-align:left;width:1.1783in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:3.3693in; " class="ce7"> </td><td style="text-align:left;width:3.0945in; " class="ce7"> </td><td style="text-align:left;width:1.6075in; " class="ce7"> </td><td style="text-align:left;width:3.1382in; " class="ce7"> </td><td style="text-align:left;width:1.9492in; " class="ce7"> </td><td style="text-align:left;width:1.6409in; " class="ce7"> </td><td style="text-align:left;width:1.9929in; " class="ce7"> </td><td style="text-align:left;width:2.6098in; " class="ce7"> </td><td style="text-align:left;width:1.3429in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce7"> </td><td style="text-align:left;width:1.1783in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:3.3693in; " class="ce7"> </td><td style="text-align:left;width:3.0945in; " class="ce7"> </td><td style="text-align:left;width:1.6075in; " class="ce7"> </td><td style="text-align:left;width:3.1382in; " class="ce7"> </td><td style="text-align:left;width:1.9492in; " class="ce7"> </td><td style="text-align:left;width:1.6409in; " class="ce7"> </td><td style="text-align:left;width:1.9929in; " class="ce7"> </td><td style="text-align:left;width:2.6098in; " class="ce7"> </td><td style="text-align:left;width:1.3429in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce7"> </td><td style="text-align:left;width:1.1783in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:3.3693in; " class="ce7"> </td><td style="text-align:left;width:3.0945in; " class="ce7"> </td><td style="text-align:left;width:1.6075in; " class="ce7"> </td><td style="text-align:left;width:3.1382in; " class="ce7"> </td><td style="text-align:left;width:1.9492in; " class="ce7"> </td><td style="text-align:left;width:1.6409in; " class="ce7"> </td><td style="text-align:left;width:1.9929in; " class="ce7"> </td><td style="text-align:left;width:2.6098in; " class="ce7"> </td><td style="text-align:left;width:1.3429in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce7"> </td><td style="text-align:left;width:1.1783in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:3.3693in; " class="ce7"> </td><td style="text-align:left;width:3.0945in; " class="ce7"> </td><td style="text-align:left;width:1.6075in; " class="ce7"> </td><td style="text-align:left;width:3.1382in; " class="ce7"> </td><td style="text-align:left;width:1.9492in; " class="ce7"> </td><td style="text-align:left;width:1.6409in; " class="ce7"> </td><td style="text-align:left;width:1.9929in; " class="ce7"> </td><td style="text-align:left;width:2.6098in; " class="ce7"> </td><td style="text-align:left;width:1.3429in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce7"> </td><td style="text-align:left;width:1.1783in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:3.3693in; " class="ce7"> </td><td style="text-align:left;width:3.0945in; " class="ce7"> </td><td style="text-align:left;width:1.6075in; " class="ce7"> </td><td style="text-align:left;width:3.1382in; " class="ce7"> </td><td style="text-align:left;width:1.9492in; " class="ce7"> </td><td style="text-align:left;width:1.6409in; " class="ce7"> </td><td style="text-align:left;width:1.9929in; " class="ce7"> </td><td style="text-align:left;width:2.6098in; " class="ce7"> </td><td style="text-align:left;width:1.3429in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce6"> </td><td style="text-align:left;width:1.8827in; " class="ce7"> </td><td style="text-align:left;width:1.1783in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:3.3693in; " class="ce7"> </td><td style="text-align:left;width:3.0945in; " class="ce7"> </td><td style="text-align:left;width:1.6075in; " class="ce7"> </td><td style="text-align:left;width:3.1382in; " class="ce7"> </td><td style="text-align:left;width:1.9492in; " class="ce7"> </td><td style="text-align:left;width:1.6409in; " class="ce7"> </td><td style="text-align:left;width:1.9929in; " class="ce7"> </td><td style="text-align:left;width:2.6098in; " class="ce7"> </td><td style="text-align:left;width:1.3429in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce7"> </td><td style="text-align:left;width:1.8827in; " class="ce7"> </td><td style="text-align:left;width:1.1783in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:3.3693in; " class="ce7"> </td><td style="text-align:left;width:3.0945in; " class="ce7"> </td><td style="text-align:left;width:1.6075in; " class="ce7"> </td><td style="text-align:left;width:3.1382in; " class="ce7"> </td><td style="text-align:left;width:1.9492in; " class="ce7"> </td><td style="text-align:left;width:1.6409in; " class="ce7"> </td><td style="text-align:left;width:1.9929in; " class="ce7"> </td><td style="text-align:left;width:2.6098in; " class="ce7"> </td><td style="text-align:left;width:1.3429in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:1.7618in; " class="ce7"> </td><td style="text-align:left;width:1.8827in; " class="ce7"> </td><td style="text-align:left;width:1.1783in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:3.3693in; " class="ce7"> </td><td style="text-align:left;width:3.0945in; " class="ce7"> </td><td style="text-align:left;width:1.6075in; " class="ce7"> </td><td style="text-align:left;width:3.1382in; " class="ce7"> </td><td style="text-align:left;width:1.9492in; " class="ce7"> </td><td style="text-align:left;width:1.6409in; " class="ce7"> </td><td style="text-align:left;width:1.9929in; " class="ce7"> </td><td style="text-align:left;width:2.6098in; " class="ce7"> </td><td style="text-align:left;width:1.3429in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr></table><table border="0" cellspacing="0" cellpadding="0" class="ta2"><colgroup><col width="99"/><col width="99"/></colgroup><tr class="ro35"><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:0.8917in; " class="ce7"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr></table></body></html>
