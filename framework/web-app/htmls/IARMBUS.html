<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.modified" content="2014-04-01T13:44:02" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:10pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.ta1 { writing-mode:lr-tb; }
	.ta2 { writing-mode:lr-tb; }
	.ta3 { writing-mode:lr-tb; }
	.Default { font-family:Arial; padding:0.028in; }
	.ce1 { background-color:#558ed5; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce2 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce3 { padding:0.028in; font-family:Arial; }
	.ce4 { background-color:#ffffff; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce5 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce6 { background-color:#ffffff; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce7 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.co1 { width:1.2335in; }
	.co10 { width:1.6409in; }
	.co11 { width:1.9929in; }
	.co12 { width:1.6957in; }
	.co13 { width:1.3429in; }
	.co2 { width:1.8827in; }
	.co3 { width:1.1783in; }
	.co4 { width:0.8917in; }
	.co5 { width:3.3693in; }
	.co6 { width:3.0945in; }
	.co7 { width:1.6075in; }
	.co8 { width:3.1382in; }
	.co9 { width:1.9492in; }
	.ro1 { height:0.6335in; }
	.ro10 { height:2.3425in; }
	.ro11 { height:2.5075in; }
	.ro12 { height:3.0055in; }
	.ro13 { height:4.3319in; }
	.ro14 { height:3.5028in; }
	.ro15 { height:4.5189in; }
	.ro16 { height:4.3728in; }
	.ro17 { height:2.1764in; }
	.ro18 { height:3.7839in; }
	.ro19 { height:2.0102in; }
	.ro2 { height:2.6126in; }
	.ro20 { height:4.498in; }
	.ro21 { height:2.8398in; }
	.ro22 { height:3.6689in; }
	.ro23 { height:2.3437in; }
	.ro24 { height:2.4898in; }
	.ro25 { height:2.3752in; }
	.ro26 { height:2.3646in; }
	.ro27 { height:2.4563in; }
	.ro28 { height:2.4146in; }
	.ro29 { height:2.4354in; }
	.ro3 { height:2.7972in; }
	.ro30 { height:2.4772in; }
	.ro31 { height:2.5709in; }
	.ro32 { height:4.0008in; }
	.ro33 { height:0.1783in; }
	.ro4 { height:3.0992in; }
	.ro5 { height:5.689in; }
	.ro6 { height:3.5161in; }
	.ro7 { height:3.3366in; }
	.ro8 { height:3.8346in; }
	.ro9 { height:3.1717in; }
	.T1 { color:#000000; font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.T2 { color:#ffffff; font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:underline; font-weight:bold; }
	.T3 { color:#ffffff; font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:bold; }
	.T4 { color:#000000; font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:underline; font-weight:normal; }
	.T5 { font-family:Times New Roman; font-size:12pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	<!-- ODF styles with no properties representable as CSS -->
	 { }
	</style></head><body dir="ltr" style="max-width:8.5in;margin-top:0.7874in; margin-bottom:0.7874in; margin-left:0.7874in; margin-right:0.7874in; writing-mode:lr-tb; "><table border="0" cellspacing="0" cellpadding="0" class="ta1"><colgroup><col width="137"/><col width="209"/><col width="131"/><col width="99"/><col width="374"/><col width="343"/><col width="178"/><col width="348"/><col width="216"/><col width="182"/><col width="221"/><col width="188"/><col width="149"/><col width="99"/><col width="99"/></colgroup><tr class="ro1"><td style="text-align:left;width:1.2335in; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:1.8827in; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:1.1783in; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:0.8917in; " class="ce1"><p>Test Setup</p></td><td style="text-align:left;width:3.3693in; " class="ce1"><p>API's / Interface Used</p></td><td style="text-align:left;width:3.0945in; " class="ce1"><p>Input Parameters</p><p>(<span class="T2">API name</span><span class="T3">: parameter type – value) / </span></p><p><span class="T3">Interface Input</span></p></td><td style="text-align:left;width:1.6075in; " class="ce1"><p>Pre-requisite</p></td><td style="text-align:left;width:3.1382in; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:1.9492in; " class="ce1"><p>Exp Output</p></td><td style="text-align:left;width:1.6409in; " class="ce1"><p>Priority</p></td><td style="text-align:left;width:1.9929in; " class="ce1"><p>Test Stub Interface</p></td><td style="text-align:left;width:1.6957in; " class="ce1"><p>Test script</p></td><td style="text-align:left;width:1.3429in; " class="ce1"><p>Remarks</p></td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_1</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Joining application with IARMBUS </p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.  </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Connect &amp; Disconnect test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_2</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Joining application with IARMBUS where the application is already joined with the IARMBUS.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent will try to register the application which is already registered with the Process group.</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Init Negative test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro4"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_3</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Checking process registration status with UI Manager</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_IsConnected(const char *, int *)</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_IsConnected</span><span class="T1"> : </span></p><p><span class="T1">Char - *memberName, int * - isRegistered</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent checks for Registration of process with UI Manager. </p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_IsConnected</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS IsConnected test</p></td><td style="text-align:left;width:1.3429in; " class="ce5"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_4</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – deregister event handler for removing listener for an event.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :  </span></p><p><span class="T1">const char - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> - None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> - None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregisters the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS unregisterEvt Handler test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_5</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – deregister event handler without registering event handler.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce2"><p> </p><p><span class="T4">IARM_Bus_Init</span><span class="T1"> : </span></p><p><span class="T1">char *-(test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :  </span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>4.IARMBUS_Agent deregister the event handler.</p><p>5.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for failure status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Unregister with out Register Event Handler test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro7"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_6</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Releasing acquired resource by a process.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char *, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :       </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t -  IR_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :  </span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> - None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> - None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent will register for “IARM_BUS_IRMGR_EVENT_IRKEY” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.IARMBUS_Agent deregister the event handler.</p><p>6.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p> </p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Release Resource test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro8"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_7</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Requesting for a resource which is already allocated for another application.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon ( First application) .</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application).</p><p>4.Second application will request and acquire  “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>5.IARMBUS_Agent application will request for a resource which is currently acquired by second application.</p><p>6.Second application will release the resource and the resource will be utilized by IARMBUS_Agent application.</p><p>7.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>8.Both the applications  deregister from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Request same resource in different application test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_8</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Requesting a resource from the application for which, the same resource  is already allocated .</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> :</span><span class="T4"> </span><span class="T1">IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent request for a resource “IARM_BUS_RESOURCE_FOCUS”.</p><p>4.IARMBUS_Agent will again request for the same resource “IARM_BUS_RESOURCE_FOCUS” before releasing it.</p><p>5.IARMBUS_Agent will release the resource “IARM_BUS_RESOURCE_FOCUS”</p><p>6.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for failure status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Request same resource from same application test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_9</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS -Request for Decoder-0 resource.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_0</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_0</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_DECODER_0.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_DECODER_0.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Request decoder-0 test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_10</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS -Request for Decoder-1 resource.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_1</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_DECODER_1</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_DECODER_1.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_DECODER_1.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Request decoder-1 test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_11</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS -Request for Graphics plane-0 resource.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">Char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_PLANE_0</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_PLANE_0</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_PLANE_0.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_PLANE_0.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Request graphics plane-0 test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_12</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS -Request for Graphics plane-1 resource.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_PLANE_1</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_PLANE_1</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_PLANE_1.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_PLANE_1.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Request graphics plane-1 test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_13</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS - Request for display resolution change<span class="T1"> resource.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_RESOLUTION</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_RESOLUTION</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_RESOLUTION.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_RESOLUTION.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Request display_resolution_change  test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_14</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS - Request for power<span class="T1"> resource.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">Char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t -</span></p><p><span class="T1">IARM_BUS_RESOURCE_POWER</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_POWER</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will request for resource IARM_BUS_RESOURCE_POWER.</p><p>4.IARMBUS_Agent will release resource IARM_BUS_RESOURCE_POWER.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce2"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p> </p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Request power  test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro11"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_15</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Registering an RPC method that can be invoked by other applications.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterCall(const char *, IARM_BusCall_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_RegisterCall</span><span class="T1"> : </span></p><p><span class="T1">const char * -</span><span class="T4"> </span><span class="T1">IARM_BUS_COMMON_API_ReleaseOwnership</span></p><p><span class="T1">IARM_BusCall_t- releaseOwnershipHandler</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.IARMBUS_Agent registers a RPC methods for releasing the resource that can be invoked by other application.</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RegisterCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS RegisterCall test</p></td><td style="text-align:left;width:1.3429in; " class="ce5"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro12"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_16</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Invoke RPC methods that is registered in another application.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterCall(const char *, IARM_BusCall_t )</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_RegisterCall</span><span class="T1"> : </span></p><p><span class="T1">const char * -</span><span class="T4"> </span><span class="T1">IARM_BUS_PWRMGR_API_GetPowerState</span></p><p><span class="T1">IARM_BusCall_t - _GetPowerStatecallback</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char *- IARM_BUS_PWRMGR_NAME,     const char * - IARM_BUS_PWRMGR_API_GetPowerState  , void * -param, size_t - sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2.“pwrMgrMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon. </p><p>3.pwrMgrMain registers a RPC methods for setting the power state and this RPC can be invoked by IARMBUS_Agent application.</p><p>5.IARMBUS_Agent Invoke the RPC method of pwrMgrMain application to get the power state of STB. </p><p>6.IARMBUS_Agent deregister from the IARM Bus Daemon.</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RegisterCall</p><p>6.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS BusCall test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_17</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting the event to application through IARMBus .</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce2"><p> </p><p><span class="T4">IARM_Bus_Init</span><span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">ARM_Bus_RegisterEventHandler</span><span class="T1"> :</span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME, IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY, IARM_EventHandler_t - IR_event_callback</span></p><p><span class="T4">IARM_Bus_BroadcastEvent</span><span class="T1"> :</span></p><p><span class="T1">const char *- IARM_BUS_IRMGR_NAME, IARM_EventId_t -  IARM_BUS_IRMGR_EVENT_IRKEY, </span></p><p><span class="T1">Void *- eventData, size_t- sizeof(eventData) </span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> :</span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t - IARM_BUS_IRMGR_EVENT_IRKEY</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2.“pwrMgrMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (first application). </p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application).</p><p>4.Second application will publish “IARM_BUS_IRMGR_EVENT_IRKEY “ to the IARMBUS_Agent.</p><p>5.IARMBUS_Agent will register for IR key events.</p><p>6.The IARMBUS_Agent should receive the IR key notification. On notification, IARMBUS_Agent keeps value of last received key.</p><p>7.IARMBUS_Agent will deregisters the event handler.</p><p>8.TM makes RPC call for getting last received from first applications.</p><p>9.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>10.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2</span><span class="T1">.Check for the correct key name for the key code received for both the test applications.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>9.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Broadcast IR event</p></td><td style="text-align:left;width:1.3429in; " class="ce5"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_18</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Receiving  HDD event while mounting and unmounting an  HDD</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :</span></p><p><span class="T1">const char * -  IARM_BUS_DISKMGR_NAME, IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_HWDISK IARM_EventHandler_t - HDD_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char* -  IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t - IARM_BUS_DISKMGR_EVENT_HWDISK</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. ”IARMDaemonMain” process should be running.</p><p> </p><p>2.ExtHDD Component should be up.</p><p> </p><p>3.“diskManager” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “IARM_BUS_DISKMGR_EVENT_HWDISK” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.The Test Agent mounts the  HDD using the mount command.</p><p>6.IARMBUS_Agent deregister the event handler.</p><p>7.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>8.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>9.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS HDD event test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro15"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_19</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Receiving Ext HDD event while mounting and unmounting an ext HDD</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char *, IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :</span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME, IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD, IARM_EventHandler_t - ExtHDD_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DISKMGR_EVENT_EXTHDD,</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. ”IARMDaemonMain” process should be running.</p><p> </p><p>2.ExtHDD Component should be up.</p><p> </p><p>3.“diskManager” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “IARM_BUS_DISKMGR_EVENT_EXTHDD” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.The Test Agent mounts the  Ext HDD using the mount command.</p><p>6.IARMBUS_Agent deregister the event handler.</p><p>7.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>8.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>9.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS ExtHDD event</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro16"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_20</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Registering the Ext HDD event for Pairing. </p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :</span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME, IARM_EventId_t – DISKMGR_EVENT_EXTHDD_PAIR, IARM_EventHandler_t - ExtHDD_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – DISKMGR_EVENT_EXTHDD_PAIR,</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. ”IARMDaemonMain” process should be running.</p><p> </p><p>2.ExtHDD Component should be up.</p><p> </p><p><span class="T1">3.“diskManager” process should be running.</span></p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “DISKMGR_EVENT_EXTHDD_PAIR” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.The Test Agent mounts the  Ext HDD using the mount command.</p><p>6.IARMBUS_Agent deregister the event handler.</p><p>7.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>8.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>9.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS ExtHDD paring event test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_21</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARM – Registering the Ext HDD event for EXTHDD_ON</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char *, IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char *, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :</span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME, IARM_EventId_t – DISKMGR_EVENT_EXTHDD_ON, IARM_EventHandler_t - ExtHDD_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char*- IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – DISKMGR_EVENT_EXTHDD_ON,</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. ”IARMDaemonMain” process should be running.</p><p> </p><p>2.ExtHDD Component should be up.</p><p> </p><p><span class="T1">3.“diskManager” process should be running.</span></p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “DISKMGR_EVENT_EXTHDD_ON” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.The Test Agent mounts the  Ext HDD using the mount command.</p><p>6.IARMBUS_Agent deregister the event handler.</p><p>7.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>8.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>9.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Ext HDD ON Event test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_22</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARM – Registering the Ext HDD event for EXTHDD_OFF. </p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p> </p><p><span class="T1">IARM_Bus_Init(char *)</span></p><p><span class="T1">IARM_Bus_Connect()</span></p><p><span class="T1">IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</span></p><p><span class="T1">IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> :</span></p><p><span class="T1">const char * - IARM_BUS_DISKMGR_NAME, IARM_EventId_t – DISKMGR_EVENT_EXTHDD_OFF, IARM_EventHandler_t - ExtHDD_event_callback</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_DISKMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – DISKMGR_EVENT_EXTHDD_OFF,</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. ”IARMDaemonMain” process should be running.</p><p> </p><p>2.ExtHDD Component should be up.</p><p> </p><p><span class="T1">3.“diskManager” process should be running.</span></p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “DISKMGR_EVENT_EXTHDD_OFF” event and waits on event.</p><p>4.IARMBUS_Agent will request for “IARM_BUS_RESOURCE_FOCUS” resource</p><p>5.The Test Agent mounts the  Ext HDD using the mount command.</p><p>6.IARMBUS_Agent deregister the event handler.</p><p>7.IARMBUS_Agent will release “IARM_BUS_RESOURCE_FOCUS” resource.</p><p>8.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T1"/></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>9.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Ext HDD OFF event test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro17"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_23</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying Key Repeat Interval time for STB</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME,</span></p><p><span class="T1">Const char * - IARM_BUS_IRMGR_API_GetRepeatInterval</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>4.IARMBUS_Agent will invoke the RPC method for querying the key repeat interval time.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Query Key Repeat Interval test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_24</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Setting Key Repeat Interval time for STB .</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_NAME,</span></p><p><span class="T1">const char * - IARM_BUS_IRMGR_API_GetRepeatInterval,</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_NAME  </span></p><p><span class="T1">const char* - IARM_BUS_IRMGR_API_SetRepeatInterval</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p>2. “irMgrMain” Process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent will invoke the RPC for getting the key repeat interval time.  </p><p>4.IARMBUS_Agent will return the Key Repeat Interval to the Test Agent.</p><p>5.IARMBUS_Agent will set key repeat time.</p><p><span class="T1">6.IARMBUS_Agent will invoke the RPC for getting the key repeat interval time.</span></p><p><span class="T1">7.IARMBUS_Agent will return the Key Repeat Interval to the Test Agent.  </span></p><p><span class="T1">8.Test Agent will compare the Key Repeat Interval time before and after setting it.</span></p><p><span class="T1">9.IARMBUS_Agent deregisters from the IARM Bus Daemon.</span></p><p><span class="T1">10.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2</span><span class="T1">.Check the Key Repeat  interval before and after setting the value.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Set Key Repeat Interval test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro19"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_25</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying the   Power state of STB from the process.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()  </span></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> :</span></p><p><span class="T1">const char* - IARM_BUS_PWRMGR_NAME,     const char* - </span></p><p><span class="T1">IARM_BUS_PWRMGR_API_GetPowerState,</span></p><p><span class="T1">void * -param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p><span class="T1">2.“pwrMgrMain” process should be running.</span></p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent Invoke the RPC call for getting the Power state of STB.</p><p>4.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>5.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1<span class="T1">.</span><span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2</span><span class="T1">.Check the Power state before and after pressing the power key</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Query Power state</p></td><td style="text-align:left;width:1.3429in; " class="ce5"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro20"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_26</p></td><td style="text-align:left;width:1.8827in; " class="ce4"><p>IARMBUS- Setting the Power state of STB from the process.</p></td><td style="text-align:left;width:1.1783in; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterCall<span class="T1">(const char *methodName, IARM_BusCall_t handler)</span></p><p><span class="T1">IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</span></p><p><span class="T1">IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</span></p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">IARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()  </span></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_PWRMGR_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_PWRMGR_API_SetPowerState,</span></p><p><span class="T1">Void * - param,size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_PWRMGR_NAME , IARM_EventId_t - IARM_BUS_PWRMGR_EVENT_MODECHANGED ,</span></p><p><span class="T1">IARM_EventHandler_t - _handler_Powermodechanged </span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler </span><span class="T1">: </span></p><p><span class="T1">const char* - IARM_BUS_PWRMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t - IARM_BUS_PWRMGR_EVENT_MODECHANGED</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* IARM_BUS_PWRMGR_NAME, const char* - </span></p><p><span class="T1">IARM_BUS_PWRMGR_API_GetPowerState,</span></p><p><span class="T1">void * -param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>IARMDaemonMain process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce4"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon . </p><p>3.IARMBUS_Agent will register for “IARM_BUS_PWRMGR_EVENT_MODECHANGED” event and waits on event.</p><p>4. TM makes RPC calls for getting the power state from IARMBUS_Agent</p><p>5.TM makes RPC calls for setting the new power state from IARMBUS_Agent</p><p>6.TM makes RPC calls for querying the latest power state from IARMBUS_Agent .</p><p>7.TM  compares the two power state for successful change in the power state</p><p>8.TM queries the last received event details to get the "IARM_BUS_PWRMGR_EVENT_MODECHANGED"event.</p><p>9.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>10.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce6"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2</span><span class="T1">.Check the Power state before and after setting the power state using API.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint3:</span><span class="T1">Check whether the IARM_BUS_PWRMGR_EVENT_MODECHANGED event is received</span></p></td><td style="text-align:left;width:1.6409in; " class="ce4"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_GetLastReceivedEventDetails</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Set Power state</p></td><td style="text-align:left;width:1.3429in; " class="ce4"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro21"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_27</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Registering all the Events before publishing and receiving events.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEvent(int )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_RegisterEvent</span><span class="T1"> :</span></p><p><span class="T1">Int - IARM_BUS_IRMGR_EVENT_MAX</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register all the events ie maximum number of events that any manager can have.</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RegisterEvent</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS RegisterEventMax</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro22"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_28</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Receiving “RESOURCE AVAILABLE” event.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_BusDaemon_RequestOwnership(IARM_Bus_ResrcType_t )</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_BusDaemon_ReleaseOwnership(IARM_Bus_ResrcType_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_BusDaemon_RequestOwnership</span><span class="T1"> :</span><span class="T4"> </span><span class="T1">IARM_Bus_ResrcType_t - IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMON_NAME , IARM_EventId_t - IARM_BUS_EVENT_RESOURCEAVAILABLE, IARM_EventHandler_t - _handler_ResourceAvailable </span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_DAEMON_NAME, IARM_EventId_t – IARM_BUS_EVENT_RESOURCEAVAILABLE</span></p><p><span class="T4">IARM_BusDaemon_ReleaseOwnership</span><span class="T1"> : IARM_Bus_ResrcType_t – IARM_BUS_RESOURCE_FOCUS</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOURCEAVAILABLE” event and waits on event.</p><p>5.Second application will release the resource.</p><p>6.IARMBUS_Agent should receive “RESOURCE AVAILABLE” event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_RequestResource</p><p>6.TestMgr_IARMBUS_ReleaseResource</p><p>7.TestMgr_IARMBUS_RegisterEventHandler</p><p>8.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>9.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBBUS Register for Resource Available event test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro22"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_29</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving “<span class="T1">RESOLUTIONCHANGE</span><span class="T1">” event.</span></p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_DAEMON_NAME , IARM_EventId_t - IARM_BUS_EVENT_RESOLUTIONCHANGE, IARM_EventHandler_t - _handler_ResolutionChange </span></p><p><span class="T4">IARM_Bus_BroadcastEvent</span><span class="T1"> :</span></p><p><span class="T1">Const char* - IARM_BUS_DAEMON_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_EVENT_RESOLUTIONCHANGE ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char* – IARM_BUS_DAEMON_NAME , IARM_EventId_t – IARM_BUS_EVENT_RESOLUTIONCHANGE</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>8.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS Broadcast ResolutionChange Event test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro23"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_30</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) manufacture name.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GET_MFRDATA,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_MANUFACTURER,</span></p><p><span class="T1">size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> – None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> – None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board manufacture name. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS BusCall MFR-STB Manufature Name test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro24"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_31</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) manufacture OUI(</p><p>Organizationally Unique Identifier).</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GET_MFRDATA,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_MANUFACTUREROUI ,</span></p><p><span class="T1">size_t - sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> – None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> – None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board manufacture OUI(Originally Unique Identifier). </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS BusCall MFR-OUI test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro25"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_32</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) model name.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GET_MFRDATA,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_MODELNAME,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> – None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> – None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board model name. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS BusCall MFR-Model Name test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro26"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_33</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) description.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GET_MFRDATA,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_DESCRIPTION,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> – None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> – None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board description. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS BusCall MFR-Board description test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro26"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_34</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) product class.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GET_MFRDATA,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_PRODUCTCLASS,</span></p><p><span class="T1">size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> – None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> – None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board product class. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS BusCall MFR-Board Product Class test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_35</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) serial number .</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GET_MFRDATA,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_SERIALNUMBER,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> – None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> – None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board serial number. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS BusCall MFR-SerialNumber test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro28"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_36</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) hardware version.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GET_MFRDATA,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_HARDWAREVERSION,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> – None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> – None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board hardware version. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS BusCall MFR-Hardware version test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro29"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_37</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) software version.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GET_MFRDATA,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_SOFTWAREVERSION,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> – None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> – None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board software version. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS BusCall MFR-Software version test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro30"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_38</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) provisioning code.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GET_MFRDATA,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_PROVISIONINGCODE,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> – None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> – None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board provisioning code. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS BusCall MFR- Provision Code test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro31"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_39</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Querying board (STB) First Use Date.</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p><span class="T1">IARM_Bus_Call(const char *,  const char *, void *, size_t )</span></p><p><span class="T1">ARM_Bus_Disconnect()</span></p><p><span class="T1">IARM_Bus_Term()</span></p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char* - IARM_BUS_MFRLIB_NAME, const char*-</span></p><p><span class="T1">IARM_BUS_MFRLIB_API_GET_MFRDATA,</span></p><p><span class="T1">Void * - IARM_BUS_MFR_SERIALIZED_TYPE_FIRSTUSEDATE,</span></p><p><span class="T1">Size_t sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> – None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> – None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1.”IARMDaemonMain” process should be running.</p><p> </p><p>2."mfrMgrMain" process should be running</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon .</p><p>3.IARMBUS_Agent invokes the RPC method for querying board last use date. </p><p>4.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS BusCall MFR-First Use Date test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro31"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_40</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Creating and Calling Dummy RPC calls for 'x' times</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p><p> </p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *) </p><p>IARM_Bus_Connect()</p><p>IARM_Bus_Call(const char *,  const char *, void *, size_t )</p><p>IARM_Bus_RegisterCall(const char *methodName, IARM_BusCall_t handler)</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()  </p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Call</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_DUMMYMGR_NAME,</span></p><p><span class="T1">Const char * - IARM_BUS_DUMMYMGR_API_DummyAPI0</span></p><p><span class="T1">void * - param, size_t -sizeof(param)</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>1. “IARMDaemonMain” Process should be running.</p><p> </p><p> </p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent.</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon(First Application). </p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which Registers the Dummy RPC calls) .</p><p>4.IARMBUS_Agent will invoke the Dummy RPC method .</p><p>5.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>6. Repeat steps 3-5 for 'x' times</p><p>7.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BusCall</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS_DummyCall_Persistent_test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:1.2335in; " class="ce2"><p>CT_IARMBUS_41</p></td><td style="text-align:left;width:1.8827in; " class="ce2"><p>IARMBUS – Broadcasting and Receiving of Dummy Event for 'x' times</p></td><td style="text-align:left;width:1.1783in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8917in; " class="ce2"><p>XI3-1 / XG1-1</p></td><td style="text-align:left;width:3.3693in; " class="ce2"><p>IARM_Bus_Init(char *)</p><p>IARM_Bus_Connect()</p><p>IARM_Bus_RegisterEventHandler(const char* , IARM_EventId_t , IARM_EventHandler_t )</p><p>IARM_Bus_BroadcastEvent(const char *, IARM_EventId_t , void *, size_t )</p><p>IARM_Bus_UnRegisterEventHandler(const char*, IARM_EventId_t )</p><p>IARM_Bus_Disconnect()</p><p>IARM_Bus_Term()</p></td><td style="text-align:left;width:3.0945in; " class="ce5"><p>IARM_Bus_Init<span class="T1"> : </span></p><p><span class="T1">char *  - (test agent process_name)</span></p><p><span class="T4">IARM_Bus_Connect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_RegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char * - IARM_BUS_DUMMYMGR_NAME , IARM_EventId_t - IARM_BUS_DUMMYMGR_EVENT_DUMMYX, IARM_EventHandler_t - _handler_ResolutionChange </span></p><p><span class="T4">IARM_Bus_BroadcastEvent</span><span class="T1"> :</span></p><p><span class="T1">Const char* - IARM_BUS_DUMMYMGR_NAME,</span></p><p><span class="T1">IARM_EventId_t – IARM_BUS_DUMMYMGR_EVENT_DUMMYX ,</span></p><p><span class="T1">Void * - eventdata, size_t – sizeof (eventdata)</span></p><p><span class="T4">IARM_Bus_UnRegisterEventHandler</span><span class="T1"> : </span></p><p><span class="T1">const char* – IARM_BUS_DUMMYMGR_NAME , IARM_EventId_t – IARM_BUS_DUMMYMGR_EVENT_DUMMYX</span></p><p><span class="T4">IARM_Bus_Disconnect</span><span class="T1"> : None</span></p><p><span class="T4">IARM_Bus_Term</span><span class="T1"> : None</span></p><p><span class="T1"/></p></td><td style="text-align:left;width:1.6075in; " class="ce2"><p>“IARMDaemonMain” process should be running.</p></td><td style="text-align:left;width:3.1382in; " class="ce2"><p>1.TM loads the IARMBUS_Agent via the test agent</p><p>2.The IARMBUS_Agent initializes and registers with IARM Bus Daemon (First Application).</p><p>3.TM loads(initializes and registers) another application with IARM Daemon(second application which broadcasts the Dummy events) .</p><p>4.IARMBUS_Agent will register for “IARM_BUS_EVENT_RESOLUTIONCHANGE” event and waits on event.</p><p>5.Second application will broadcast the event to the bus.</p><p>6.IARMBUS_Agent should receive the event and event handler should handle the event(printing some log message) .</p><p>7. Repeat steps3 to 6 for 'x' times .</p><p>8.IARMBUS_Agent deregisters from the IARM Bus Daemon.</p><p>9.For each API called in the script, IARMBUS_Agent will send SUCCESS or FAILURE status to Test Agent by comparing the return vale of APIs.</p><p> </p></td><td style="text-align:left;width:1.9492in; " class="ce5"><p>Checkpoint 1.<span class="T1">Check the return value of API for success status.</span></p><p><span class="T1"/></p><p><span class="T4">Checkpoint 2.</span><span class="T1"> Check for  the print  message.</span></p></td><td style="text-align:left;width:1.6409in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.9929in; " class="ce2"><p>libiarmbusstub.so</p><p>1.TestMgr_IARMBUS_Init</p><p>2.TestMgr_IARMBUS_Term</p><p>3.TestMgr_IARMBUS_Connect</p><p>4.TestMgr_IARMBUS_Disconnect</p><p>5.TestMgr_IARMBUS_BroadcastEvent</p><p>6.TestMgr_IARMBUS_RegisterEventHandler</p><p>7.TestMgr_IARMBUS_UnRegisterEventHandler</p><p>8.TestMgr_IARMBUS_InvokeSecondApplication</p></td><td style="text-align:left;width:1.6957in; " class="ce7"><p>IARMBUS_DummyEvt_Persistent_test</p></td><td style="text-align:left;width:1.3429in; " class="ce2"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.2335in; " class="ce3"> </td><td style="text-align:left;width:1.8827in; " class="ce3"> </td><td style="text-align:left;width:1.1783in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:3.3693in; " class="ce3"> </td><td style="text-align:left;width:3.0945in; " class="ce3"> </td><td style="text-align:left;width:1.6075in; " class="ce3"> </td><td style="text-align:left;width:3.1382in; " class="ce3"> </td><td style="text-align:left;width:1.9492in; " class="ce3"> </td><td style="text-align:left;width:1.6409in; " class="ce3"> </td><td style="text-align:left;width:1.9929in; " class="ce3"> </td><td style="text-align:left;width:1.6957in; " class="ce3"> </td><td style="text-align:left;width:1.3429in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:1.2335in; " class="ce3"> </td><td style="text-align:left;width:1.8827in; " class="ce3"> </td><td style="text-align:left;width:1.1783in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:3.3693in; " class="ce3"> </td><td style="text-align:left;width:3.0945in; " class="ce3"> </td><td style="text-align:left;width:1.6075in; " class="ce3"> </td><td style="text-align:left;width:3.1382in; " class="ce3"> </td><td style="text-align:left;width:1.9492in; " class="ce3"> </td><td style="text-align:left;width:1.6409in; " class="ce3"> </td><td style="text-align:left;width:1.9929in; " class="ce3"> </td><td style="text-align:left;width:1.6957in; " class="ce3"> </td><td style="text-align:left;width:1.3429in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr></table><table border="0" cellspacing="0" cellpadding="0" class="ta2"><colgroup><col width="99"/><col width="99"/></colgroup><tr class="ro33"><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr></table><table border="0" cellspacing="0" cellpadding="0" class="ta3"><colgroup><col width="99"/><col width="99"/></colgroup><tr class="ro33"><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:0.8917in; " class="ce3"> </td><td style="text-align:left;width:0.8917in; " class="Default"> </td></tr></table></body></html>
