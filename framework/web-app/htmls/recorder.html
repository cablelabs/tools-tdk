<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="Dinesh Pandian"/><meta name="DCTERMS.issued" content="2014-05-13T09:28:40" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="Mohita Singh"/><meta name="DCTERMS.modified" content="2015-07-30T08:59:51" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:10pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.ta1 { writing-mode:lr-tb; }
	.ta2 { writing-mode:lr-tb; }
	.ta3 { writing-mode:lr-tb; }
	.Default { font-family:Arial; padding:2.01pt; }
	.ce1 { background-color:#558ed5; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce10 { padding:2.01pt; font-family:Arial; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce11 { background-color:#558ed5; border-style:none; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:center ! important; }
	.ce12 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce13 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:justify ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce14 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce15 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce16 { background-color:#558ed5; border-style:none; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-style:none; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:center ! important; }
	.ce17 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; }
	.ce18 { padding:2.01pt; font-family:Arial; border-width:0.0261cm; border-style:solid; border-color:#000000; }
	.ce19 { background-color:#558ed5; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce2 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce20 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce21 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce22 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-style:none; text-align:left ! important; }
	.ce23 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; }
	.ce24 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; }
	.ce25 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; }
	.ce26 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; }
	.ce27 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; }
	.ce28 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; }
	.ce29 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-style:none; }
	.ce3 { padding:2.01pt; font-family:Arial; }
	.ce30 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce31 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce32 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce33 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-style:none; text-align:left ! important; }
	.ce34 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; }
	.ce35 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce36 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-style:none; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce37 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-style:none; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce38 { background-color:#ffffff; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce39 { background-color:#ffffff; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce4 { background-color:transparent; border-style:none; color:#000000; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce40 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-style:none; text-align:center ! important; }
	.ce41 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-style:none; text-align:left ! important; }
	.ce42 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-style:none; }
	.ce43 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce44 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-style:none; text-align:left ! important; }
	.ce45 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; }
	.ce46 { background-color:#ffffff; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce47 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce48 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce49 { background-color:#558ed5; border-style:none; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce5 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce50 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-width:0.0261cm; border-bottom-style:solid; border-bottom-color:#000000; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-style:none; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:left ! important; }
	.ce51 { padding:2.01pt; font-family:Arial1; border-width:0.0261cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce52 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce53 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce54 { padding:2.01pt; font-family:Arial1; border-width:0.0261cm; border-style:solid; border-color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce55 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; border-bottom-style:none; border-left-width:0.0261cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0261cm; border-right-style:solid; border-right-color:#000000; border-top-width:0.0261cm; border-top-style:solid; border-top-color:#000000; text-align:center ! important; }
	.ce56 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce57 { background-color:transparent; border-style:none; color:#ffffff; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce58 { padding:2.01pt; font-family:Arial1; vertical-align:middle; text-align:left ! important; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce59 { padding:2.01pt; font-family:Arial1; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce6 { padding:2.01pt; font-family:Arial; vertical-align:top; margin-left:0pt; writing-mode:page; }
	.ce60 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce61 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; }
	.ce62 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce63 { background-color:#ffffff; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce64 { padding:2.01pt; font-family:Arial1; vertical-align:top; margin-left:0pt; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce65 { padding:2.01pt; font-family:Arial1; background-color:#ffffff; border-style:none; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce7 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial1; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce8 { background-color:transparent; border-width:0.0261cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce9 { background-color:transparent; border-style:none; color:#ffffff; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0pt; padding:2.01pt; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.co1 { width:132.41pt; }
	.co10 { width:278.31pt; }
	.co11 { width:123.7pt; }
	.co12 { width:225.95pt; }
	.co13 { width:261.64pt; }
	.co14 { width:229.15pt; }
	.co15 { width:125.26pt; }
	.co16 { width:102.25pt; }
	.co17 { width:234.71pt; }
	.co18 { width:185.5pt; }
	.co19 { width:171.24pt; }
	.co2 { width:135.55pt; }
	.co20 { width:257.64pt; }
	.co21 { width:187.09pt; }
	.co22 { width:64.2pt; }
	.co23 { width:280.66pt; }
	.co24 { width:325.05pt; }
	.co25 { width:160.95pt; }
	.co26 { width:76.9pt; }
	.co27 { width:346.45pt; }
	.co28 { width:326.64pt; }
	.co3 { width:94.34pt; }
	.co4 { width:134.79pt; }
	.co5 { width:190.29pt; }
	.co6 { width:344.1pt; }
	.co7 { width:181.56pt; }
	.co8 { width:116.56pt; }
	.co9 { width:227.54pt; }
	.ro1 { height:43.34pt; }
	.ro10 { height:51pt; }
	.ro11 { height:137.25pt; }
	.ro12 { height:171.01pt; }
	.ro13 { height:137.99pt; }
	.ro14 { height:96.75pt; }
	.ro15 { height:12.76pt; }
	.ro16 { height:267.76pt; }
	.ro17 { height:245.45pt; }
	.ro18 { height:283.49pt; }
	.ro19 { height:280.49pt; }
	.ro2 { height:173.99pt; }
	.ro20 { height:255pt; }
	.ro21 { height:189.61pt; }
	.ro22 { height:264.19pt; }
	.ro23 { height:321.59pt; }
	.ro24 { height:344.24pt; }
	.ro25 { height:216.74pt; }
	.ro26 { height:306pt; }
	.ro27 { height:267pt; }
	.ro28 { height:205.51pt; }
	.ro29 { height:217.5pt; }
	.ro3 { height:180.74pt; }
	.ro30 { height:242.25pt; }
	.ro31 { height:263.25pt; }
	.ro32 { height:239.24pt; }
	.ro33 { height:237.74pt; }
	.ro34 { height:255.74pt; }
	.ro35 { height:241.51pt; }
	.ro36 { height:248.26pt; }
	.ro37 { height:222.01pt; }
	.ro38 { height:244.49pt; }
	.ro39 { height:234pt; }
	.ro4 { height:187.34pt; }
	.ro40 { height:331.51pt; }
	.ro41 { height:229.49pt; }
	.ro42 { height:251.26pt; }
	.ro43 { height:252.74pt; }
	.ro44 { height:228.76pt; }
	.ro45 { height:247.49pt; }
	.ro46 { height:278.25pt; }
	.ro47 { height:272.24pt; }
	.ro5 { height:178.5pt; }
	.ro6 { height:204.01pt; }
	.ro7 { height:190.49pt; }
	.ro8 { height:187.51pt; }
	.ro9 { height:121.49pt; }
	.T1 { color:#ffffff; font-family:Arial; font-size:10pt; font-weight:bold; text-decoration:underline; font-style:normal; text-shadow:none; }
	.T10 { color:#000000; font-family:Arial1; font-size:10pt; font-weight:normal; font-style:normal; text-shadow:none; text-decoration:none ! important; }
	.T11 { color:#000000; font-family:Arial1; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T12 { font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.T2 { color:#ffffff; font-family:Arial; font-size:10pt; font-weight:bold; font-style:normal; text-shadow:none; text-decoration:none ! important; }
	.T3 { color:#ffffff; font-family:Arial; font-size:10pt; font-weight:bold; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T4 { color:#ffffff; font-family:Arial1; font-size:10pt; font-weight:bold; text-decoration:underline; font-style:normal; text-shadow:none; }
	.T5 { color:#ffffff; font-family:Arial1; font-size:10pt; font-weight:bold; font-style:normal; text-shadow:none; text-decoration:none ! important; }
	.T6 { color:#ffffff; font-family:Arial1; font-size:10pt; font-weight:bold; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T7 { font-family:Arial1; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; }
	.T8 { font-family:Arial1; font-size:10pt; font-weight:normal; text-decoration:none ! important; font-style:normal; text-shadow:none; color:#000000; }
	.T9 { color:#000000; font-family:Arial1; font-size:10pt; font-weight:normal; text-decoration:underline; font-style:normal; text-shadow:none; }
	<!-- ODF styles with no properties representable as CSS -->
	 { }
	</style></head><body dir="ltr" style="margin-top:54pt; margin-bottom:54pt; margin-left:50.29pt; margin-right:50.29pt; writing-mode:lr-tb; "><table border="0" cellspacing="0" cellpadding="0" class="ta1"><colgroup><col width="204"/><col width="209"/><col width="209"/><col width="145"/><col width="208"/><col width="208"/><col width="208"/><col width="293"/><col width="530"/><col width="280"/><col width="180"/><col width="351"/><col width="429"/><col width="191"/><col width="348"/><col width="348"/></colgroup><tr class="ro1"><td style="text-align:left;width:132.41pt; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:135.55pt; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:135.55pt; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:94.34pt; " class="ce1"><p>Test Setup</p></td><td style="text-align:left;width:134.79pt; " class="ce1"><p>Stream ID</p></td><td style="text-align:left;width:134.79pt; " class="ce1"><p>Pre-requisite</p></td><td style="text-align:left;width:134.79pt; " class="ce1"><p>API's / Interface Used</p></td><td style="text-align:left;width:190.29pt; " class="ce1"><p>Input Parameters</p><p>(<span class="T1">API name</span><span class="T2">: parameter type – value) / </span></p><p><span class="T3">Interface Input</span></p></td><td style="text-align:left;width:344.1pt; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:181.56pt; " class="ce1"><p>Exp Output</p></td><td style="text-align:left;width:116.56pt; " class="ce1"><p>Priority</p></td><td style="text-align:left;width:227.54pt; " class="ce1"><p>Test Stub Interface</p></td><td style="text-align:left;width:278.31pt; " class="ce1"><p>Test script</p></td><td style="text-align:left;width:123.7pt; " class="ce1"><p>Remarks</p></td><td style="text-align:left;width:225.95pt; " class="ce9"> </td><td style="text-align:left;width:225.95pt; " class="ce9"> </td></tr><tr class="ro2"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_1</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To check scheduling current recording.</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.                                    </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>RMFMS_ScheduleRecording_12</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro3"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_2</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To check scheduling current recording with invalid source.</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.                                    </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>RMFMS_ScheduleRecording_InvalidSRC_13</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro4"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_3</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To check scheduling a big recording.</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.RecorderAgent gets the duration info present in ocapri logs to verify big recording scheduled.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.                                    </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>RMFMS_Schedule_Big_Recording_14</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro4"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_4</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To schedule a future recording with start time as</p><p>100 seconds.</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.                                    </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>RMFMS_Schedule_FutureRecording_15</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro2"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_5</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To check scheduling current recording with duration as “0”</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.                                    </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>RMFMS_Schedule_ZeroSize_Recording_16</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro4"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_6</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To check scheduling a small recording.</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.RecorderAgent gets the duration info present in ocapri logs to verify small recording scheduled.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.                                    </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>RMFMS_Schedule_SmallDuration_Recording_17</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro4"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_7</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To check scheduling a  recording with minimum duration value.</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.RecorderAgent gets the duration info present in ocapri logs to verify small recording scheduled.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.                                    </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>RMFMS_Schedule_MinDuration_Recording_18</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro2"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_8</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To check scheduling current recording with negative duration.</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.                                    </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>RMFMS_Schedule_NegDuration_Recording_19</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro5"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_9</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To schedule a recording with negative start time.</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.                                    </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>RMFMS_Schedule_NegStartTime_Recording_20</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro6"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_10</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To check scheduling six consecutive current recording.</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent for all the six recordings.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.Get all the Tuner States using the TRM_Agent to confirm all the tuner are occupied.</p><p>7.Depends on the result RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.</p><p>Checkpoint 3  Verifying the tuner states using TRM                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>Recorder_RMF_SixTuner_DVR_Now_10</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro7"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_11</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To check scheduling six consecutive future recording.</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent for all the six recordings.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.Get all the Tuner States using the TRM_Agent to confirm all the tuner are occupied.</p><p>7.Depends on the result RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.</p><p>Checkpoint 3  Verifying the tuner states using TRM                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>Recorder_RMF_SixTuner_DVR_Future_11</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro8"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_12</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To check scheduling six consecutive current and future recording with 5 min gap.</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent for all the six recordings.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.Get all the Tuner States using the TRM_Agent to confirm all the tuner are occupied.</p><p>7.Depends on the result RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.</p><p>Checkpoint 3  Verifying the tuner states using TRM                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>Recorder_RMF_SixTuner_DVR_Consecutive_12</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro5"><td style="text-align:left;width:132.41pt; " class="ce2"><p>CT_Recorder_13</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Recorder-To check scheduling seven consecutive current recording.</p></td><td style="text-align:left;width:135.55pt; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:134.79pt; " class="ce2"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce2"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce2"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:344.1pt; " class="ce2"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.TM pass the parameters like duration and recording_id to RecorderAgent for all the six recordings.</p><p>3.RecorderAgent will frame the json message to schedule the recording and send to DVRSimulator which is present in TM.</p><p>4.Status of the Json response from Mediastreamer to DVRSimulator getting extracted by TM.</p><p>5 RecorderAgent  will do the error checking by verifying ocapri_log.txt.</p><p>6.Get all the Tuner States using the TRM_Agent to confirm all the tuner are occupied and check the state of the seventh recording.</p><p>7.Depends on the result RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce7"><p>Checkpoint 1 Status from the DVRSimulator.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording.</p><p>Checkpoint 3  Verifying the tuner states using TRM                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce2"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce8"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:278.31pt; " class="ce8"><p>Recorder_RMF_SixTuner_DVR_Seven_Recordings_13</p></td><td style="text-align:left;width:123.7pt; " class="ce8"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td><td style="text-align:left;width:225.95pt; " class="ce10"> </td></tr><tr class="ro9"><td style="text-align:left;width:132.41pt; " class="ce3"> </td><td style="text-align:left;width:135.55pt; " class="ce3"> </td><td style="text-align:left;width:135.55pt; " class="ce3"> </td><td style="text-align:left;width:94.34pt; " class="ce3"> </td><td style="text-align:left;width:134.79pt; " class="ce3"> </td><td style="text-align:left;width:134.79pt; " class="ce6"> </td><td style="text-align:left;width:134.79pt; " class="ce3"> </td><td style="text-align:left;width:190.29pt; " class="ce3"> </td><td style="text-align:left;width:344.1pt; " class="ce3"> </td><td style="text-align:left;width:181.56pt; " class="ce3"> </td><td style="text-align:left;width:116.56pt; " class="ce3"> </td><td style="text-align:left;width:227.54pt; " class="ce3"> </td><td style="text-align:left;width:278.31pt; " class="ce3"> </td><td style="text-align:left;width:123.7pt; " class="ce3"> </td><td style="text-align:left;width:225.95pt; " class="ce3"> </td><td style="text-align:left;width:225.95pt; " class="ce3"> </td></tr><tr class="ro9"><td style="text-align:left;width:132.41pt; " class="ce3"> </td><td style="text-align:left;width:135.55pt; " class="ce3"> </td><td style="text-align:left;width:135.55pt; " class="ce3"> </td><td style="text-align:left;width:94.34pt; " class="ce3"> </td><td style="text-align:left;width:134.79pt; " class="ce3"> </td><td style="text-align:left;width:134.79pt; " class="ce6"> </td><td style="text-align:left;width:134.79pt; " class="ce3"> </td><td style="text-align:left;width:190.29pt; " class="ce3"> </td><td style="text-align:left;width:344.1pt; " class="ce3"> </td><td style="text-align:left;width:181.56pt; " class="ce3"> </td><td style="text-align:left;width:116.56pt; " class="ce3"> </td><td style="text-align:left;width:227.54pt; " class="ce3"> </td><td style="text-align:left;width:278.31pt; " class="ce3"> </td><td style="text-align:left;width:123.7pt; " class="ce3"> </td><td style="text-align:left;width:225.95pt; " class="ce3"> </td><td style="text-align:left;width:225.95pt; " class="ce3"> </td></tr><tr class="ro9"><td style="text-align:left;width:132.41pt; " class="ce4"> </td><td style="text-align:left;width:135.55pt; " class="ce4"> </td><td style="text-align:left;width:135.55pt; " class="ce4"> </td><td style="text-align:left;width:94.34pt; " class="ce4"> </td><td style="text-align:left;width:134.79pt; " class="ce4"> </td><td style="text-align:left;width:134.79pt; " class="ce4"> </td><td style="text-align:left;width:134.79pt; " class="ce4"> </td><td style="text-align:left;width:190.29pt; " class="ce4"> </td><td style="text-align:left;width:344.1pt; " class="ce4"> </td><td style="text-align:left;width:181.56pt; " class="ce4"> </td><td style="text-align:left;width:116.56pt; " class="ce4"> </td><td style="text-align:left;width:227.54pt; " class="ce4"> </td><td style="text-align:left;width:278.31pt; " class="ce4"> </td><td style="text-align:left;width:123.7pt; " class="ce4"> </td><td style="text-align:left;width:225.95pt; " class="ce4"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:132.41pt; " class="ce4"> </td><td style="text-align:left;width:135.55pt; " class="ce4"> </td><td style="text-align:left;width:135.55pt; " class="ce4"> </td><td style="text-align:left;width:94.34pt; " class="ce4"> </td><td style="text-align:left;width:134.79pt; " class="ce4"> </td><td style="text-align:left;width:134.79pt; " class="ce4"> </td><td style="text-align:left;width:134.79pt; " class="ce4"> </td><td style="text-align:left;width:190.29pt; " class="ce4"> </td><td style="text-align:left;width:344.1pt; " class="ce4"> </td><td style="text-align:left;width:181.56pt; " class="ce4"> </td><td style="text-align:left;width:116.56pt; " class="ce4"> </td><td style="text-align:left;width:227.54pt; " class="ce4"> </td><td style="text-align:left;width:278.31pt; " class="ce4"> </td><td style="text-align:left;width:123.7pt; " class="ce4"> </td><td style="text-align:left;width:225.95pt; " class="ce4"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr></table><table border="0" cellspacing="0" cellpadding="0" class="ta2"><colgroup><col width="403"/><col width="353"/><col width="193"/><col width="158"/><col width="362"/><col width="286"/><col width="264"/><col width="397"/><col width="288"/><col width="99"/><col width="433"/><col width="501"/><col width="99"/><col width="99"/></colgroup><tr class="ro10"><td style="text-align:left;width:261.64pt; " class="ce11"><p>      Test Case ID</p></td><td style="text-align:left;width:229.15pt; " class="ce11"><p>Test Objective</p></td><td style="text-align:left;width:125.26pt; " class="ce11"><p>Test Type</p></td><td style="text-align:left;width:102.25pt; " class="ce11"><p>Test Setup</p></td><td style="text-align:left;width:234.71pt; " class="ce11"><p>API's / Interface Used</p></td><td style="text-align:left;width:185.5pt; " class="ce11"><p>Input Parameters</p><p>(<span class="T1">API name</span><span class="T2">: parameter type – value) / </span></p><p><span class="T3">Interface Input</span></p></td><td style="text-align:left;width:171.24pt; " class="ce11"><p>Pre-requisite</p></td><td style="text-align:left;width:257.64pt; " class="ce11"><p>Automation Approach</p></td><td style="text-align:left;width:187.09pt; " class="ce11"><p>Exp Output</p></td><td style="text-align:left;width:64.2pt; " class="ce11"><p>Priority</p></td><td style="text-align:left;width:280.66pt; " class="ce11"><p>Test Stub Interface</p></td><td style="text-align:left;width:325.05pt; " class="ce16"><p>Test script</p></td><td style="text-align:left;width:64.2pt; " class="ce11"><p>Remarks</p></td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro8"><td style="text-align:left;width:261.64pt; " class="ce12"><p>CT_RECORDER_RECORDID_256CHARCTER_01</p></td><td style="text-align:left;width:229.15pt; " class="ce13"><p>To Initiate recording with recording Id of length 256 characters and verify it is successful or not.</p></td><td style="text-align:left;width:125.26pt; " class="ce12"><p>Positive</p></td><td style="text-align:left;width:102.25pt; " class="ce12"><p>XG1</p></td><td style="text-align:left;width:234.71pt; " class="ce14"><p>Json Interface</p></td><td style="text-align:left;width:185.5pt; " class="ce13"><p>Json Interface- source id = &lt;256 character length&gt;, duration recording_id, start_time.</p></td><td style="text-align:left;width:171.24pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:257.64pt; " class="ce13"><p>1. Test Mgr loads the RecorderAgent via tdk test agent.</p><p>2. Test Mgr fetches the source_id/ocap_id mapped in streaming details page in test manager, frames 256 character length recordId, duration, </p><p>record start time (0-record immediately, else specify time), and get UTC time. Pass all the values to RecorderAgent.</p><p>3. The RecorderAgent will frame the final RWS record request json message to start the recording</p><p>and  send to TDK recorder simulator server which is in Test Mgr. </p><p>4. The json message will be of the form " {"updateSchedule" : {"requestId" : "7", "schedule" : [ </p><p>{"recordingId" : "&lt;256 length recordId&gt;","locator" : [ "ocap://0x5f43" ] ,"epoch" : ${now} ,"start" : "0" ,"duration" : 180000 ,</p><p>"properties":{"title":"Recording_&lt;256 character recordid&gt;&gt;"},"bitRate" : "HIGH_BIT_RATE" ,"deletePriority" : "P3" }]}} "</p><p>5. The TDK recorder simulator server will pass it to the comcast rmfStreamer process to initiate recording requested.</p><p>6. The comcast rmfStreamer will send the acknowledgement json message to TDK recorder simulator server and is passed to Test mgr. </p><p>7. Test Mgr verifies the acknowledgement json message for SUCCESS/FAILURE.</p><p>8. And RecorderAgent also verifies the status of the recording by verifying ocapri_log.txt.txt.</p><p>9. The Final result after verifying ocapri_log.txt.txt RecorderAgent will send the SUCCESS/FAILURE to Test Mgr.</p></td><td style="text-align:left;width:187.09pt; " class="ce15"><p>Checkpoint 1 Status from the TDK_Recorder_server.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording. </p></td><td style="text-align:left;width:64.2pt; " class="ce14"><p>High</p></td><td style="text-align:left;width:280.66pt; " class="ce15"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p><p>2.TestMgr_Recorder_checkRecording_status</p></td><td style="text-align:left;width:325.05pt; " class="ce17"><p>RMFMS_Recording_256Character_RecordId_01</p></td><td style="text-align:left;width:64.2pt; " class="ce18"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro11"><td style="text-align:left;width:261.64pt; " class="ce12"><p>CT_RECORDER_RECORDID_256CHARCTER_02</p></td><td style="text-align:left;width:229.15pt; " class="ce13"><p>To Initiate recording with recording Id of length 256 characters and value given is negative.</p></td><td style="text-align:left;width:125.26pt; " class="ce12"><p>Negative</p></td><td style="text-align:left;width:102.25pt; " class="ce12"><p>XG1</p></td><td style="text-align:left;width:234.71pt; " class="ce14"><p>Json Interface</p></td><td style="text-align:left;width:185.5pt; " class="ce13"><p>Json Interface- source id = &lt;256 character length&gt;, duration recording_id, start_time.</p></td><td style="text-align:left;width:171.24pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:257.64pt; " class="ce13"><p>1. Test Mgr loads the RecorderAgent via tdk test agent.</p><p>2. Test Mgr fetches the source_id/ocap_id mapped in streaming details page in test manager, frames 256 character length recordId, duration, </p><p>record start time (0-record immediately, else specify time), and get UTC time. Pass all the values to RecorderAgent.</p><p>3. The RecorderAgent will frame the final RWS record request json message to start the recording</p><p>and  send to TDK recorder simulator server which is in Test Mgr. </p><p>4. The json message will be of the form " {"updateSchedule" : {"requestId" : "7", "schedule" : [ </p><p>{"recordingId" : "&lt;256 length recordId&gt;","locator" : [ "ocap://0x5f43" ] ,"epoch" : ${now} ,"start" : "0" ,"duration" : 180000 ,</p><p>"properties":{"title":"Recording_&lt;256 character recordid&gt;&gt;"},"bitRate" : "HIGH_BIT_RATE" ,"deletePriority" : "P3" }]}} "</p><p>5. The TDK recorder simulator server will pass it to the comcast rmfStreamer process to initiate recording requested.</p><p>6. The comcast rmfStreamer will send the acknowledgement json message to TDK recorder simulator server and is passed to Test mgr. </p><p>7. Test Mgr verifies the acknowledgement json message for SUCCESS/FAILURE.</p><p>8. And RecorderAgent also verifies the status of the recording by verifying ocapri_log.txt.txt.</p><p>9. The Final result after verifying ocapri_log.txt.txt RecorderAgent will send the SUCCESS/FAILURE to Test Mgr.</p></td><td style="text-align:left;width:187.09pt; " class="ce15"><p>Checkpoint 1 Status from the TDK_Recorder_server.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording. </p></td><td style="text-align:left;width:64.2pt; " class="ce14"><p>High</p></td><td style="text-align:left;width:280.66pt; " class="ce15"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p><p>2.TestMgr_Recorder_checkRecording_status</p></td><td style="text-align:left;width:325.05pt; " class="ce17"><p>RMFMS_Recording_256Character_RecordId_Neg_02</p></td><td style="text-align:left;width:64.2pt; " class="ce18"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro12"><td style="text-align:left;width:261.64pt; " class="ce12"><p>CT_RECORDER_RECORDID_256CHARCTER_03</p></td><td style="text-align:left;width:229.15pt; " class="ce13"><p>To Initiate recording with recording Id of length 256 characters and value given is already existing .</p></td><td style="text-align:left;width:125.26pt; " class="ce12"><p>Negative</p></td><td style="text-align:left;width:102.25pt; " class="ce12"><p>XG1</p></td><td style="text-align:left;width:234.71pt; " class="ce14"><p>Json Interface</p></td><td style="text-align:left;width:185.5pt; " class="ce13"><p>Json Interface- source id = &lt;256 character length&gt;, duration recording_id, start_time.</p></td><td style="text-align:left;width:171.24pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:257.64pt; " class="ce13"><p>1. Test Mgr loads the RecorderAgent via tdk test agent.</p><p>2. Test Mgr fetches the source_id/ocap_id mapped in streaming details page in test manager, frames 256 character length recordId, duration, </p><p>record start time (0-record immediately, else specify time), and get UTC time. Pass all the values to RecorderAgent.</p><p>3. The RecorderAgent will frame the final RWS record request json message to start the recording</p><p>and  send to TDK recorder simulator server which is in Test Mgr. </p><p>4. The json message will be of the form " {"updateSchedule" : {"requestId" : "7", "schedule" : [ </p><p>{"recordingId" : "&lt;256 length recordId&gt;","locator" : [ "ocap://0x5f43" ] ,"epoch" : ${now} ,"start" : "0" ,"duration" : 180000 ,</p><p>"properties":{"title":"Recording_&lt;256 character recordid&gt;&gt;"},"bitRate" : "HIGH_BIT_RATE" ,"deletePriority" : "P3" }]}} "</p><p>5. The TDK recorder simulator server will pass it to the comcast rmfStreamer process to initiate recording requested.</p><p>6. The comcast rmfStreamer will send the acknowledgement json message to TDK recorder simulator server and is passed to Test mgr. </p><p>7. Test Mgr verifies the acknowledgement json message for SUCCESS/FAILURE.</p><p>8. And RecorderAgent also verifies the status of the recording by verifying ocapri_log.txt.txt.</p><p>9. The Final result after verifying ocapri_log.txt.txt RecorderAgent will send the SUCCESS/FAILURE to Test Mgr.</p></td><td style="text-align:left;width:187.09pt; " class="ce15"><p>Checkpoint 1 Status from the TDK_Recorder_server.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording. </p></td><td style="text-align:left;width:64.2pt; " class="ce14"><p>High</p></td><td style="text-align:left;width:280.66pt; " class="ce15"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p><p>2.TestMgr_Recorder_checkRecording_status</p></td><td style="text-align:left;width:325.05pt; " class="ce17"><p>RMFMS_Recording_256Character_RecordId_Exist_Neg_03</p></td><td style="text-align:left;width:64.2pt; " class="ce18"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:left;width:261.64pt; " class="ce12"><p>CT_RECORDER_RECORDID_256CHARCTER_04</p></td><td style="text-align:left;width:229.15pt; " class="ce13"><p>To Initiate recording with recording Id of length 256 characters and verify it is successful or not. And do the DVR playback of the recorded content.</p></td><td style="text-align:left;width:125.26pt; " class="ce12"><p>Positive</p></td><td style="text-align:left;width:102.25pt; " class="ce12"><p>XG1</p></td><td style="text-align:left;width:234.71pt; " class="ce15"><p>Json Interface</p><p> </p><p>"RMFResult HnSource-&gt;init()</p><p>RMFResult HnSource-&gt;open(url,mimetype)</p><p>RMFResult HnSource-&gt;play()</p><p>RMFResult HnSource-&gt;getState()</p><p>RMFResult HnSource-&gt;pause()</p><p>RMFResult HnSource-&gt;close()</p><p>RMFResult HnSource-&gt;term()</p><p>RMFResult DvrSink-&gt;term()</p><p>RMFResult MPSink-&gt;init()</p><p>RMFResult MPSink-&gt; setVideoRectangle(x,y,width,height,applynow)</p><p>RMFResult MPSink-&gt;setSource(HnSource)</p><p>RMFResult MPSink-&gt;term()</p></td><td style="text-align:left;width:185.5pt; " class="ce13"><p>Json Interface- source id = &lt;256 character length&gt;, duration recording_id, start_time.</p><p> </p><p>HnSource-&gt;Init() - None</p><p>HnSource-&gt;Open() - char*-url,char*- mimetype</p><p>HnSource-&gt;play() - None</p><p>HnSource-&gt;pause() - None</p><p>HnSource-&gt;getState() - RMFState</p><p>HnSource-&gt;getMediaTime() - double</p><p>HnSource-&gt;getSpeed() - None</p><p>HnSource-&gt;close() - None</p><p>HnSource-&gt;term() - None</p><p>DvrSink-&gt;term() - None.</p><p>MpSink-&gt;Init() - None.</p><p>MpSink-&gt;setVideoRectangle() - unsigned – x,unsigned – y,unsigned – width,unsigned – height, bool – false.</p><p>MpSink-&gt;setSource() - RMFMediaSourceBase* - HnSource.</p><p>MpSink-&gt;term() - None.</p></td><td style="text-align:left;width:171.24pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:257.64pt; " class="ce13"><p>1. Test Mgr loads the RecorderAgent via tdk test agent.</p><p>2. Test Mgr fetches the source_id/ocap_id mapped in streaming details page in test manager, frames 256 character length recordId, duration, </p><p>record start time (0-record immediately, else specify time), and get UTC time. Pass all the values to RecorderAgent.</p><p>3. The RecorderAgent will frame the final RWS record request json message to start the recording</p><p>and  send to TDK recorder simulator server which is in Test Mgr. </p><p>4. The json message will be of the form " {"updateSchedule" : {"requestId" : "7", "schedule" : [ </p><p>{"recordingId" : "&lt;256 length recordId&gt;","locator" : [ "ocap://0x5f43" ] ,"epoch" : ${now} ,"start" : "0" ,"duration" : 180000 ,</p><p>"properties":{"title":"Recording_&lt;256 character recordid&gt;&gt;"},"bitRate" : "HIGH_BIT_RATE" ,"deletePriority" : "P3" }]}} "</p><p>5. The TDK recorder simulator server will pass it to the comcast rmfStreamer process to initiate recording requested.</p><p>6. The comcast rmfStreamer will send the acknowledgement json message to TDK recorder simulator server and is passed to Test mgr. </p><p>7. Test Mgr verifies the acknowledgement json message for SUCCESS/FAILURE.</p><p>8. And RecorderAgent also verifies the status of the recording by verifying ocapri_log.txt.txt.</p><p>9. The Final result after verifying ocapri_log.txt.txt RecorderAgent will send the SUCCESS/FAILURE to Test Mgr.</p><p>10. After recording is success. Verfying recording by doing the play back of the recording.</p><p>11. Test Mgr loads the mediaframework_agent via test agent.</p><p>12. Mediaframework_agent will create the instance for HNSource and  initialize the HnSource element HnSource-&gt;init().</p><p>13. On success, Mediaframework_agent will call HNSource-&gt;open() with the valid url(Ex: http://&lt;StreamingIP&gt;:8080/hnStreamStart?recordingId=&lt;RecordId&gt;&amp;segmentId=0). And request to playback will be served by comcast mfStreamer process.</p><p>14. On success, Mediaframework_agent will create the instance for MPSink and  initialize the MPSink element MpSink-&gt;init().</p><p>15. On success, Mediaframework_agent will call MpSink-&gt;setVideoRectangle() to set the video co-ordinates.</p><p>16. On success, Mediaframework_agent will call MpSink-&gt;setSource() to connect the source element with sink element.</p><p>17. On success, Mediaframework_agent will call HnSource-&gt;play() to playback the recorded content.</p><p>18. On success, Mediaframework_agent will call HnSource-&gt;getState() to check the playback is successful.</p><p>19.  On success, Mediaframework_agent will call HnSource-&gt;pause() to pause the playback before closing the pipeline.</p><p>20. On success, Mediaframework_agent will call MpSink-&gt;term() to terminate the  MPSink element..</p><p>21. On success, Mediaframework_agent will call HnSource-&gt;close() to close HnSource element.</p><p>27. On success, Mediaframework_agent will call HnSource-&gt;term() to terminate the  HNSource element.</p><p>28. On success, Mediaframework_agent will remove all the instance.</p><p>29. For each API called in the script, mediaframework_agent will send SUCCESS or FAILURE status to Test Mgr via the test agent by comparing the return value of APIs.</p></td><td style="text-align:left;width:187.09pt; " class="ce15"><p>Checkpoint 1 Status from the TDK_Recorder_server.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording. </p><p>Checkpoint 3 Check the return value of API for success status.</p></td><td style="text-align:left;width:64.2pt; " class="ce14"><p>High</p></td><td style="text-align:left;width:280.66pt; " class="ce15"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p><p>2.TestMgr_Recorder_checkRecording_status</p><p> </p><p>Mediaframework_agent</p></td><td style="text-align:left;width:325.05pt; " class="ce17"><p>RMFMS_Recording_256Character_RecordId_Dvr_PlayBack_04</p></td><td style="text-align:left;width:64.2pt; " class="ce18"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:left;width:261.64pt; " class="ce12"><p>CT_RECORDER_RECORDID_256CHARCTER_05</p></td><td style="text-align:left;width:229.15pt; " class="ce13"><p>To Initiate recording with recording Id of length more then 256 characters.</p></td><td style="text-align:left;width:125.26pt; " class="ce12"><p>Negative</p></td><td style="text-align:left;width:102.25pt; " class="ce12"><p>XG1</p></td><td style="text-align:left;width:234.71pt; " class="ce14"><p>Json Interface</p></td><td style="text-align:left;width:185.5pt; " class="ce13"><p>Json Interface- source id = &lt; greater than 256 character length&gt;, duration recording_id, start_time.</p></td><td style="text-align:left;width:171.24pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:257.64pt; " class="ce13"><p>1. Test Mgr loads the RecorderAgent via tdk test agent.</p><p>2. Test Mgr fetches the source_id/ocap_id mapped in streaming details page in test manager, frames greater than 256 character length recordId, duration, </p><p>record start time (0-record immediately, else specify time), and get UTC time. Pass all the values to RecorderAgent.</p><p>3. The RecorderAgent will frame the final RWS record request json message to start the recording</p><p>and  send to TDK recorder simulator server which is in Test Mgr. </p><p>4. The json message will be of the form " {"updateSchedule" : {"requestId" : "7", "schedule" : [ </p><p>{"recordingId" : "&lt;256 length recordId&gt;","locator" : [ "ocap://0x5f43" ] ,"epoch" : ${now} ,"start" : "0" ,"duration" : 180000 ,</p><p>"properties":{"title":"Recording_&lt;256 character recordid&gt;&gt;"},"bitRate" : "HIGH_BIT_RATE" ,"deletePriority" : "P3" }]}} "</p><p>5. The TDK recorder simulator server will pass it to the comcast rmfStreamer process to initiate recording requested.</p><p>6. The comcast rmfStreamer will send the acknowledgement json message to TDK recorder simulator server and is passed to Test mgr. </p><p>7. Test Mgr verifies the acknowledgement json message for SUCCESS/FAILURE.</p><p>8. And RecorderAgent also verifies the status of the recording by verifying ocapri_log.txt.txt.</p><p>9. The Final result after verifying ocapri_log.txt.txt RecorderAgent will send the SUCCESS/FAILURE to Test Mgr.</p></td><td style="text-align:left;width:187.09pt; " class="ce15"><p>Checkpoint 1 Status from the TDK_Recorder_server.</p><p>Checkpoint 2 Verifying the ocapri_log.txt to check the state of Recording. </p></td><td style="text-align:left;width:64.2pt; " class="ce14"><p>High</p></td><td style="text-align:left;width:280.66pt; " class="ce15"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p><p>2.TestMgr_Recorder_checkRecording_status</p></td><td style="text-align:left;width:325.05pt; " class="ce17"><p>RMFMS_Recording_Grt_Than_256Character_RecordId_05</p></td><td style="text-align:left;width:64.2pt; " class="ce18"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro15"><td style="text-align:left;width:261.64pt; " class="ce3"> </td><td style="text-align:left;width:229.15pt; " class="ce3"> </td><td style="text-align:left;width:125.26pt; " class="ce3"> </td><td style="text-align:left;width:102.25pt; " class="ce3"> </td><td style="text-align:left;width:234.71pt; " class="ce3"> </td><td style="text-align:left;width:185.5pt; " class="ce3"> </td><td style="text-align:left;width:171.24pt; " class="ce3"> </td><td style="text-align:left;width:257.64pt; " class="ce3"> </td><td style="text-align:left;width:187.09pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:280.66pt; " class="ce3"> </td><td style="text-align:left;width:325.05pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr><tr class="ro15"><td style="text-align:left;width:261.64pt; " class="ce3"> </td><td style="text-align:left;width:229.15pt; " class="ce3"> </td><td style="text-align:left;width:125.26pt; " class="ce3"> </td><td style="text-align:left;width:102.25pt; " class="ce3"> </td><td style="text-align:left;width:234.71pt; " class="ce3"> </td><td style="text-align:left;width:185.5pt; " class="ce3"> </td><td style="text-align:left;width:171.24pt; " class="ce3"> </td><td style="text-align:left;width:257.64pt; " class="ce3"> </td><td style="text-align:left;width:187.09pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:280.66pt; " class="ce3"> </td><td style="text-align:left;width:325.05pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="ce3"> </td><td style="text-align:left;width:64.2pt; " class="Default"> </td></tr></table><table border="0" cellspacing="0" cellpadding="0" class="ta3"><colgroup><col width="248"/><col width="209"/><col width="209"/><col width="145"/><col width="119"/><col width="208"/><col width="208"/><col width="293"/><col width="534"/><col width="280"/><col width="180"/><col width="351"/><col width="504"/><col width="191"/><col width="348"/><col width="348"/><col width="348"/><col width="348"/><col width="348"/><col width="348"/><col width="348"/></colgroup><tr class="ro1"><td style="text-align:left;width:160.95pt; " class="ce19"><p>Test Case ID</p></td><td style="text-align:left;width:135.55pt; " class="ce19"><p>Test Objective</p></td><td style="text-align:left;width:135.55pt; " class="ce19"><p>Test Type</p></td><td style="text-align:left;width:94.34pt; " class="ce19"><p>Test Setup</p></td><td style="text-align:left;width:76.9pt; " class="ce19"><p>Stream ID</p></td><td style="text-align:left;width:134.79pt; " class="ce19"><p>Pre-requisite</p></td><td style="text-align:left;width:134.79pt; " class="ce19"><p>API's / Interface Used</p></td><td style="text-align:left;width:190.29pt; " class="ce19"><p>Input Parameters</p><p>(<span class="T4">API name</span><span class="T5">: parameter type – value) / </span></p><p><span class="T6">Interface Input</span></p></td><td style="text-align:left;width:346.45pt; " class="ce19"><p>Automation Approach</p></td><td style="text-align:left;width:181.56pt; " class="ce19"><p>Exp Output</p></td><td style="text-align:left;width:116.56pt; " class="ce19"><p>Priority</p></td><td style="text-align:left;width:227.54pt; " class="ce19"><p>Test Stub Interface</p></td><td style="text-align:left;width:326.64pt; " class="ce49"><p>Test script</p></td><td style="text-align:left;width:123.7pt; " class="ce19"><p>Remarks</p></td><td style="text-align:left;width:225.95pt; " class="ce57"> </td><td style="text-align:left;width:225.95pt; " class="ce57"> </td><td style="text-align:left;width:225.95pt; " class="ce57"> </td><td style="text-align:left;width:225.95pt; " class="ce57"> </td><td style="text-align:left;width:225.95pt; " class="ce57"> </td><td style="text-align:left;width:225.95pt; " class="ce57"> </td><td style="text-align:left;width:225.95pt; " class="ce57"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_1</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To replace all current and future schedules when updateSchedule is received with fullSchedule=true</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Another current recording will be scheduled with generation id = 0 and fullSchedule = true</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Full_Schedule_True_1</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_2</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To preserve all current and future schedules when updateSchedule is received with fullSchedule=false</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Another current recording will be scheduled with generation id = 0 and fullSchedule = false</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Full_Schedule_False_2</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_3</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To accept updateSchedule messages via inline longpoll payload</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_UpdateSchedule_Inline_LongPoll_3</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_4</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To accept updateRecording messages via inline longpoll payload</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to update deletePriority field for a specified recording Id with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id.</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_UpdateRecording_Inline_LongPoll_4</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_5</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To accept updateSchedule messages via legacy style</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_UpdateSchedule_Legacy_LongPoll_5</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_6</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To accept updateRecording messages via legacy style</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to update deletePriority field for a specified recording Id with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id.</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_UpdateRecording_Legacy_LongPoll_6</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_7</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To support canceling of a recording when rescheduling it with the same Recording ID</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Reschedule will be done with the same recording Id.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Rescheduling_Same_RecordingId_7</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_8</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To send error as USER_STOP if a recording in-progress is cancelled</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Schedule another recording to cancel the recording which in progress.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_CancelRecording_InProgress_8</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_9</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To update deletion priority upon receiving updateRecordings message</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to update deletePriority field for a specified recording Id with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id.</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_UpdateRecording_Deletion_Priority_9</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_10</p></td><td style="text-align:left;width:135.55pt; " class="ce31"><p>Recorder - To send initializing=true if and only if the recordingStatus contains ALL past, present, and future recordings on the box</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GetRecordingsList_10</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro16"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_11</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To accept Generation ID via inline updateSchedule</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a longpoll </p><p>  notification with an inline "updateSchedule" payload containing "generationId": "test1a" </p><p>  and send to TDK Recorder Simulator server which is present in TM.</p><p>4.STB (Recorder) makes a POST request to RWS bearing HTTP header "X-Parker-Generation-ID: test1a" (CP).</p><p>5.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.RecorderAgent/Python lib interface will frame the json message to simulate a legacy longpoll notification </p><p>  (no inline payload, only RWS GET URL).</p><p>8.STB (Recorder) makes a GET request to RWS bearing HTTP header "X-Parker-Generation-ID: test1a" (CP)</p><p>9.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p> </p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at step 4 and 9</p><p> </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_Inline_UpdateSchedule_11</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro17"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_12</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To accept  Generation ID via inline updateRecordings</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to simulate a </p><p>  longpoll notification with an inline "updateRecordings" payload containing "generationId": "test1b"</p><p>  and send to TDK Recorder Simulator server which is present in TM.</p><p>4.STB (Recorder) makes a POST request to RWS bearing HTTP header "X-Parker-Generation-ID: test1b" (CP).</p><p>5.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.RecorderAgent/Python lib interface will frame the json message to simulate a legacy longpoll notification </p><p>  (no inline payload, only RWS GET URL).</p><p>9.STB (Recorder) makes a GET request to RWS bearing HTTP header "X-Parker-Generation-ID: test1b" (CP)</p><p> </p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at step 4 and 9                                 </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_Inline_UpdateRecording_12</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro18"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_13</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To accept Generation ID via inline noUpdate</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a longpoll notification with an </p><p>  inline "noUpdate" payload containing "generationId": "test1c" and send to TDK Recorder Simulator server which </p><p>  is present in TM.</p><p>4.STB (Recorder) will not send any acknowledgement for this message. (CP)</p><p>5.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.RecorderAgent/Python lib interface will frame the json message to Simulate a legacy longpoll </p><p>  notification (no inline payload, only RWS GET URL). </p><p>9.STB (Recorder) makes a GET request to RWS bearing HTTP header "X-Parker-Generation-ID: test1c" (CP)</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at step 4 and 9                                </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_Inline_noUpdate_13</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro19"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_14</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To accept Generation ID via updateSchedule retrieved from RWS</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a legacy </p><p>  longpoll notification (no inline payload, only RWS GET URL) and send to TDK Recorder Simulator server which </p><p>  is present in TM.</p><p>4.When STB (Recorder) makes a GET request to RWS, simulate an RWS "updateSchedule" response bearing </p><p>  HTTP header "X-Parker-Generation-ID: test2a" through RecorderAgent/Python lib interface</p><p>5.STB (Recorder) makes a POST request to RWS bearing HTTP header "X-Parker-Generation-ID: test2a" with "acknowledgement" payload.(CP)</p><p>5.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.RecorderAgent/Python lib interface will frame the json message to Simulate a legacy longpoll </p><p>  notification (no inline payload, only RWS GET URL). </p><p>9.STB (Recorder) makes a GET request to RWS bearing HTTP header "X-Parker-Generation-ID: test2a" (CP)</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at step 5 and 9                                </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_UpdateSchedule_RWS_14</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro19"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_15</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To accept Generation ID via updateRecordings retrieved from RWS</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a legacy </p><p>  longpoll notification (no inline payload, only RWS GET URL) and send to TDK Recorder Simulator server which </p><p>  is present in TM.</p><p>4.When Recorder makes a GET request to RWS, simulate an RWS "updateRecordings" response bearing HTTP header </p><p>  "X-Parker-Generation-ID: test2b" through RecorderAgent/Python lib interface.</p><p>5.STB (Recorder) makes a POST request to RWS bearing HTTP header "X-Parker-Generation-ID: test2b" with "acknowledgement" payload.(CP)</p><p>5.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.RecorderAgent/Python lib interface will frame the json message to Simulate a legacy longpoll </p><p>  notification (no inline payload, only RWS GET URL). </p><p>9.STB (Recorder) makes a GET request to RWS bearing HTTP header "X-Parker-Generation-ID: test2b" (CP)</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at step 5 and 9                                      </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_UpdateRecording_RWS_15</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro20"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_16</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To accept Generation ID via noUpdate retrieved from RWS</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a legacy longpoll notification </p><p>  (no inline payload, only RWS GET URL) and send to TDK Recorder Simulator server which is present in TM.</p><p>4.When Recorder makes a GET request to RWS, simulate an RWS "noUpdate" response bearing </p><p>  HTTP header "X-Parker-Generation-ID: test2c" through RecorderAgent/Python lib interface.</p><p>5.STB (Recorder) will not send any "acknowledgement" payload.(CP)</p><p>5.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.RecorderAgent/Python lib interface will frame the json message to Simulate a legacy longpoll </p><p>  notification (no inline payload, only RWS GET URL). </p><p>9.STB (Recorder) makes a GET request to RWS bearing HTTP header "X-Parker-Generation-ID: test2c" (CP)</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at step 5 and 9                                                                        </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_noUpdate_RWS_16</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro21"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_17</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To preserve generation Id across reboot in normal case</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator.</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a longpoll notification </p><p>  with an inline "noUpdate" payload containing "generationId": "test3a", and send to TDK Recorder Simulator </p><p>  server which is present in TM.</p><p>4.Wait for 5 seconds and reboor the STB.</p><p>5.After reboot STB (Recorder) makes a GET request to RWS bearing HTTP header "X-Parker-Generation-ID: test3a". (CP)</p><p>6.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at step 5.                                                                                          </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_Preserve_Across_reboot_17</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro22"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_18</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To reset generation Id if  corruption occurs on reboot</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a longpoll notification with an inline </p><p>  "updateSchedule" payload containing a new future recording and "generationId": "test3b", and send to TDK Recorder </p><p>  Simulator server which is present in TM.</p><p>4.wait 5 seconds, corrupt the DVR persistant storage directory*, wait 5 seconds, then reboot the settop.</p><p>5.After reboot STB (Recorder) makes a GET request to RWS bearing HTTP header "X-Parker-Generation-ID: 0". (CP)</p><p>6.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM..</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at step 5.                                                                                          </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_Preserve_On_Reboot_Corruption_18</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro23"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_19</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To check if generation Id is sent with recording status </p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a longpoll notification with an inline </p><p>  "updateSchedule" payload containing a new hot recording (starting now and lasting 30 seconds) and "generationId": "test4a",</p><p>  and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait 15 seconds and then simulate a longpoll notification with an inline "updateSchedule" </p><p>payload that causes the new recording to be deleted (e.g. send an empty schedule with fullSchedule:true) and </p><p>"generationId": "test4b" through RecorderAgent/Python lib interface and TDK Recorder Simulator server.</p><p>5.Recorder makes a POST request to RWS bearing HTTP header "X-Parker-Generation-ID: </p><p>  test4b" and "recordingStatus" payload.(CP)</p><p>6.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at step 5.                                                                                                </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_In_Recording_Status_19</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro24"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_20</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To verify  Generation ID of up to 255 characters is supported. </p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a longpoll notification with an inline "noUpdate" payload containing </p><p>"generationId": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcde"</p><p>  and send to TDK Recorder Simulator server which is present in TM.</p><p>4.STB (recorder) will not send any acknowledgement. (CP)</p><p>5.Simulate a legacy longpoll notification (no inline payload, only RWS GET URL) through RecorderAgent/Python lib interface and TDK Recorder Simulator server. </p><p>6. STB (Recorder) makes a GET request to RWS bearing HTTP header "X-Parker-Generation-ID: 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcde" (CP).</p><p>7.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at steps 4 and 6.                                                                                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_Support_255_Chars_20</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro25"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_21</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To verify  Generation ID containing special characters is supported</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a longpoll notification with an inline "noUpdate" payload containing </p><p>  "generationId": "Aa&amp;amp;&amp;quot;'&gt; &lt;-`~!@#$%^&amp;*(){}[]\|;:,.?/Zz"  and send to TDK Recorder Simulator server which is present in TM.</p><p>4.STB (recorder) will not send any acknowledgement. (CP)</p><p>5.Simulate a legacy longpoll notification (no inline payload, only RWS GET URL) through RecorderAgent/Python lib interface and TDK Recorder Simulator server. </p><p>6.STB (Recorder) makes a GET request to RWS bearing HTTP header X-Parker-Generation-ID: "Aa&amp;amp;&amp;quot;'&gt; &lt;-`~!@#$%^&amp;*(){}[]\|;:,.?/Zz" (CP).</p><p>7.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at steps 4 and 6.                                                                                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_Support_Special_Chars_21</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro26"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_22</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To verify whether lack of new Generation ID in legacy payload preserves current ID. </p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a legacy longpoll notification </p><p>  (no inline payload, only RWS GET URL) and send to TDK Recorder Simulator server which is present in TM.</p><p>4.When Recorder makes a GET request to RWS, simulate a "noUpdate" response payload containing "generationId": "test6a".  </p><p>5.STB (recorder) will not send any acknowledgement. (CP).</p><p>6.Simulate another legacy longpoll notification (no inline payload, only RWS GET URL) though RecorderAgent/Python lib interface and TDK Recorder Simulator server. </p><p>7.When Recorder makes a GET request to RWS, simulate an "updateSchedule" response payload that does NOT </p><p>  bear any "X-Parker-Generation-ID" through ecorder_agent/Python lib interface and TDK Recorder Simulator server. </p><p>8.Simulate a legacy longpoll notification (no inline payload, only RWS GET URL) though RecorderAgent/Python lib interface and TDK Recorder Simulator server. </p><p>9. STB (Recorder) makes a GET request to RWS bearing HTTP header "X-Parker-Generation-ID: test6a".(CP).</p><p>7.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at steps 5 and 9.                                                                                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_Preserve_CurrentId_Legacy_Payload_22</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro27"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_23</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To verify whether lack of new Generation ID in inline payload preserves current ID.  </p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a longpoll notification with an inline </p><p>  "noUpdate" payload containing "generationId": "test6b" and send to TDK Recorder Simulator server which is present </p><p>  in TM.</p><p>4.STB (recorder) will not send any acknowledgement(CP).</p><p>5.Simulate a longpoll notification with an inline "updateSchedule" payload that does not contain any </p><p>  "generationId" though RecorderAgent/Python lib interface and TDK Recorder Simulator server. </p><p>6.Simulate a legacy longpoll notification (no inline payload, only RWS GET URL) through ecorder_agent/Python lib interface and TDK Recorder Simulator server. </p><p>7.STB (recorder) makes a GET request to RWS bearing HTTP header "X-Parker-Generation-ID: test6b". (CP).</p><p>8.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : Acknowledgement status from the DVRSimulator AND value of generationId from http header at steps 4 and 7.                                                                                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GenerationId_Preserve_CurrentId_Inline_Payload_23</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_24</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To replace all current and future schedules when updateSchedule is received without fullSchedule</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Another current recording will be scheduled with generation id = 0 and not containing fullSchedule(default is true)</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Full_Schedule_Default_24</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_25</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To replace all current and future schedules when updateSchedule is received with fullSchedule = true as an inline mesasge</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Another current recording will be scheduled with generation id = 0 and fullSchedule = true</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_Inline_Full_Schedule_True_25</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_26</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To replace all current and future schedules when updateSchedule is received without fullSchedule as an inline message</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Another current recording will be scheduled with generation id = 0 and not containing fullSchedule(default is true)</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_Full_Schedule_Default_26</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_27</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To replace all current and future schedules when updateSchedule is received with fullSchedule=true. Perform first updateSchedule as legacy and second as inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server using legacy mechanism which is present in TM.</p><p>4.Another current recording  will be scheduled with generation id = 0 and fullSchedule= true as inline mechanism</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_LegacyInline_Full_Schedule_True_27</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_28</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To replace all current and future schedules when updateSchedule is received with fullSchedule=true. Perform inline updateSchedule first and then legacy</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server using inline mechanism which is present in TM.</p><p>4.Another current recording  will be scheduled with generation id = 0 and fullSchedule= true as legacy mechanism</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_InlineLegacy_Full_Schedule_True_28</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_29</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To replace all current and future schedules when updateSchedule is received with fullSchedule=true. Perform updateschedule with legacy first and then inline without passing fullSchedule=true</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server using legacy mechanism which is present in TM.</p><p>4.Another current recording  will be scheduled with generation id = 0 and not containing fullSchedule= true as inline mechanism</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_LegacyInline_Full_Schedule_Default_29</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_30</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To replace all current and future schedules when updateSchedule is received with fullSchedule=true. Peform updateschedule with inline first and then legacy without fullschedule=true</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server using inline mechanism which is present in TM.</p><p>4.Another current recording  will be scheduled with generation id = 0 and not containing fullSchedule= true as legacy mechanism</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_InlineLegacy_Full_Schedule_Default_30</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_31</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To replace all current and future schedules when updateSchedule is received with fullSchedule=true. Perform updateschedule with fullschedule=false in the first request and true in the second request</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording with fullschedule=false and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Another current recording will be scheduled with generation id = 0 and fullSchedule = true</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Full_Schedule_FalseTrue_31</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_32</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To replace all current and future schedules when updateSchedule is received with fullSchedule=true.Perform fullschedule first with false and then with true via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording with fullschedule=false and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Another current recording will be scheduled with generation id = 0 and fullSchedule = true as inline</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_Full_Schedule_FalseTrue_32</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_33</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To send error as USER_STOP if a recording in-progress is cancelled via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Schedule another recording to cancel the recording which in progress using inline mechanism.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_CancelRecording_InProgress_33</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_34</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder to send error when trying to cancel an invalid recording Id.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Schedule another recording to cancel the recording for an invalid recording id.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_CancelRecording_Invalid_RecId_34</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_35</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-Not to send error as USER_STOP if a future recording is cancelled</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the future recording with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Schedule another recording to cancel the recording which in progress.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_CancelRecording_Future_RecId_35</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_36</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-Not to send error as USER_STOP if a future recording is cancelled via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the future recording with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Schedule another recording to cancel the recording which in progress.</p><p>5. STB will be rebooted after a sleep of recording duration vial inline mechanism.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>/Recorder_RMF_Inline_CancelRecording_Future_RecId_36</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_37</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To support canceling of a recording when rescheduling it with the same Recording ID via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Reschedule will be done with the same recording Id via inline mechanism.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_Rescheduling_Same_RecordingId_37</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_38</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-To support cancelling of a recording when rescheduling it with the same Recording ID. Check whether status is not pending/erased</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Reschedule will be done with the same recording Id .</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Rescheduling_Same_RecordingId_Erased_Check_38</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_39</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- Not to accept updateSchedule messages via legacy style for invalid json message</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording containing errors in the JSON message and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_UpdateSchedule_Legacy_LongPoll_InvalidJson_39</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_40</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-No to accept updateRecording messages via legacy style     for invalid json message</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to update deletePriority field for a specified recording Id with errors in the JSON mesage request and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id.</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_UpdateRecording_Legacy_LongPoll_InvalidJson_40</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_41</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To preserve all current and future schedules when updateSchedule is received with fullSchedule=false via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Another current recording will be scheduled with generation id = 0 and fullSchedule = false via inline</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_Full_Schedule_False_41</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_42</p></td><td style="text-align:left;width:135.55pt; " class="ce31"><p>Recorder - not to send initializing=true if box reboots with generation id not equal to zero</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording with generation id not equal to 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GetRecordingsList_GenId_NotZero_42</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_43</p></td><td style="text-align:left;width:135.55pt; " class="ce31"><p>Recorder - To send initializing=true if and only if the recordingStatus contains ALL past, present, and future recordings on the box. Get recording list by sending updateSchedule after reboot</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording with generation id not equal to 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. Update schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GetRecordingsList_with_updateSchedule_43</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_44</p></td><td style="text-align:left;width:135.55pt; " class="ce31"><p>Recorder - To send initializing=true if and only if the recordingStatus contains ALL past, present, and future recordings on the box. Get recording list by sending updateRecording after reboot</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording with generation id not equal to 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. Update Recording message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_GetRecordingsList_with_updateRecording_44</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_45</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To preserve all current and future schedules when updateSchedule is received with fullSchedule=false. Cancelling of a recording should not preserve current scheduling</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Another current recording will be scheduled with generation id = 0 and fullSchedule = false via legacy and cancelling a Recording</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Full_Schedule_False_CancelRecording_45</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_46</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To update deletion priority upon receiving updateRecordings message via inline longpoll</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to update deletePriority field for a specified recording Id with generation id = 0 using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id.</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_UpdateRecording_Deletion_Priority_46</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_47</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- To update duration upon receiving updateRecordings message</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to update duration field for a specified recording Id with generation id = 0 using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id.</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_UpdateRecording_Duration_Inprogress_47</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_48</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p> Recorder- To update duration upon receiving updateRecordings message via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to update duration field for a specified recording Id with generation id = 0 using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id.</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_UpdateRecording_Duration_Inprogress_47</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_49</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder to send error TRM_CANCELLED if future recording is cancelled by TRM message</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording for the same ocap ID and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id.</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_TRM_Cancel_Same_OcapId_49</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_50</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder to send error TRM_CANCELLED if future recording is cancelled by TRM message via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording for the same ocap ID as an inline message and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id.</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_TRM_Cancel_Same_OcapId_50</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_51</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder to send error TRM_CANCELLED if two current recording with same ocap id is scheduled. Second current recording should be cancelled by TRM message.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule two current recordings for the same ocap ID and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id.</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_TRM_Cancel_CurrentRec_Same_OcapId_51</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_52</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder to send error TRM_CANCELLED if future recording is cancelled by TRM message via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule two current recordings for the same ocap ID as inline message and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id.</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_TRM_Cancel_CurrentRec_Same_OcapId_52</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_53</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recoder to send power interruption error notification for multiple scheduling at different timestamp using legacy</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the multiple current recordings using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Reboot the STB when the recordings are INPROGRESS</p><p>5. Check the status message sent by the recorder back to RWS</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_PowerInterrupt_Notification_53</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_54</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recoder to send power interruption error notification for multiple scheduling at different timestamp using inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the multiple current recordings using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Reboot the STB when the recordings are INPROGRESS</p><p>5. Check the status message sent by the recorder back to RWS</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_PowerInterrupt_Notification_54</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_55</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-Create a recording of 3 seconds duration and get the details of recording using GET RWS (legacy). Status of this recording should be marked as Failed</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current a current recording with duration = 3seconds using leagacy mechanism</p><p>4. Send an update Schedule message with generationid=0</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_3secDurRec_Legacy_55</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_56</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-Create a recording of 6 seconds duration and get the details of recording using GET RWS (legacy). Status of this recording should be marked as Failed</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current a current recording with duration = 6 seconds using leagacy mechanism</p><p>4. Send an update Schedule message with generationid=0</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_6secDurRec_Legacy_56</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_57</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-Create a recording of 3 seconds duration and get the details of recording using GET RWS (inline). Status of this recording should be marked as Failed</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current a current recording with duration = 3seconds using inline mechanism</p><p>4. Send an update Schedule message with generationid=0</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_3secDurRec_Inline_57</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_58</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder-Create a recording of 6 seconds duration and get the details of recording using GET RWS (inline). Status of this recording should not be marked as Failed</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current a current recording with duration = 6 seconds using inline mechanism</p><p>4. Send an update Schedule message with generationid=0</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_6secDurRec_Inline_58</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_59</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should do a full sync only on reboot, but only if there has been any change in completed recordings checksum.(legacy)</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_ChecksumChange_fullSync_Legacy_59</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_60</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should do a full sync only on reboot, but only if there has been any change in completed recordings checksum.(inline)</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_ChecksumChange_fullSync_Inline_60</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_61</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that after Longpoll server outage recorder attempts no more than 1 concurrent connection with randomized  exponentially-longer retry intervals each time, to avoid overwhelming the server after a systemwide outage.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL </p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_LPServerOutage_CheckConnectionRetrial_61</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_62</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that after RWS Get server outage recorder attempts no more than 1 concurrent connection with randomized  exponentially-longer retry intervals each time, to avoid overwhelming the server after a systemwide outage.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the RWS GET server URL </p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_RWSServerOutage_CheckConnectionRetrial_62</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_63</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that after RWS Post server outage recorder attempts no more than 1 concurrent connection with randomized  exponentially-longer retry intervals each time, to avoid overwhelming the server after a systemwide outage.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the RWS POST server URL </p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_RWSStatusOutage_CheckConnectionRetrial_63</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_64</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that after RWS Get and Post server outage recorder attempts no more than 1 concurrent connection with randomized  exponentially-longer retry intervals each time, to avoid overwhelming the server after a systemwide outage.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the RWS GET and RSW Postserver URL </p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_RWSOutage_CheckConnectionRetrial_64</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_65</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that longpoll connection interruption during inline hot recording resumes by recorder requesting a full schedule once the connection is re-established</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule current recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4.RecorderAgent / Python lib interface will down the Long poll server URL </p><p>5.RecorderAgent / Python lib interface will bring up/activate the Long poll server URL </p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_HotRecording_LPServerConnInterrupt_65</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_66</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that longpoll connection interruption during inline scheduled future recording resumes by recorder requesting a full schedule once the connection is re-established</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4.RecorderAgent / Python lib interface will down the Long poll server URL </p><p>5.RecorderAgent / Python lib interface will bring up/activate the Long poll server URL </p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_SchedRecording_LPServerConnInterrupt_66</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_67</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that longpoll connection interruption during legacy hot recording resumes by recorder requesting a full schedule once the connection is re-established</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule current recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4.RecorderAgent / Python lib interface will down the Long poll server URL </p><p>5.RecorderAgent / Python lib interface will bring up/activate the Long poll server URL </p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Legacy_HotRecording_LPServerConnInterrupt_67</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_68</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that longpoll connection interruption during legacy scheduled future recording resumes by recorder requesting a full schedule once the connection is re-established</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4.RecorderAgent / Python lib interface will down the Long poll server URL </p><p>5.RecorderAgent / Python lib interface will bring up/activate the Long poll server URL </p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Legacy_SchedRecording_LPServerConnInterrupt_68</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_69</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Test that an inline hot recording scheduled while Longpoll is down starts as soon as connection is re-established after duration of recording.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL</p><p>4. RecorderAgent / Python lib interface will frame the json message to schedule current recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5.RecorderAgent / Python lib interface will bring up/activate the Long poll server URL after the duartion of the recording is complete</p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce50"><p>Recorder_RMF_Inline_HotRecWithLPSDown_UpAfterRecDuration_69</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_70</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Test that an inline hot recording scheduled while Longpoll is down starts as soon as connection is re-established before duration of recording.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL</p><p>4. RecorderAgent / Python lib interface will frame the json message to schedule current recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5.RecorderAgent / Python lib interface will bring up/activate the Long poll server URL before the duartion of the recording is complete</p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce50"><p>Recorder_RMF_Inline_HotRecWithLPSDown_UpBeforeRecDuration_70</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_71</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Test that a legacy hot recording scheduled while Longpoll is down starts as soon as connection is re-established after duration of recording.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL</p><p>4. RecorderAgent / Python lib interface will frame the json message to schedule current recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5.RecorderAgent / Python lib interface will bring up/activate the Long poll server URL after the duartion of the recording is complete</p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce50"><p>Recorder_RMF_Legacy_HotRecWithLPSDown_UpAfterRecDuration_71</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_72</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Test that a legacy hot recording scheduled while Longpoll is down starts as soon as connection is re-established before duration of recording.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL</p><p>4. RecorderAgent / Python lib interface will frame the json message to schedule current recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5.RecorderAgent / Python lib interface will bring up/activate the Long poll server URL before the duartion of the recording is complete</p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce50"><p>Recorder_RMF_Legacy_HotRecWithLPSDown_UpBeforeRecDuration_72</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_73</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Test that an inline hot recording scheduled while only RWS is down starts immediately and is eventually playable (even though the ACK for the schedule update was not sent to RWS)</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL</p><p>4. RecorderAgent / Python lib interface will frame the json message to schedule current recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5.RecorderAgent / Python lib interface will bring up/activate the RWS Post server URL </p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_HotRecWithRWSDown_CheckCompletion_73</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_74</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Test that an inline recording scheduled while only RWS is down starts immediately and is eventually playable (even though the ACK for the schedule update was not sent to RWS)</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL</p><p>4. RecorderAgent / Python lib interface will frame the json message to schedule future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5.RecorderAgent / Python lib interface will bring up/activate the RWSl server URL </p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_SchedRecWithRWSDown_CheckCompletion_74</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_75</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Test that an legacy hot recording scheduled while only RWS is down starts immediately and is eventually playable (even though the ACK for the schedule update was not sent to RWS)</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL</p><p>4. RecorderAgent / Python lib interface will frame the json message to schedule current recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5.RecorderAgent / Python lib interface will bring up/activate the RWS server URL</p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Legacy_HotRecWithRWSDown_CheckCompletion_75</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_76</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Test that an legacy recording scheduled while only RWS is down starts immediately and is eventually playable (even though the ACK for the schedule update was not sent to RWS)</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL</p><p>4. RecorderAgent / Python lib interface will frame the json message to schedule future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5.RecorderAgent / Python lib interface will bring up/activate the RWS server URL</p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Legacy_SchedRecWithRWSDown_CheckCompletion_76</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_77</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder requests a full schedule when heartbeat dots are not received on Longpoll connection for 90 seconds when legacy hot recording is scheduled</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL</p><p>4. RecorderAgent / Python lib interface will frame the json message to schedule current recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5.RecorderAgent / Python lib interface will bring up/activate the Long poll server URL after 90 secs</p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Legacy_HotRec_LPSDownFor90Sec_FullSched_77</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_78</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder requests a full schedule when heartbeat dots are not received on Longpoll connection for 90 seconds when legacy recording is scheduled for a future time</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL</p><p>4. RecorderAgent / Python lib interface will frame the json message to schedule future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5.RecorderAgent / Python lib interface will bring up/activate the Long poll server URL after 90 secs</p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Legacy_SchedRec_LPSDownFor90Sec_FullSched_78</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_79</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder requests a full schedule when heartbeat dots are not received on Longpoll connection for 90 seconds when inline hot recording is scheduled</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL</p><p>4. RecorderAgent / Python lib interface will frame the json message to schedule current recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5.RecorderAgent / Python lib interface will bring up/activate the Long poll server URL after 90 secs</p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_HotRec_LPSDownFor90Sec_FullSched_79</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_80</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder requests a full schedule when heartbeat dots are not received on Longpoll connection for 90 seconds when inline recording is scheduled for a future time</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the Long poll server URL</p><p>4. RecorderAgent / Python lib interface will frame the json message to schedule future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5.RecorderAgent / Python lib interface will bring up/activate the Long poll server URL after 90 secs</p><p>6. After getting the list of recordings , check the Recording status.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_SchedRec_LPSDownFor90Sec_FullSched_80</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_81</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that an inline recording scheduled for future time is iterrupted by settop reboot is reported with Error=POWER_INTERRUPTION</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted </p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_SchedRecording_PowerInterrupt_81</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_82</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that an inline hot recording scheduled is iterrupted by settop reboot is reported with Error=POWER_INTERRUPTION</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a current recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted </p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_HotRecording_PowerInterrupt_82</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_83</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that a legacy recording scheduled for future time is iterrupted by settop reboot is reported with Error=POWER_INTERRUPTION</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted </p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Legacy_SchedRecording_PowerInterrupt_83</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_84</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that a legacy hot recording scheduled is iterrupted by settop reboot is reported with Error=POWER_INTERRUPTION</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a current recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted </p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Legacy_HotRecording_PowerInterrupt_84</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro28"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_85</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>check that recording status is set to startedIncomplete and error to STARTED_EARLY if actual start varies by more than 30 seconds from requestedstart </p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Tune to the service and fill the TSB for 2 minutes.</p><p>3.Frame the legacy json message through RecorderAgent/Python lib interface to schedule the current recording of 5 minutes and </p><p>  send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to complete.</p><p>5.Reboot the STB.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to startedIncomplete, error to STARTED_EARLY</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_RecStartedEarly_StartedIncomplete_Legacy_85</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro29"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_86</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>check that recording status is set to startedIncomplete and error to STARTED_EARLY if actual start varies by more than 30 seconds from requestedstart </p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Tune to the service and fill the TSB for 2 minutes.</p><p>3.Frame the in line json message through RecorderAgent/Python lib interface to schedule the current recording of 5 minutes and </p><p>  send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to complete.</p><p>5.Reboot the STB.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to startedIncomplete, error to STARTED_EARLY</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_RecStartedEarly_StartedIncomplete_Inline_86</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro30"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_87</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Verify that recorder deletes non-P4 recordings before disk is completely full to allow new scheduled hot P4 recording</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3. Get the list of all P3 recordings</p><p>4.RecorderAgent / Python lib interface will frame the json message to schedule a hot P4 recording for 1 min and send to TDK Recorder Simulator server which is present in TM.</p><p>5. check oldest P3 recording gets deleted and new recording is completed. Check for rws notification.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Check the oldest P3 recording deleted</p><p>Checkpoint 3 Check new recording completed</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_PurgeNonP4_OnDiskFull_SchedHotP4Rec_87</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro30"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_88</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Verify that recorder deletes non-P4 recordings before disk is completely full to allow new scheduled hot P3 recording</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3. Get the list of all P3 recordings</p><p>4.RecorderAgent / Python lib interface will frame the json message to schedule a hot P3 recording for 1 min and send to TDK Recorder Simulator server which is present in TM.</p><p>5. check oldest P3 recording gets deleted and new recording is completed. Check for rws notification.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Check the oldest P3 recording deleted</p><p>Checkpoint 3 Check new recording completed</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_PurgeNonP4_OnDiskFull_SchedHotP3Rec_88</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_89</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p> Recorder should respond to updateSchedule messages received from RWS by sending an acknowledgement messageÂ to RWS.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording and send to TDK Recorder Simulator server which uses legacy mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_Ack_Legacy_UpdateSchedule_OneRec_89</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_90</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should respond to updateSchedule multiple messages received from RWS by sending an acknowledgement message to RWS.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording(multiple) and send to TDK Recorder Simulator server which uses legacy mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_Ack_Legacy_UpdateSchedule_MultipleRec_90</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_91</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should respond to updateRecordings messages, whether received from RWS by sending an acknowledgement messageÂ to RWS.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the updateRecordings json message and send to TDK Recorder Simulator server which uses legacy mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_Ack_Legacy_UpdateRecording_OneRec_91</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_92</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should respond to updateRecordings multiple messages, whether received from RWS by sending an acknowledgement messageÂ to RWS.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame multiple updateRecordings json message and send to TDK Recorder Simulator server which uses legacy mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_Ack_Legacy_UpdateRecording_MultipleRec_92</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_93</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should respond to updateSchedule messages received from longpoll by sending an acknowledgement message to RWS.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording and send to TDK Recorder Simulator server which uses inline mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_Ack_Inline_UpdateSchedule_OneRec_93</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_94</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p> Recorder should respond to updateSchedule multiple recording messages received from longpoll by sending an acknowledgement message to RWS.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording(multiple) and send to TDK Recorder Simulator server which uses inline mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_Ack_Inline_UpdateSchedule_MultipleRec_94</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_95</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should respond to updateRecordings messages, whether received from longpoll by sending an acknowledgement messageÂ to RWS.</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the updateRecordings json message and send to TDK Recorder Simulator server which uses inline mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_Ack_Inline_UpdateRecording_OneRec_95</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_96</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p> Recorder should respond to updateRecordings messages, whether received from longpoll by sending an âacknowledgementâ</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame multiple updateRecordings json message and send to TDK Recorder Simulator server which uses inline mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_Ack_Inline_UpdateRecording_MultipleRec_96</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_97</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- This test is to test the DVR Protocol Version being advertised during Cancel Recording through Inline Mechanism</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording with  and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Cancel the recording which in progressusing inline mechanism,.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_DVR_Protocol_Ad_DuringInlineCancel_97</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_98</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>This test is to test the DVR Protocol Version being advertised during Cancel Recording through Legacy Mechanism </p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording with  and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Cancel the recording which in progress using legacy mechanism,.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>/Recorder_RMF_DVR_Protocol_Ad_DuringLegacyCancel_98</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_99</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should advertise DVR Protocol version during inline power interruption Failure</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted </p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_DVR_Protocol_Ad_DuringInlinePowerInterruption_99</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_100</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should advertise DVR Protocol version during legacy power interruption Failure</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted </p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_DVR_Protocol_Ad_DuringLegacyPowerInterruption_100</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_101</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should advertise DVR Protocol version during inline Full Sync scenario</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_DVR_Protocol_Ad_DuringInlineFullSync_101</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_102</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should advertise DVR Protocol version during Legacy Full Sync scenario</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_DVR_Protocol_Ad_DuringInlineFullSync_102</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_103</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- This test is to test the DVR Protocol Version being advertised during full schedule true through Legacy Mechanism    </p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server using legacy mechanism which is present in TM.</p><p>4.Another current recording  will be scheduled with and fullSchedule= true as legacy mechanism</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_DVR_Protocol_Ad_DuringLegacy_FullScheduleTrue_103</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_104</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder- This test is to test the DVR Protocol Version being advertised during full schedule true Inline Mechanism </p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server using inline mechanism which is present in TM.</p><p>4.Another current recording  will be scheduled with and fullSchedule= true as legacy mechanism</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_DVR_Protocol_Ad_DuringInline_FullScheduleTrue_104</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_105</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder not sending any status message if a inline hot recording starts and ends on time without error</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a current recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Wait till recording is completed.</p><p>5. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that no status sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_HotRec_Inline_NoStatus_105</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce61"> </td><td style="text-align:left;width:225.95pt; " class="ce61"> </td><td style="text-align:left;width:225.95pt; " class="ce61"> </td><td style="text-align:left;width:225.95pt; " class="ce61"> </td><td style="text-align:left;width:225.95pt; " class="ce61"> </td><td style="text-align:left;width:225.95pt; " class="ce61"> </td><td style="text-align:left;width:225.95pt; " class="ce61"> </td></tr><tr class="ro25"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_106</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder not sending any status message if a legacy hot recording starts and ends on time without error</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a current recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Wait till recording is completed.</p><p>5. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that no status sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_HotRec_Legacy_NoStatus_106</p></td><td style="text-align:left;width:123.7pt; " class="ce54"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_107</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder not sending any status message if a inline future recording starts and ends on time without error</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Wait till recording is completed.</p><p>5. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that no status sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_SchedRec_Inline_NoStatus_107</p></td><td style="text-align:left;width:123.7pt; " class="ce54"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_108</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder not sending any status message if a legacy future recording starts and ends on time without error</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Wait till recording is completed.</p><p>5. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that no status sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_SchedRec_Legacy_NoStatus_108</p></td><td style="text-align:left;width:123.7pt; " class="ce54"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_109</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder sending status = Failed message if a inline hot recording is scheduled with duration of 3seconds</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Failed sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_HotRec_Inline_FailedStatus_109</p></td><td style="text-align:left;width:123.7pt; " class="ce54"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_110</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder sending status = Failed message if a legacy hot recording is scheduled with duration of 3seconds</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Failed sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_HotRec_Legacy_FailedStatus_110</p></td><td style="text-align:left;width:123.7pt; " class="ce54"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_111</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder sending status = Failed message if a inline future recording is scheduled with duration of 3seconds</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Failed sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_SchedRec_Inline_FailedStatus_111</p></td><td style="text-align:left;width:123.7pt; " class="ce54"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_112</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder sending status = Failed message if a legacy future recording is scheduled with duration of 3seconds</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Failed sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_SchedRec_Legacy_FailedStatus_112</p></td><td style="text-align:left;width:123.7pt; " class="ce54"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_113</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder sending status = Incomplete message if a inline hot recording is scheduled and it is interrupted by another recording with full schedule=true</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Incomplete sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_HotRec_Inline_IncompleteStatus_113</p></td><td style="text-align:left;width:123.7pt; " class="ce54"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_114</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder sending status = Incomplete message if a legacy hot recording is scheduled and it is interrupted by another recording with full schedule=true</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Incomplete sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_HotRec_Legacy_IncompleteStatus_114</p></td><td style="text-align:left;width:123.7pt; " class="ce54"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_115</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder sending status = Incomplete message if a inline future recording is scheduled and it is interrupted by another recording with full schedule=true</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Incomplete sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_SchedRec_Inline_IncompleteStatus_115</p></td><td style="text-align:left;width:123.7pt; " class="ce54"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_116</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Check that recorder sending status = Incomplete message if a legacy future recording is scheduled and it is interrupted by another recording with full schedule=true</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Incomplete sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_SchedRec_Legacy_IncompleteStatus_116</p></td><td style="text-align:left;width:123.7pt; " class="ce54"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro20"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_117</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Verify that additional segment is created for new hot P4 recording after manually deleting old P4 recording before scheduled end time</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with P4 recordings. There shud be atleast 1 P4 recording of 1 min duration</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot P4 recording for 1 min and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Expecting error=spacefull</p><p>5. Delete existing P4 recording of 1 min duration</p><p>6. Now the retry should be successful</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Check the error=spacefull</p><p>Checkpoint 3 Check retry to record success</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotP4Rec_OnDiskFull_Check_AfterFreeSpace_117</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro20"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_118</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Verify that additional segment is created for new hot P3 recording after manually deleting old P4 recording before scheduled end time</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with P4 recordings. There shud be atleast 1 P4 recording of 1 min duration</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot P3 recording for 1 min and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Expecting error=spacefull</p><p>5. Delete existing P4 recording of 1 min duration</p><p>6. Now the retry should be successful</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Check the error=spacefull</p><p>Checkpoint 3 Check retry to record success</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotP3Rec_OnDiskFull_Check_AfterFreeingSpace_118</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro20"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_119</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Verify that additional segment is created for new future P4 recording after manually deleting old P4 recording before scheduled end time</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with P4 recordings. There shud be atleast 1 P4 recording of 1 min duration</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future P4 recording for 1 min and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Expecting error=spacefull</p><p>5. Delete existing P4 recording of 1 min duration</p><p>6. Now the retry should be successful</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Check the error=spacefull</p><p>Checkpoint 3 Check retry to record success</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_FutureP4Rec_OnDiskFull_Check_AfterFreeingSpace_119</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro20"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_120</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Verify that additional segment is created for new future P3 recording after manually deleting old P4 recording before scheduled end time</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with P4 recordings. There shud be atleast 1 P4 recording of 1 min duration</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future P3 recording for 1 min and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Expecting error=spacefull</p><p>5. Delete existing P4 recording of 1 min duration</p><p>6. Now the retry should be successful</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Check the error=spacefull</p><p>Checkpoint 3 Check retry to record success</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_FutureP3Rec_OnDiskFull_Check_AfterFreeingSpace_120</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_121</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p> Recorder should handle updateSchedule with multiple messages via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame multiple updateSchedule json message to schedule the current recording and send to TDK Recorder Simulator server which uses inline mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_UpdateSchedule_Multiple_Messages_121</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_122</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p> Recorder to handle updateRecording with multiple messages via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame multiple updateRecording json message send to TDK Recorder Simulator server which uses inline mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_UpdateRecording_Multiple_Messages_122</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_123</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder to cancel multiple recordings via inline longpoll</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame multiple Cancel Recording json message send to TDK Recorder Simulator server which uses inline mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_CancelRecording_Multiple_Messages_123</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_124</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder to delete multiple recordings via inline longpoll</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame multiple Delete Recording json message send to TDK Recorder Simulator server which uses inline mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_DeleteRecording_Multiple_Messages_124</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_125</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder to send Power interruption error when multiple recordings in progress is interrupted because of STB reboot</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame multiple updateSchedule json message to schedule the current recording and send to TDK Recorder Simulator server which uses inline mechanism to send to Recorder.</p><p>4. Reboot the STB when the recordings are in progress.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_PowerInterrupt_Multiple_Messages_125</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro30"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_126</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Verify that recorder deletes non-P4 recordings before disk is completely full to allow new scheduled future P4 recording</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with atleast 1 P3 and P4 recordings. </p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3. Get the list of all P3 recordings</p><p>4.RecorderAgent / Python lib interface will frame the json message to schedule a future P4 recording for 1 min and send to TDK Recorder Simulator server which is present in TM.</p><p>5. check oldest P3 recording gets deleted and new recording is completed. Check for rws notification.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Check the oldest P3 recording deleted</p><p>Checkpoint 3 Check new recording completed</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_PurgeNonP4_OnDiskFull_SchedFutureP4Rec_126</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro30"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_127</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Verify that recorder deletes non-P4 recordings before disk is completely full to allow new scheduled future P3 recording</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with atleast 1 P3 and P4 recordings. </p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3. Get the list of all P3 recordings</p><p>4.RecorderAgent / Python lib interface will frame the json message to schedule a future P3 recording for 1 min and send to TDK Recorder Simulator server which is present in TM.</p><p>5. check oldest P3 recording gets deleted and new recording is completed. Check for rws notification.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Check the oldest P3 recording deleted</p><p>Checkpoint 3 Check new recording completed</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_PurgeNonP4_OnDiskFull_SchedFutureP3Rec_127</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro31"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_128</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>check that Recorder sends an end-of-recording status if it ever sent any start-of-recording status for recording started late and ended on time.</p></td><td style="text-align:left;width:135.55pt; " class="ce35"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Frame the legacy json message through RecorderAgent/Python lib interface to schedule the future (starting after 90 seconds) recording </p><p>  of 5 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Reboot the STB so that recording starts late</p><p>4.Once the STB and re4corder is up wait for the recording to complete.</p><p>5.Reboot the STB.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to startedIncomplete.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_EOR_StartedLate_EndedOnTime_Legacy_128</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro32"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_129</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>check that Recorder sends an end-of-recording status if it ever sent any start-of-recording status for recording started late and ended early.</p></td><td style="text-align:left;width:135.55pt; " class="ce35"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Frame the inline json message through RecorderAgent/Python lib interface to schedule the future (starting after 90 seconds) recording </p><p>  of 5 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Reboot the STB so that recording starts late</p><p>4.Once the STB and re4corder is up wait for the recording to complete.</p><p>5.Reboot the STB.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to startedIncomplete.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_EOR_StartedLate_EndedOnTime_Inline_129</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro33"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_130</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>check that Recorder sends an end-of-recording status if it ever sent any start-of-recording status for recording started late and ended early.</p></td><td style="text-align:left;width:135.55pt; " class="ce35"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Frame the legacy json message through RecorderAgent/Python lib interface to schedule the future (starting after 90 seconds) recording </p><p>  of 5 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Reboot the STB so that recording starts late.</p><p>5.Once the STB and recorder is up wait for the recording to completes partially.</p><p>6.Reboot the STB so that recording is partial and ends early.</p><p>7.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>8.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>9.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to startedIncomplete.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_EOR_StartedLate_EndedEarly_Legacy_130</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro31"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_131</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>check that Recorder sends an end-of-recording status if it ever sent any start-of-recording status for recording started on time and ended early.</p></td><td style="text-align:left;width:135.55pt; " class="ce35"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Frame the inline json message through RecorderAgent/Python lib interface to schedule the future (starting after 90 seconds) recording </p><p>  of 5 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Reboot the STB so that recording starts late.</p><p>5.Once the STB and recorder is up wait for the recording to completes partially.</p><p>6.Reboot the STB so that recording is partial and ends early.</p><p>7.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>8.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>9.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to startedIncomplete.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_EOR_StartedLate_EndedEarly_Inline_131</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro34"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_132</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>check that Recorder sends an end-of-recording status if it ever sent any start-of-recording status for recording started on time and ended early.</p></td><td style="text-align:left;width:135.55pt; " class="ce35"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Frame the legacy json message through RecorderAgent/Python lib interface to schedule the current recording </p><p>  of 5 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to completes partially.</p><p>5.Reboot the STB so that recording is partial and ends early.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to startedIncomplete.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_EOR_StartedOnTime_EndedEarly_Legacy_132</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_133</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>check that Recorder sends an end-of-recording status if it ever sent any start-of-recording status for recording started on time and ended early.</p></td><td style="text-align:left;width:135.55pt; " class="ce35"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Frame the inline json message through RecorderAgent/Python lib interface to schedule the current recording </p><p>  of 5 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to completes partially.</p><p>5.Reboot the STB so that recording is partial and ends early.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to startedIncomplete.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_EOR_StartedOnTime_EndedEarly_Inline_133</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro36"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_134</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>check that Recorder sends an end-of-recording status if it ever sent any start-of-recording status for recording started on time  and ended on time.</p></td><td style="text-align:left;width:135.55pt; " class="ce35"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Frame the legacy json message through RecorderAgent/Python lib interface to schedule the current recording </p><p>  of 5 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to completes.</p><p>5.Reboot the STB.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to startedIncomplete.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_EOR_StartedOnTime_EndedOnTime_Legacy_134</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro35"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_135</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>check that Recorder sends an end-of-recording status if it ever sent any start-of-recording status for recording started on time  and ended on time.</p></td><td style="text-align:left;width:135.55pt; " class="ce35"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Frame the inline json message through RecorderAgent/Python lib interface to schedule the current recording </p><p>  of 5 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to completes.</p><p>5.Reboot the STB.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to startedIncomplete.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_EOR_StartedOnTime_EndedOnTime_Inline_135</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_136</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should send timestamp=&amp;lt;the time inÂ millis that something last changed&amp;gt; in full sync</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_TimeStamp_FullSync_136</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_137</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should send timestamp=&amp;lt;the time inÂ millis that something last changed&amp;gt; in recording status while cancelling the recording in progress</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Schedule another recording to cancel the recording which in progress using inline mechanism.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_TimeStamp_CancelRecording_137</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_138</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should send timestamp=&amp;lt;the time inÂ millis that something last changed&amp;gt; in the recording status while performing full schedule true</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server using inline mechanism which is present in TM.</p><p>4.Another current recording  will be scheduled with and fullSchedule= true as legacy mechanism</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>/Recorder_RMF_Verify_TimeStamp_FullSchedule_True_138</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_139</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should send timestamp=&amp;lt;the time inÂ millis that something last changed&amp;gt; in recording status during power interruption</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recordings using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Reboot the STB when the recordings are INPROGRESS</p><p>5. Check the status message sent by the recorder back to RWS</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_TimeStamp_PowerInterrupt_139</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_140</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should do nothing upon receiving NoUpdate with empty message</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a longpoll notification with an </p><p>  legacy "noUpdate" with no data and send to TDK Recorder Simulator server which </p><p>  is present in TM.</p><p>4.STB (Recorder) will not send any acknowledgement for this message. (CP)</p><p>5.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.RecorderAgent/Python lib interface will frame the json message to Simulate a legacy longpoll </p><p>  notification (no inline payload, only RWS GET URL). </p><p> </p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : No Acknowlegment should be received                    </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Legacy_Verify_NoAck_NoUpdate_EmptyMessage_140</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro18"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_141</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should do nothing upon receiving NoUpdate empty message   via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a longpoll notification with an </p><p>  inline "noUpdate" with no data and send to TDK Recorder Simulator server which </p><p>  is present in TM.</p><p>4.STB (Recorder) will not send any acknowledgement for this message. (CP)</p><p>5.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.RecorderAgent/Python lib interface will frame the json message to Simulate a legacy longpoll </p><p>  notification (no inline payload, only RWS GET URL). </p><p> </p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : No Acknowlegment should be received                    </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_Verify_NoAck_NoUpdate_EmptyMessage_141</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro18"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_142</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should do nothing upon receiving NoUpdate message with dvrProtocolVersion field</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a longpoll notification with an </p><p>  legacy "noUpdate" with dvrprotocolVersion=7 and send to TDK Recorder Simulator server which </p><p>  is present in TM.</p><p>4.STB (Recorder) will not send any acknowledgement for this message. (CP)</p><p>5.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.RecorderAgent/Python lib interface will frame the json message to Simulate a legacy longpoll </p><p>  notification (no inline payload, only RWS GET URL). </p><p> </p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : No Acknowlegment should be received                    </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Legacy_Verify_NoAck_NoUpdate_142</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro18"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_143</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should do nothing upon receiving NoUpdate message with dvrProtocolVersion field        via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to </p><p>  RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to Simulate a longpoll notification with an </p><p>  inline "noUpdate" with dvrProtocolVersion=7 and send to TDK Recorder Simulator server which </p><p>  is present in TM.</p><p>4.STB (Recorder) will not send any acknowledgement for this message. (CP)</p><p>5.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.RecorderAgent/Python lib interface will frame the json message to Simulate a legacy longpoll </p><p>  notification (no inline payload, only RWS GET URL). </p><p> </p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint : No Acknowlegment should be received                    </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_Verify_NoAck_NoUpdate_143</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_144</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should not send redundant recording statuses; new status only needs to be sent if number of playable segments has changed or status has changed (change in Error code only does not require status to be re-sent) - Checking with cancel recording status message</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Schedule another recording to cancel the recording which in progress using inline mechanism.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. Recorder should not send the same response again</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_RedundantStatus_CancelRecording_144</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_145</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should not send redundant recording statuses; new status only needs to be sent if number of playable segments has changed or status has changed (change in Error code only does not require status to be re-sent) - Checking by cancelling the future recording</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the future recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Schedule another recording to cancel the future recording which in progress using inline mechanism.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. Recorder should not send the same response again</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_RedundantStatus_Cancel_FutureRecording_145</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_146</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should not send redundant recording statuses; new status only needs to be sent if number of playable segments has changed or status has changed (change in Error code only does not require status to be re-sent) - Checking by creating power interruption failure</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame multiple updateSchedule json message to schedule the current recording and send to TDK Recorder Simulator server which uses inline mechanism to send to Recorder.</p><p>4. Reboot the STB when the recordings are in progress.</p><p>5. CHeck for acknowledgement received on RWS Post server</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_RedundantStatus_PowerInterrupt_146</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_147</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should not send repeats of the same status - verifying by checking the full schedule true status</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Another current recording will be scheduled with generation id = 0 and fullSchedule = true</p><p>5. Check for the response sent by the recorder</p><p>6. The response should not be sent again.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_RepeatStatus_FullSchedule_True_147</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_148</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should not send repeats of the same status - verifying by deleting the completed recording and checking the status</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame  Delete Recording json message send to TDK Recorder Simulator server which uses inline mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server and check it is not sent again</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_RepeatStatus_DeleteRecording_148</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_149</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should not send repeats of the same status - verifying by cancelling the in progress recording and then deleting the cancelled recording and checking the status</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame  Delete Recording json message send to TDK Recorder Simulator server which uses inline mechanism to send to Recorder.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. CHeck for acknowledgement received on RWS Post server and check it is not sent again</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_RepeatStatus_DeleteRecording_InProgress_149</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_150</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder must support canceling of a recording a rescheduling it with the same Recording ID - Reuse the cancelled recording Id</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording  and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Reschedule will be done with the same recording Id.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current recording                            </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Rescheduling_Cancelled_RecordingId_150</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_151</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should not send Erased state while canceling a future recording uding Legacy mechanism</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Schedule another recording to cancel the recording which in progress using legacy mechanism.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Legacy_Cancel_Future_Rec_ErasedState_151</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_152</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should not send Erased state while canceling a future recording uding Legacy mechanism</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Schedule another recording to cancel the recording which in progress using inline mechanism.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_Cancel_Future_Rec_ErasedState_152</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_153</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should not send Erased state while canceling a future recording using Legacy fullschedule = truemechanism</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server using legacy mechanism which is present in TM.</p><p>4.Another current recording  will be scheduled with and fullSchedule= true as legacy mechanism</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Legacy_CancelRec_Full_Schedule_True_153</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_154</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should not send Erased state while canceling a future recording using Inline fullschedule=true mechanism</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current and future recording and send to TDK Recorder Simulator server using inline mechanism which is present in TM.</p><p>4.Another current recording  will be scheduled with and fullSchedule= true as legacy mechanism</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check the state of current and future recordings or verify the response from the RWS post server.                               </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Inline_CancelRec_Full_Schedule_True_154</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_155</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should send dvrProtocolVersionChanged=false during inline full sync</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_DVR_Protocol_Changed_DuringInlineFullSync_155</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_156</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should send dvrProtocolVersionChanged=false during legacy full sync</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_DVR_Protocol_Changed_DuringLegacyFullSync_156</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_157</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should currentAsOf = &amp;lt;current time in millis&amp;gt;during legacy fullsync</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_Legacy_currentAsOf_FullSync_157</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_158</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recorder should currentAsOf = &amp;lt;current time in millis&amp;gt;during inline fullsync</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check all current and future recordings</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_Verify_Inline_currentAsOf_FullSync_158</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td><td style="text-align:left;width:225.95pt; " class="ce58"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_159</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p> Recoder to send USER_STOP error notification at different timestamp when multiple recording in progress are cancelled</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the multiple json message to schedule the current recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Send cancel recording message for all the scheduled recordings using legacy</p><p>5. The USER STOP error should be sent back to RWS</p><p>6. Check that the error should be sent at different timestamps</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_CancelRecording_Notification_159</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_159</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Recoder to send USER_STOP error notification at different timestamp when multiple recording in progress are cancelled via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the multiple json message to schedule the current recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Send cancel recording message for all the scheduled recordings using inline</p><p>5. The USER STOP error should be sent back to RWS</p><p>6. Check that the error should be sent at different timestamps</p><p>7. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Verify the list of recordings to check the state of the cancelled recording Id.                                  </p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce47"><p>Recorder_RMF_CancelRecording_Notification_Inline_160</p></td><td style="text-align:left;width:123.7pt; " class="ce5"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_161</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Check that recorder not sending status = Pending when a inline hot recording is scheduled </p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Pending not sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotRec_Inline_Pending_Not_Received_161</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_162</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Check that recorder not sending status = Pending when a legacy hot recording is scheduled </p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Pending not sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotRec_Legacy_Pending_Not_Received_162</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_163</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Check that recorder not sending status = Pending when a inline future  recording is scheduled </p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Pending not sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_SchedRec_Inline_Pending_Not_Received_163</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_164</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Check that recorder not sending status = Pending when a legacy future recording is scheduled </p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Pending not sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_SchedRec_Legacy_Pending_Not_Received_164</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_165</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Check that recorder should send Pending status in a full sync when a hot inline recording is scheduled</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Pending has been sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotRec_Inline_Pending_Received_165</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_166</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Check that recorder should send Pending status in a full sync when a hot legacy recording is scheduled</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Pending has been sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotRec_Legacy_Pending_Received_166</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_167</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Check that recorder should send Pending status in a full sync when a future inline recording is scheduled</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Pending has been sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_SchedRec_Inline_Pending_Received_167</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_168</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Check that recorder should send Pending status in a full sync when a future legacy recording is scheduled</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Pending has been sent for the recording from recorder.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_SchedRec_Legacy_Pending_Received_168</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_169</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Verify that generation ID is reset on reboot if corruption happens after scheduling inline future recording</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using inline mechanism with genid=test3b and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Wait for 5sec, corrupt and again wait for 5sec.</p><p>5. Reboot and retrieve status</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that genid=0</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequestToDeleteFile</p><p>2.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_GenerationId_Reset_OnCorruption_InlineFutureRec_169</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_170</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Verify that generation ID is reset on reboot if corruption happens after scheduling inline hot recording</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using inline mechanism with genid=test3b and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Wait for 5sec, corrupt and again wait for 5sec.</p><p>5. Reboot and retrieve status</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that genid=0</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequestToDeleteFile</p><p>2.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_GenerationId_Reset_OnCorruption_InlineHotRec_170</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_171</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Verify that generation ID is reset on reboot if corruption happens after scheduling legacy future recording</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording legacy inline mechanism with genid=test3b and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Wait for 5sec, corrupt and again wait for 5sec.</p><p>5. Reboot and retrieve status</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that genid=0</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequestToDeleteFile</p><p>2.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_GenerationId_Reset_OnCorruption_LegacyFutureRec_171</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro25"><td style="text-align:left;width:160.95pt; " class="ce21"><p>CT_Recoder_DVR_Protocol_172</p></td><td style="text-align:left;width:135.55pt; " class="ce32"><p>Verify that generation ID is reset on reboot if corruption happens after scheduling legacy hot recording</p></td><td style="text-align:left;width:135.55pt; " class="ce32"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce32"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce32"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce21"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce21"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce43"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using legacy mechanism with genid=test3b and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Wait for 5sec, corrupt and again wait for 5sec.</p><p>5. Reboot and retrieve status</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce43"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that genid=0</p></td><td style="text-align:left;width:116.56pt; " class="ce32"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequestToDeleteFile</p><p>2.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce32"><p>Recorder_RMF_GenerationId_Reset_OnCorruption_LegacyHotRec_172</p></td><td style="text-align:left;width:123.7pt; " class="ce55"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro37"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_173</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder must send Error=MISSING_REQUESTED_START when requestedStart is not sent in JSON request</p></td><td style="text-align:left;width:135.55pt; " class="ce35"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Frame the legacy json message without requestedStart in it through RecorderAgent/Python lib interface to schedule the </p><p>  current recording of 5 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording duration.</p><p>5.Reboot the STB.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to failed and error to MISSING_REQUESTED_START.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_MISSING_REQUESTED_START_Legacy_173</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td></tr><tr class="ro25"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_174</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder must send Error=MISSING_REQUESTED_START when requestedStart is not sent in JSON request</p></td><td style="text-align:left;width:135.55pt; " class="ce35"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Frame the inline json message without requestedStart in it through RecorderAgent/Python lib interface to schedule the </p><p>  current recording of 5 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording duration.</p><p>5.Reboot the STB.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to failed and error to MISSING_REQUESTED_START.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_MISSING_REQUESTED_START_Inline_174</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td></tr><tr class="ro38"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_175</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder must not send Error=MISSING_REQUESTED_START when requestedStart is sent in JSON request</p></td><td style="text-align:left;width:135.55pt; " class="ce35"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Frame the legacy json message with requestedStart in it through RecorderAgent/Python lib interface to schedule the </p><p>  current recording of 5 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording duration.</p><p>5.Reboot the STB.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to complete.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_WITH_REQUESTED_START_Legacy_175</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td></tr><tr class="ro39"><td style="text-align:left;width:160.95pt; " class="ce20"><p>CT_Recoder_DVR_Protocol_176</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder must not send Error=MISSING_REQUESTED_START when requestedStart is sent in JSON request</p></td><td style="text-align:left;width:135.55pt; " class="ce35"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce35"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.Frame the inline json message with requestedStart in it through RecorderAgent/Python lib interface to schedule the </p><p>  current recording of 5 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording duration.</p><p>5.Reboot the STB.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p>Checkpoint 1 : Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 : Get the response from recorder in full sync and verify that status has been set to complete.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_WITH_REQUESTED_START_Inline_176</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td><td style="text-align:left;width:225.95pt; " class="ce62"> </td></tr><tr class="ro25"><td style="text-align:left;width:160.95pt; " class="ce22"><p>CT_Recoder_DVR_Protocol_177</p></td><td style="text-align:left;width:135.55pt; " class="ce33"><p>After deleting a completed hot inline recording, check that recorder has sent status=Erased in a full sync</p></td><td style="text-align:left;width:135.55pt; " class="ce33"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce33"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce33"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce22"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce22"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce44"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce44"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Erased has been sent for the recording from recorder in a full sync.</p></td><td style="text-align:left;width:116.56pt; " class="ce33"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce33"><p>Recorder_RMF_HotRec_Inline_Del_CompletedRec_177</p></td><td style="text-align:left;width:123.7pt; " class="ce40"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_178</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>After deleting a completed hot legacy recording, check that recorder has sent status=Erased in a full sync</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Erased has been sent for the recording from recorder in a full sync.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotRec_Legacy_Del_CompletedRec_178</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_179</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>After deleting a completed future inline recording, check that recorder has sent status=Erased in a full sync</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Erased has been sent for the recording from recorder in a full sync.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_SchedRec_Inline_Del_CompletedRec_179</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_180</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>After deleting a completed future legacy recording, check that recorder has sent status=Erased in a full sync</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Erased has been sent for the recording from recorder in a full sync.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_SchedRec_Legacy_Del_CompletedRec_180</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_181</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>After deleting a on-going hot inline recording, check that recorder has sent status=Erased in a full sync</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Erased has been sent for the recording from recorder in a full sync.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotRec_Inline_Del_InProgressRec_181</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_182</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>After deleting a on-going hot legacy recording, check that recorder has sent status=Erased in a full sync</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Erased has been sent for the recording from recorder in a full sync.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotRec_Legacy_Del_InProgressRec_182</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_183</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>After deleting a on-going future inline recording, check that recorder has sent status=Erased in a full sync</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Erased has been sent for the recording from recorder in a full sync.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_SchedRec_Inline_Del_InProgressRec_183</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_184</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>After deleting a on-going future legacy recording, check that recorder has sent status=Erased in a full sync</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status=Erased has been sent for the recording from recorder in a full sync.</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_SchedRec_Legacy_Del_InProgressRec_184</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_185</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Check that recording status of hot inline recording that have not been sent due to RWS connection failure, need to be re-sent once RWS connectivity is re-established</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the RWS status server URL </p><p>4.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5. RecorderAgent / Python lib interface will bring up the RWS status server URL after recording completed</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status has been received in full sync</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Inline_HotRecWithRWSDown_CheckRecStatus_185</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_186</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Check that recording status of future inline recording that have not been sent due to RWS connection failure, need to be re-sent once RWS connectivity is re-established</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the RWS status server URL </p><p>4.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5. RecorderAgent / Python lib interface will bring up the RWS status server URL after recording completed</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status has been received in full sync</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Inline_SchedRecWithRWSDown_CheckRecStatus_186</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_187</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Check that recording status of hot legacy recording that have not been sent due to RWS connection failure, need to be re-sent once RWS connectivity is re-established</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the RWS status server URL </p><p>4.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5. RecorderAgent / Python lib interface will bring up the RWS status server URL after recording completed</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status has been received in full sync</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Legacy_HotRecWithRWSDown_CheckRecStatus_187</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_188</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Check that recording status of future legacy recording that have not been sent due to RWS connection failure, need to be re-sent once RWS connectivity is re-established</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will down the RWS status server URL </p><p>4.RecorderAgent / Python lib interface will frame the json message to schedule a future recording using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5. RecorderAgent / Python lib interface will bring up the RWS status server URL after recording completed</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce31"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that status has been received in full sync</p></td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Legacy_SchedRecWithRWSDown_CheckRecStatus_188</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_189</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder should not schedule recording when trying to schedule with a cancelled recording Id</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Delete the recording when in progress</p><p>5. Again schedule recording with same cancelled recording Id.</p><p>6. Reboot the STB after a sleep of recording duration.</p><p>7. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>8. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>9.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Inline_Rescheduling_Cancelled_RecordingId_189</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_190</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder to send TRM_CANCELLED error if recording is scheduled for the max number of tuners available with different ocap id and then again scheduling one more recording with different ocap id</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce20"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of  the FW and sends it to RecorderAgent to generate request url.</p><p>3.Get max number of tuners and schedule recording for all tuners with different ocap id</p><p>4.Again schedule one more recording with different ocap id</p><p>5. Recorder should send TRM_CANCELLED error for the last scheduling happened.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Trm_Cancel_MaxTuners_Diff_OcapId_190</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_191</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p> Recorder to send TRM_CANCELLED error if recording is scheduled for the max number of tuners available with different ocap id and then again scheduling one more recording with different ocap id via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of  the FW and sends it to RecorderAgent to generate request url.</p><p>3.Get max number of tuners and schedule recording for all tuners with different ocap id via inline long poll notification</p><p>4.Again schedule one more recording with different ocap id via inline long poll notification</p><p>5. Recorder should send TRM_CANCELLED error for the last scheduling happened.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Inline_Trm_Cancel_MaxTuners_Diff_OcapId_191</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_192</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder to send TRM_CANCELLED error if recording is scheduled for the max number of tuners available with different ocap id and then again scheduling one more recording with same ocap id used already</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of  the FW and sends it to RecorderAgent to generate request url.</p><p>3.Get max number of tuners and schedule recording for all tuners with different ocap id</p><p>4.Again schedule one more recording with same ocap id which is already in use</p><p>5. Recorder should send TRM_CANCELLED error for the last scheduling happened.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Trm_Cancel_MaxTuners_Same_OcapId_192</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_193</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder to send TRM_CANCELLED error if recording is scheduled for the max number of tuners available with different ocap id and then again scheduling one more recording with same ocap id already used via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of  the FW and sends it to RecorderAgent to generate request url.</p><p>3.Get max number of tuners and schedule recording for all tuners with different ocap id via inline long poll notification</p><p>4.Again schedule one more recording with same ocap id which is already in use via inline long poll notification</p><p>5. Recorder should send TRM_CANCELLED error for the last scheduling happened.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Inline_Trm_Cancel_MaxTuners_Same_OcapId_193</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_194</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder to send the device status when a query is made to the long poll server after reboot</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce31"><p>1.TM loads RecorderAgent via the test agent.</p><p>2. Reboot the STB</p><p>3. Invoke an interface to retrieve the device status</p><p>4. Recorder to send device statusto the TDK Recorder Simulator </p><p>5. Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Device_Status_194</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_195</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder to update the duration of a future recording when a updateschedule is done with fullschedule false</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Again schedule a recording with same recording, fullschedule to false and duration value alone changed</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Validate the duration and expectedDuration value to be same or can have threshold value of 30 seconds</p><p>8. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>9.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_FullSchedule_False_Update_Duration_195</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_196</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder to update the start time of a future recording when a updateschedule is done with fullschedule false</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Again schedule a recording with same recording, fullschedule to false and start time value alone changed</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Validate the duration and expectedDuration value to be same or can have threshold value of 30 seconds</p><p>8. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>9.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_FullSchedule_False_Update_StartTime_196</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_197</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder should not send impossible out-of-sequence statuses - Do a power interrupt for a completed recording. Status should not be COMPLETE followed by FAILED</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Once the recording is completed, reboot the stb.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Recorder to send COMPLETE status and not Incomplete/Failed</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_PowerInterrupt_For_CompletedRec_197</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_198</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder not to send Complete status followed by Incomplete when a completed recording is cancelled.</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Once the recording is completed, do a cancel recording for the completed recording Id.</p><p>5. Reboot the STB.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Recorder to send COMPLETE status and not Incomplete/Failed</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Cancel_CompletedRec_198</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_199</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder not to send Erased status followed by Incomplete if a deleted recording is cancelled</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Once the recording is completed, delete the completed recording Id.</p><p>5. Now, cancel the deleted recording id and then reboot the STB</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Recorder to send ERASED status and not Incomplete/Failed</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_DeleteRec_Followed_CancelRec_199</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_200</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder must send Error=MULTIPLE_SEGMENTS if more than one segment for reason other than POWER_INTERRUPTED</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. When the recording is in progress, reboot the STB</p><p>5. Recorder should send "POWER_INTERRUPTION" error and not MULTIPLE_SEGMENTS for any reason</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Multiple_Segments_200</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro40"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_201</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>check that Recorder includes in full sync any recordings that are lost due to corruption in the next sync with Status=Erased, Error=ORPHANED</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording of 2 minutes </p><p>  and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to complete.</p><p>5.Reboot STB.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>8.Check the status of previously scheduled recording, it should be complete.                                                                                            9. Delete the metadata of previously completed recording.                                      </p><p>10.RecorderAgent / Python lib interface will frame the json message to schedule the one more current recording of 2 minutes </p><p>  and send to TDK Recorder Simulator server which is present in TM.</p><p>11.Wait for the recording to complete.</p><p>12.Reboot STB.</p><p>13.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>14.Check the status of first recording, it should be ERASED and error should be set to ORPHANED.                             </p><p>15.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>16.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1 Status from the DVRSimulator of first recording</p><p>Checkpoint 2 Get the response from recorder and verify that status has been received in full sync after second reboot for the first recording and verify the expected status and error.</p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_DeleteRecordingMetaData</p><p>2.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce51"><p>Recorder_RMF_Rec_Erased_Orphaned_Legacy_201 </p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro38"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_202</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>check that Recorder includes in full sync any recordings that are lost due to corruption in the next sync with Status=Erased, Error=ORPHANED</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule the current recording of 2 minutes </p><p>  and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to complete.</p><p>5.Reboot STB.</p><p>6.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7.Check the status of previously scheduled recording, it should be complete.                                                                                            7. Delete the metadata of previously completed recording.                                      8.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>8.Delete the metadata of previously completed recording.     </p><p>9.RecorderAgent / Python lib interface will frame the json message to schedule the one more current recording of 2 minutes </p><p>  and send to TDK Recorder Simulator server which is present in TM.</p><p>10.Wait for the recording to complete.</p><p>11.Reboot STB.</p><p>12.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>13.Check the status of first recording, it should be ERASED and error should be set to ORPHANED.                             </p><p>14.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>15.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1 Status from the DVRSimulator of first recording</p><p>Checkpoint 2 Get the response from recorder and verify that status has been received in full sync after second reboot for the first recording and verify the expected status and error.</p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_DeleteRecordingMetaData</p><p>2.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Rec_Erased_Orphaned_Inline_202</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro41"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_203</p></td><td style="text-align:left;width:135.55pt; " class="ce34"><p>If all recordings are P4, notification should include Error=SPACE_FULL for scheduling a new 6 sec P4 recording with status as Incomplete</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce23"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with P4 recordings.</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot P4 recording of more than 5 seconds duration and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM (before 10 seconds)</p><p>5. Expected status=Incomplete, error=SPACE_FULL</p><p>6. Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1<span class="T7"> </span><span class="T8">Disk full</span></p><p><span class="T9">Checkpoint 2</span><span class="T10"> Check the error and status reported</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce52"><p>Recorder_RMF_6secP4Rec_OnDiskFullWithP4_GetErrorStatus_203</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro41"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_204</p></td><td style="text-align:left;width:135.55pt; " class="ce34"><p>If all recordings are P4, notification should include Error=SPACE_FULL for scheduling a new 3 sec P4 recording with status as Failed</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce23"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with P4 recordings.</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot P4 recording of less than 5 seconds duration and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM (before 10 seconds)</p><p>5. Expected status=Failed, error=SPACE_FULL</p><p>6. Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1<span class="T7"> </span><span class="T8">Disk full</span></p><p><span class="T9">Checkpoint 2</span><span class="T10"> Check the error and status reported</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce52"><p>Recorder_RMF_3secP4Rec_OnDiskFullWithP4_GetErrorStatus_204</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro41"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_205</p></td><td style="text-align:left;width:135.55pt; " class="ce34"><p>If all recordings are P4, notification should include Error=SPACE_FULL for scheduling a new 6 sec P3 recording with status as Incomplete</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce23"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with P4 recordings.</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot P3 recording of more than 5 seconds duration and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM (before 10 seconds)</p><p>5. Expected status=Incomplete, error=SPACE_FULL</p><p>6. Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1<span class="T7"> </span><span class="T8">Disk full</span></p><p><span class="T9">Checkpoint 2</span><span class="T10"> Check the error and status reported</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce52"><p>Recorder_RMF_6secP3Rec_OnDiskFullWithP4_GetErrorStatus_205</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro41"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_206</p></td><td style="text-align:left;width:135.55pt; " class="ce34"><p>If all recordings are P4, notification should include Error=SPACE_FULL for scheduling a new 3 sec P3 recording with status as Failed</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce23"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with P4 recordings.</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot P3 recording of less than 5 seconds duration and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM (before 10 seconds)</p><p>5. Expected status=Failed, error=SPACE_FULL</p><p>6. Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1<span class="T7"> </span><span class="T8">Disk full</span></p><p><span class="T9">Checkpoint 2</span><span class="T10"> Check the error and status reported</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce52"><p>Recorder_RMF_3secP3Rec_OnDiskFullWithP4_GetErrorStatus_206</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro42"><td style="text-align:left;width:160.95pt; " class="ce24"><p>CT_Recoder_DVR_Protocol_207</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Check that recording interrupted by set top reboot and becomes corrupted and lost, </p><p>recorder resumes recording what’s left and report as STARTED_LATE. It should not be reported as ORPHANED.</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce24"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to schedule the current recording of 20 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to complete partially.</p><p>5.Delete the meta data of the ongoing recording.</p><p>6.Reboot STB.</p><p>7.Wait for the recording to complete.</p><p>8.Reboot STB.</p><p>9.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>10.Check the status of the recording, it should be INCOMPLETE and error should be set to STARTED_LATE.</p><p>11.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>12.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM."</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p><span class="T9">Checkpoint </span><span class="T10">Get the response from recorder and verify that status has been received in full sync after second reboot for the recording and verify the expected status and error.</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_DeleteRecordingMetaData</p><p>2.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Rec_NotOrphaned_StartedLate_Legacy_207</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro43"><td style="text-align:left;width:160.95pt; " class="ce24"><p>CT_Recoder_DVR_Protocol_208</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Check that recording interrupted by set top reboot and becomes corrupted and lost, </p><p>recorder resumes recording what’s left and report as STARTED_LATE. It should not be reported as ORPHANED.</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce24"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent/Python lib interface will frame the json message to schedule the current recording of 20 minutes and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to complete partially.</p><p>5.Delete the meta data of the ongoing recording.</p><p>6.Reboot STB.</p><p>7.Wait for the recording to complete.</p><p>8.Reboot STB.</p><p>9.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>10.Check the status of the recording, it should be INCOMPLETE and error should be set to STARTED_LATE.</p><p>11.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>12.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM."</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p><span class="T9">Checkpoint </span><span class="T10">Get the response from recorder and verify that status has been received in full sync after second reboot for the recording and verify the expected status and error.</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_DeleteRecordingMetaData</p><p>2.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Rec_NotOrphaned_StartedLate_Inline_208</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro44"><td style="text-align:left;width:160.95pt; " class="ce24"><p>CT_Recoder_DVR_Protocol_209</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Check that Recorder parses properties.requestedStart and send STARTED_EARLY/STARTED_LATE if actual start varies by </p><p>more than 30 seconds from requested </p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce24"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request URL.</p><p>3.Tune to the service and fill the TSB for 2 minutes.</p><p>3.Frame the in line json message through RecorderAgent/Python lib interface to schedule the current recording of 20 minutes </p><p>  with negative requestedStart (10 minutes in the past)  and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to complete and Reboot the STB.</p><p>5.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6.check the status of recording it should be set to STARTEDINCOMPLETE and error should be set to STARTED_LATE.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p><span class="T9">Checkpoint </span><span class="T10">Get the response from recorder and verify that status has been received in full sync after the reboot for the recording and verify the expected status and error.</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_RecStartedLate_StartedIncomplete_Legacy_209</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro45"><td style="text-align:left;width:160.95pt; " class="ce24"><p>CT_Recoder_DVR_Protocol_210</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Check that Recorder parses properties.requestedStart and send STARTED_EARLY/STARTED_LATE if actual start varies by </p><p>more than 30 seconds from requested </p></td><td style="text-align:left;width:135.55pt; " class="ce24"> </td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce24"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets a source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request URL.</p><p>3.Tune to the service and fill the TSB for 2 minutes.</p><p>3.Frame the in line json message through RecorderAgent/Python lib interface to schedule the current recording of 20 minutes </p><p>  with negative requestedStart (10 minutes in the past)  and send to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to complete and Reboot the STB.</p><p>5.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6.check the status of recording it should be set to STARTEDINCOMPLETE and error should be set to STARTED_LATE.</p><p>7.Retrieve the status from Recorder to TDK Recorder Simulator server, it will be extracted by the TM.</p><p>8.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p><span class="T9">Checkpoint </span><span class="T10">Get the response from recorder and verify that status has been received in full sync after the reboot for the recording and verify the expected status and error.</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_RecStartedLate_StartedIncomplete_Inline_210</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_211</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Recorder should send Error=NOT_YET_PLAYABLE if more than 10 seconds have gone by since recording should have started, and it is still not reporting an accumulated duration of at least 5 seconds</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording of 6 seconds duration using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM (before 10 seconds)</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM. Expected: NOT_YET_PLAYABLE</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that not yet playable error comes</p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotRec_Inline_Error_Not_Yet_Playable_211</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_212</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Recorder should send Error=NOT_YET_PLAYABLE if more than 10 seconds have gone by since recording should have started, and it is still not reporting an accumulated duration of at least 5 seconds</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot recording of 6 seconds duration using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM (before 10 seconds)</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM. Expected: NOT_YET_PLAYABLE</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that not yet playable error comes</p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotRec_Legacy_Error_Not_Yet_Playable_212</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_213</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Recorder should send Error=NOT_YET_PLAYABLE if more than 10 seconds have gone by since recording should have started, and it is still not reporting an accumulated duration of at least 5 seconds</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording of 6 seconds duration using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM (before 10 seconds)</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM. Expected: NOT_YET_PLAYABLE</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that not yet playable error comes</p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_FutureRec_Inline_Error_Not_Yet_Playable_213</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_214</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Recorder should send Error=NOT_YET_PLAYABLE if more than 10 seconds have gone by since recording should have started, and it is still not reporting an accumulated duration of at least 5 seconds</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording of 6 seconds duration using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM (before 10 seconds)</p><p>5.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM. Expected: NOT_YET_PLAYABLE</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that not yet playable error comes</p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_FutureRec_Legacy_Error_Not_Yet_Playable_214</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro19"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_215</p></td><td style="text-align:left;width:135.55pt; " class="ce34"><p>Schedule a new hot P3 recording for 2 hrs and cancel after 5 mins of recordings. Check that an existing P3 recording of duration not more than 10 min duration is deleted and not big P3 recording</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce23"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with big size P3 and P4 recordings. There should be atleast 1 P3 recording of small duration (10 min)</p><p> </p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot P3 recording of 2hrs duration using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Wait for 5 minutes and cancel the recording</p><p>5. Verify that big P3 recording not deleted and it deleted only the small P3 recording within 10 minutes duration</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM. Expected: NOT_YET_PLAYABLE</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1<span class="T7"> </span><span class="T8">Disk full</span></p><p><span class="T9">Checkpoint 2</span><span class="T10"> Check that small p3 recording is deleted</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce52"><p>Recorder_RMF_Cancel2HrsHotP3Rec_OnDiskFull_CheckDeletedDur_215</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro19"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_216</p></td><td style="text-align:left;width:135.55pt; " class="ce34"><p>Schedule a new hot P4 recording for 2 hrs and cancel after 5 mins of recordings. Check that an existing P3 recording of duration not more than 10 min duration is deleted and not big P3 recording</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce23"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with big size P3 and P4 recordings. There should be atleast 1 P3 recording of small duration (10 min)</p><p> </p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a hot P4 recording of 2hrs duration using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Wait for 5 minutes and cancel the recording</p><p>5. Verify that big P3 recording not deleted and it deleted only the small P3 recording within 10 minutes duration</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM. Expected: NOT_YET_PLAYABLE</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1<span class="T7"> </span><span class="T8">Disk full</span></p><p><span class="T9">Checkpoint 2</span><span class="T10"> Check that small p3 recording is deleted</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce52"><p>Recorder_RMF_Cancel2HrsHotP4Rec_OnDiskFull_CheckDeletedDur_216</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro19"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_217</p></td><td style="text-align:left;width:135.55pt; " class="ce34"><p>Schedule a new future P3 recording for 2 hrs and cancel after 5 mins of recordings. Check that an existing P3 recording of duration not more than 10 min duration is deleted and not big P3 recording</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce23"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with big size P3 and P4 recordings. There should be atleast 1 P3 recording of small duration (10 min)</p><p> </p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future P3 recording of 2hrs duration using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Wait for 5 minutes and cancel the recording</p><p>5. Verify that big P3 recording not deleted and it deleted only the small P3 recording within 10 minutes duration</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM. Expected: NOT_YET_PLAYABLE</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1<span class="T7"> </span><span class="T8">Disk full</span></p><p><span class="T9">Checkpoint 2</span><span class="T10"> Check that small p3 recording is deleted</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce52"><p>Recorder_RMF_Cancel2HrsFutureP3Rec_OnDiskFull_CheckDeletedDur_217</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro19"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_218</p></td><td style="text-align:left;width:135.55pt; " class="ce34"><p>Schedule a new future P4 recording for 2 hrs and cancel after 5 mins of recordings. Check that an existing P3 recording of duration not more than 10 min duration is deleted and not big P3 recording</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce23"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5. hdd should be full with big size P3 and P4 recordings. There should be atleast 1 P3 recording of small duration (10 min)</p><p> </p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future P4 recording of 2hrs duration using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Wait for 5 minutes and cancel the recording</p><p>5. Verify that big P3 recording not deleted and it deleted only the small P3 recording within 10 minutes duration</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM. Expected: NOT_YET_PLAYABLE</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1<span class="T7"> </span><span class="T8">Disk full</span></p><p><span class="T9">Checkpoint 2</span><span class="T10"> Check that small p3 recording is deleted</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce52"><p>Recorder_RMF_Cancel2HrsFutureP4Rec_OnDiskFull_CheckDeletedDur_218</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_219</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder must send Error=MULTIPLE_SEGMENTS if more than one segment for reason other than POWER_INTERRUPTED via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Negative</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a recording and send to TDK Recorder Simulator server which is present in TM via inline long poll notification</p><p>4. When the recording is in progress, reboot the STB</p><p>5. Recorder should send "POWER_INTERRUPTION" error and not MULTIPLE_SEGMENTS for any reason</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Inline_Multiple_Segments_219</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro30"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_220</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Recorder should send Error=BECAME_PLAYABLE if 5-second requirement is subsequently met after already sending NOT_YET_PLAYABLE</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce24"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5.FEATURE.RECORDER.INCOMPLETETHRESHOLD=1000</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3. Set FEATURE.RECORDER.INCOMPLETETHRESHOLD as 1000 from test script</p><p>4.RecorderAgent / Python lib interface will frame the json message to schedule 4 hot recordings of 10 min duration using inline mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM (after 10 seconds)</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM. Expected: BECAME_PLAYABLE</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that became playable comes</p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.Recorder_SetValuesInRmfconfig</p><p>2.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotRec_Inline_Error_Became_Playable_220</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro30"><td style="text-align:left;width:160.95pt; " class="ce23"><p>CT_Recoder_DVR_Protocol_221</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Recorder should send Error=BECAME_PLAYABLE if 5-second requirement is subsequently met after already sending NOT_YET_PLAYABLE</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce24"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p><p>5.FEATURE.RECORDER.INCOMPLETETHRESHOLD=1000</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce45"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3. Set FEATURE.RECORDER.INCOMPLETETHRESHOLD as 1000 from test script</p><p>4.RecorderAgent / Python lib interface will frame the json message to schedule 4 hot recordings of 10 min duration using legacy mechanism and send to TDK Recorder Simulator server which is present in TM.</p><p>5. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM (after 10 seconds)</p><p>6.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM. Expected: BECAME_PLAYABLE</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the response from recorder and verify that became playable comes</p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce23"><p>RecorderAgent</p><p>1.Recorder_SetValuesInRmfconfig</p><p>2.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_HotRec_Legacy_Error_Became_Playable_221</p></td><td style="text-align:left;width:123.7pt; " class="ce24"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_222</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Test attempt to record non-existent service</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3. Schedule a recording with an invalid/non existent ocap Id</p><p>4. Recorder should send "Failed" status to the simulator</p><p>5. Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Record_NonExistent_Service_222</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce5"><p>CT_Recoder_DVR_Protocol_223</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Test attempt to record non-existent service via inline</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3. Schedule a recording with an invalid/non existent ocap Id via inline long poll notification</p><p>4. Recorder should send "Failed" status to the simulator</p><p>5. Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce20"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_Inline_Record_NonExistent_Service_223</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro46"><td style="text-align:left;width:160.95pt; " class="ce24"><p>CT_Recoder_DVR_Protocol_224</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Check that Recorder sends Error=ENDED_LATE if actual end varies more than 30 seconds</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce24"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request URL.</p><p>3.RecorderAgent/Python lib interface will frame the json message to schedule the current recording of 5 minutes and send </p><p>  to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to complete partially (1 minute).</p><p>5.RecorderAgent/Python lib interface will frame the json message to schedule the current recording of 15 seconds with the same </p><p>  recording id as before and send to TDK Recorder Simulator server which is present in TM.</p><p>6.Recording will stop immediately.</p><p>7.Reboot STB.</p><p>8.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>10.Check the status of the recording, it should be INCOMPLETE and error should be set to ENDED_LATE.</p><p>11.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>12.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM."</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p><span class="T9">Checkpoint </span><span class="T10">Get the response from recorder and verify that status has been received in full sync after the reboot for the recording and verify the expected status and error.</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce47"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_RecEndedLate_Incomplete_Legacy_224</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro47"><td style="text-align:left;width:160.95pt; " class="ce24"><p>CT_Recoder_DVR_Protocol_225</p></td><td style="text-align:left;width:135.55pt; " class="ce27"><p>check that Recorder sends Error=ENDED_LATE if actual end varies more than 30 seconds</p></td><td style="text-align:left;width:135.55pt; " class="ce24"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce24"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce24"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce23"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce24"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request URL.</p><p>3.RecorderAgent/Python lib interface will frame the json message to schedule the current recording of 5 minutes and send </p><p>  to TDK Recorder Simulator server which is present in TM.</p><p>4.Wait for the recording to complete partially (1 minute).</p><p>5.RecorderAgent/Python lib interface will frame the json message to schedule the current recording of 15 seconds with the same </p><p>  recording id as before and send to TDK Recorder Simulator server which is present in TM.</p><p>6.Recording will stop immediately.</p><p>7.Reboot STB.</p><p>8.noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>10.Check the status of the recording, it should be INCOMPLETE and error should be set to ENDED_LATE.</p><p>11.Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>12.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM."</p></td><td style="text-align:left;width:181.56pt; " class="ce45"><p><span class="T9">Checkpoint </span><span class="T10">Get the response from recorder and verify that status has been received in full sync after the reboot for the recording and verify the expected status and error.</span></p></td><td style="text-align:left;width:116.56pt; " class="ce24"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce47"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce32"><p>Recorder_RMF_RecEndedLate_Incomplete_Inline_225</p></td><td style="text-align:left;width:123.7pt; " class="ce55"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:160.95pt; " class="ce25"><p>CT_Recoder_DVR_Protocol_226</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>To update deletion priority from P4 to P1 upon receiving updateRecordings message</p></td><td style="text-align:left;width:135.55pt; " class="ce36"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to update deletePriority field for a specified recording Id with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id.</p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce47"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_UpdateRecording_Deletion_Priority_226</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce26"><p>CT_Recoder_DVR_Protocol_227</p></td><td style="text-align:left;width:135.55pt; " class="ce32"><p>To update deletion priority upon receiving updateRecordings message and checking expected duration value of the recoridng after updation.</p></td><td style="text-align:left;width:135.55pt; " class="ce37"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce21"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce21"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce21"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce21"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce21"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to update deletePriority field for a specified recording Id with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce21"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether fields are updated for the specified recording Id and also  expected duration value is matching after and before priority updation</p></td><td style="text-align:left;width:116.56pt; " class="ce21"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce48"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce21"><p>Recorder_RMF_UpdateRecording_Deletion_Priority_Duration_227</p></td><td style="text-align:left;width:123.7pt; " class="ce55"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro30"><td style="text-align:left;width:160.95pt; " class="ce24"><p>CT_Recoder_DVR_Protocol_228</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>To verify that recording will restart/resume after a power interruption</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce5"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce21"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1. TM loads RecorderAgent via the test agent.</p><p>2. TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3. RecorderAgent / Python lib interface will frame the json message to send request message to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. Legacy updateSchedule message will be sent to TDK Recorder Simulator to start a new recording for 25 min duration.</p><p>6. Once acknowledgment is received, wait for 10 min and reboot the box.</p><p>7. Wait for box and recorder component to be up.</p><p>8. Wait for remaining 15 min recording to complete.</p><p>9. Send getRecordings request to TDK Recorder Simulator to check the completion status of the recordings</p><p>10. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>11. Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce5"><p><span class="T9">CheckPoint:</span></p><p><span class="T11">1. Recorder should send acknowledgement for updateSchedule request</span></p><p><span class="T11">2. Recorder should send complete recording list in response to getRecordings request</span></p><p><span class="T11">3. The recording should be completed without any issues.</span></p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce5"><p>Recorder_RMF_PowerInterrupt_CheckRecRestart_228</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:left;width:160.95pt; " class="ce27"><p>CT_Recoder_DVR_Protocol_229</p></td><td style="text-align:left;width:135.55pt; " class="ce32"><p>To Restore a recording after deleting upon receiving updateRecordings message and checking the recording should not have undesirable values.</p></td><td style="text-align:left;width:135.55pt; " class="ce21"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce21"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce21"> </td><td style="text-align:left;width:134.79pt; " class="ce21"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce21"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce21"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce21"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to update deletePriority field and restore the deletePriority field for a specified recording Id with generation id = 0 and send to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>6. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>7.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce21"><p>Checkpoint 1 Acknowledgement status from the DVRSimulator.</p><p>Checkpoint 2 Get the list of recordings to check whether the recording fields not have undesirable values.</p></td><td style="text-align:left;width:116.56pt; " class="ce21"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce21"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce21"><p>Recorder_RMF_RestoreRecording_Deletion_Priority_229</p></td><td style="text-align:left;width:123.7pt; " class="ce55"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:160.95pt; " class="ce28"><p>CT_Recoder_DVR_Protocol_230</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder to update the start time of a future recording to now when a updateschedule is done with fullschedule false</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,""FEATURE.RWS.GET.URL"" and ""FEATURE.RWS.POST.URL"" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Again schedule a recording with same recording, fullschedule to false and start time value alone changed to current time.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Validate the duration and expectedDuration value to be same or can have threshold value of 30 seconds</p><p>8. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>9.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce35"> </td><td style="text-align:left;width:116.56pt; " class="ce38"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce38"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce39"><p>Recorder_RMF_FullSchedule_False_Update_NowStartTime_230</p></td><td style="text-align:left;width:123.7pt; " class="ce46"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td></tr><tr class="ro9"><td style="text-align:left;width:160.95pt; " class="ce28"><p>CT_Recoder_DVR_Protocol_231</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>Recorder to update the start time of a future recording to a past time when a updateschedule is done with fullschedule false</p></td><td style="text-align:left;width:135.55pt; " class="ce38"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce39"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce38"> </td><td style="text-align:left;width:134.79pt; " class="ce21"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce38"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce5"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce5"><p>1.TM loads RecorderAgent via the test agent.</p><p>2.TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3.RecorderAgent / Python lib interface will frame the json message to schedule a future recording and send to TDK Recorder Simulator server which is present in TM.</p><p>4. Again schedule a recording with same recording, fullschedule to false and start time value alone changed to a past time.</p><p>5. STB will be rebooted after a sleep of recording duration.</p><p>6. noUpdate schedule message will be send to TDK Recorder Simulator server once STB is up to get the list of recordings.</p><p>7. Validate the duration and expectedDuration value to be same or can have threshold value of 30 seconds</p><p>8. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>9.Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce46"> </td><td style="text-align:left;width:116.56pt; " class="ce38"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce38"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce39"><p>Recorder_RMF_FullSchedule_False_Update_Past_StartTime_231</p></td><td style="text-align:left;width:123.7pt; " class="ce46"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td><td style="text-align:left;width:225.95pt; " class="ce63"> </td></tr><tr class="ro41"><td style="text-align:left;width:160.95pt; " class="ce29"><p>CT_Recoder_DVR_Protocol_232</p></td><td style="text-align:left;width:135.55pt; " class="ce33"><p>To verify successful playback of recorded content</p></td><td style="text-align:left;width:135.55pt; " class="ce22"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce33"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce40"> </td><td style="text-align:left;width:134.79pt; " class="ce22"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce41"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce42"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce33"><p>1. TM loads RecorderAgent via the test agent.</p><p>2. TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3. RecorderAgent / Python lib interface will frame the json message to send request message to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. Legacy updateSchedule message will be sent to TDK Recorder Simulator to start a new recording.</p><p>6. Once acknowledgment is received, wait for recording to complete</p><p>7. getRecordings request will be send to TDK Recorder Simulator to check the completion status of the recordings</p><p>8. Once the verification is complete, initiate dvr playback using TDKIntegrationStub  </p><p>9. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>10. Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce33"><p><span class="T9">CheckPoint:</span></p><p><span class="T11">1. Recorder should send acknowledgement for updateSchedule request</span></p><p><span class="T11">2. Recorder should send complete recording list in response to getRecordings request</span></p><p><span class="T11">3. The recording should be completed without any issues.</span></p><p><span class="T11">4. Recording playback should be successful.</span></p></td><td style="text-align:left;width:116.56pt; " class="ce22"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce22"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce33"><p>Recorder_RMF_VerifyRecording_Playback_232</p></td><td style="text-align:left;width:123.7pt; " class="ce40"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro25"><td style="text-align:left;width:160.95pt; " class="ce24"><p>CT_Recoder_DVR_Protocol_233</p></td><td style="text-align:left;width:135.55pt; " class="ce20"><p>To verify state of recording after updating with no recording properties</p></td><td style="text-align:left;width:135.55pt; " class="ce5"><p>Positive</p></td><td style="text-align:left;width:94.34pt; " class="ce20"><p>XG1</p></td><td style="text-align:left;width:76.9pt; " class="ce35"> </td><td style="text-align:left;width:134.79pt; " class="ce5"><p>1. rmfStreamer executable should be running.</p><p>2. Device time should be in current time of UTC.</p><p>3. Two files should be created in the name of “stt_received” and “stage4” in “/tmp” path of device.</p><p>4. In rmfconfig.ini file the parameters “FEATURE.LONGPOLL.URL”,"FEATURE.RWS.GET.URL" and "FEATURE.RWS.POST.URL" should be pointing to DVRSimulator</p></td><td style="text-align:left;width:134.79pt; " class="ce5"><p>Json Interface</p></td><td style="text-align:left;width:190.29pt; " class="ce23"><p>Json Interface- source id, duration recording_id, start_time.</p></td><td style="text-align:left;width:346.45pt; " class="ce20"><p>1. TM loads RecorderAgent via the test agent.</p><p>2. TM gets an source_id from the streaming details page of the FW and sends it to RecorderAgent to generate request url.</p><p>3. RecorderAgent / Python lib interface will frame the json message to send request message to TDK Recorder Simulator server which is present in TM.</p><p>4. STB will be rebooted after a sleep of recording duration.</p><p>5. Inline updateSchedule message will be sent to TDK Recorder Simulator to start a new recording.</p><p>6. Once acknowledgment is received updateRecordings without any properties will be sent to TDK Recorder Simulator</p><p>7. getRecordings request will be send to TDK Recorder Simulator to check the completion status of the recordings </p><p>8. Status of the Json response from Recorder to TDK Recorder Simulator server getting extracted by TM.</p><p>9. Depends on the result of above step RecorderAgent sends SUCCESS or FAILURE to TM.</p></td><td style="text-align:left;width:181.56pt; " class="ce20"><p><span class="T9">CheckPoint:</span></p><p><span class="T11">1. Recorder should send acknowledgement for inline updateSchedule request</span></p><p><span class="T11">2. Recorder should send acknowledgement for updateRecordings request</span></p><p><span class="T11">3. Recorder should send complete recording list in response to getRecordings request</span></p><p><span class="T11">4. The recording should be completed without any issues</span></p></td><td style="text-align:left;width:116.56pt; " class="ce5"><p>High</p></td><td style="text-align:left;width:227.54pt; " class="ce5"><p>RecorderAgent</p><p>1.TestMgr_Recorder_SendRequest</p></td><td style="text-align:left;width:326.64pt; " class="ce20"><p>Recorder_RMF_UpdateRecording_WithNoRecordingProperties_233</p></td><td style="text-align:left;width:123.7pt; " class="ce35"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:160.95pt; " class="ce30"> </td><td style="text-align:left;width:135.55pt; " class="ce30"> </td><td style="text-align:left;width:135.55pt; " class="ce30"> </td><td style="text-align:left;width:94.34pt; " class="ce30"> </td><td style="text-align:left;width:76.9pt; " class="ce30"> </td><td style="text-align:left;width:134.79pt; " class="ce30"> </td><td style="text-align:left;width:134.79pt; " class="ce30"> </td><td style="text-align:left;width:190.29pt; " class="ce30"> </td><td style="text-align:left;width:346.45pt; " class="ce30"> </td><td style="text-align:left;width:181.56pt; " class="ce30"> </td><td style="text-align:left;width:116.56pt; " class="ce30"> </td><td style="text-align:left;width:227.54pt; " class="ce30"> </td><td style="text-align:left;width:326.64pt; " class="ce53"> </td><td style="text-align:left;width:123.7pt; " class="ce56"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:left;width:160.95pt; " class="ce30"> </td><td style="text-align:left;width:135.55pt; " class="ce30"> </td><td style="text-align:left;width:135.55pt; " class="ce30"> </td><td style="text-align:left;width:94.34pt; " class="ce30"> </td><td style="text-align:left;width:76.9pt; " class="ce30"> </td><td style="text-align:left;width:134.79pt; " class="ce30"> </td><td style="text-align:left;width:134.79pt; " class="ce30"> </td><td style="text-align:left;width:190.29pt; " class="ce30"> </td><td style="text-align:left;width:346.45pt; " class="ce30"> </td><td style="text-align:left;width:181.56pt; " class="ce30"> </td><td style="text-align:left;width:116.56pt; " class="ce30"> </td><td style="text-align:left;width:227.54pt; " class="ce30"> </td><td style="text-align:left;width:326.64pt; " class="ce53"> </td><td style="text-align:left;width:123.7pt; " class="ce56"> </td><td style="text-align:left;width:225.95pt; " class="ce60"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="ce59"> </td><td style="text-align:left;width:225.95pt; " class="Default"> </td></tr></table></body></html>