<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.issued" content="2014-01-01T09:37:50" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.modified" content="2014-02-11T07:58:31" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:10pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.ta1 { writing-mode:lr-tb; }
	.ta2 { writing-mode:lr-tb; }
	.ta3 { writing-mode:lr-tb; }
	.ta4 { writing-mode:lr-tb; }
	.ta5 { writing-mode:lr-tb; }
	.Default { font-family:Arial; padding:0.028in; }
	.ce1 { padding:0.028in; font-family:Arial; background-color:#0084d1; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:center ! important; margin-left:0in; writing-mode:page; color:#ffffff; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:bold; }
	.ce10 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce11 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; color:#000000; }
	.ce12 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0in; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce13 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:center ! important; margin-left:0in; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce14 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:top; text-align:left ! important; margin-left:0in; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce15 { background-color:#0084d1; border-width:0.0133cm; border-style:solid; border-color:#000000; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; color:#ffffff; }
	.ce16 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:center ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce17 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce18 { padding:0.028in; font-family:Trebuchet MS; background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce19 { padding:0.028in; font-family:Trebuchet MS; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce2 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:center ! important; margin-left:0in; writing-mode:page; }
	.ce20 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce21 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:justify ! important; margin-left:0in; writing-mode:page; color:#000000; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce22 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:justify ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce23 { padding:0.028in; font-family:Arial; background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce24 { padding:0.028in; font-family:Arial; background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:top; text-align:left ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce25 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce26 { padding:0.028in; font-family:Arial; border-style:none; vertical-align:middle; text-align:left ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce27 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce3 { padding:0.028in; font-family:Arial; }
	.ce4 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce5 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:center ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce6 { padding:0.028in; font-family:Arial; background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:center ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce7 { padding:0.028in; font-family:Arial; border-bottom-style:none; border-left-width:0.0133cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0133cm; border-right-style:solid; border-right-color:#000000; border-top-style:none; vertical-align:middle; text-align:center ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce8 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:center ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce9 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; color:#000000; }
	.co1 { width:0.5134in; }
	.co10 { width:0.6335in; }
	.co11 { width:1.4201in; }
	.co12 { width:2.1626in; }
	.co13 { width:2.4575in; }
	.co14 { width:2.1736in; }
	.co15 { width:2.2835in; }
	.co16 { width:3.5283in; }
	.co17 { width:2.1193in; }
	.co18 { width:2.3484in; }
	.co19 { width:2.6217in; }
	.co2 { width:2.9929in; }
	.co20 { width:2.272in; }
	.co21 { width:1.2339in; }
	.co22 { width:1.8681in; }
	.co23 { width:3.878in; }
	.co24 { width:4.2717in; }
	.co25 { width:3.0366in; }
	.co26 { width:1.9984in; }
	.co3 { width:2.6in; }
	.co4 { width:2.0862in; }
	.co5 { width:3.4736in; }
	.co6 { width:4.2165in; }
	.co7 { width:2.0319in; }
	.co8 { width:0.8925in; }
	.co9 { width:1.922in; }
	.ro1 { height:0.8083in; }
	.ro10 { height:5.3283in; }
	.ro11 { height:5.4866in; }
	.ro12 { height:5.1134in; }
	.ro13 { height:6.2799in; }
	.ro14 { height:6.161in; }
	.ro15 { height:6.9866in; }
	.ro16 { height:6.3161in; }
	.ro17 { height:6.1575in; }
	.ro18 { height:0.1783in; }
	.ro19 { height:0.352in; }
	.ro2 { height:5.1591in; }
	.ro20 { height:2.3217in; }
	.ro21 { height:2.4457in; }
	.ro22 { height:2.0728in; }
	.ro23 { height:1.8862in; }
	.ro24 { height:2.2591in; }
	.ro25 { height:1.5134in; }
	.ro26 { height:1.6992in; }
	.ro27 { height:0.9118in; }
	.ro28 { height:0.8189in; }
	.ro29 { height:0.5181in; }
	.ro3 { height:5.8272in; }
	.ro30 { height:0.4972in; }
	.ro31 { height:0.5181in; }
	.ro32 { height:0.4555in; }
	.ro33 { height:0.6839in; }
	.ro4 { height:6.1492in; }
	.ro5 { height:5.4929in; }
	.ro6 { height:4.6638in; }
	.ro7 { height:6.322in; }
	.ro8 { height:6.4866in; }
	.ro9 { height:5.1575in; }
	.T1 { font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.T2 { font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.T3 { font-family:Times New Roman; font-size:12pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	<!-- ODF styles with no properties representable as CSS -->
	 { }
	</style></head><body dir="ltr" style="margin-top:0.7874in; margin-bottom:0.7874in; margin-left:0.7874in; margin-right:0.7874in; writing-mode:lr-tb; "><table border="0" cellspacing="0" cellpadding="0" class="ta1"><colgroup><col width="57"/><col width="332"/><col width="289"/><col width="232"/><col width="232"/><col width="386"/><col width="386"/><col width="386"/><col width="468"/><col width="226"/><col width="99"/><col width="213"/><col width="99"/><col width="99"/></colgroup><tr class="ro1"><td style="text-align:left;width:0.5134in; " class="ce1"><p>Sl. No.</p></td><td style="text-align:left;width:2.9929in; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:2.6in; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:2.0862in; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:2.0862in; " class="ce1"><p>Test Setup</p></td><td style="text-align:left;width:3.4736in; " class="ce1"><p>API's / Interfaces Used</p></td><td style="text-align:left;width:3.4736in; " class="ce1"><p>Input Parameters</p></td><td style="text-align:left;width:3.4736in; " class="ce1"><p>Pre-requisite</p></td><td style="text-align:left;width:4.2165in; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:2.0319in; " class="ce15"><p>Exp Output</p></td><td style="text-align:left;width:0.8925in; " class="ce1"><p>Priority</p></td><td style="text-align:left;width:1.922in; " class="ce15"><p>Test Stub Interface</p></td><td style="text-align:left;width:0.8925in; " class="ce15"><p>Test script</p></td><td style="text-align:left;width:0.8925in; " class="ce15"><p>Remarks</p></td></tr><tr class="ro2"><td style="text-align:right; width:0.5134in; " class="ce2"><p>1</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_01</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Fast Forward is done at 4x speed from the starting point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                      </p><p>- XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoend stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.And query the speed to make sure dvr play back is success by using HNSource getSpeed() API, and verify the result and resulting speed should be in 4x rate.</p><p>10.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>11.On success of close,endtoend stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoend stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce11"> </td><td style="text-align:left;width:0.8925in; " class="ce11"> </td></tr><tr class="ro2"><td style="text-align:right; width:0.5134in; " class="ce2"><p>2</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_02</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Fast Forward is done at 8x speed from the starting point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                      </p><p>- XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.And query the speed to make sure dvr play back is success by using HNSource getSpeed() API, and verify the result and resulting speed should be in 8x rate.</p><p>10.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>11.On success of close,endtoend stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoend stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:right; width:0.5134in; " class="ce2"><p>3</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_03</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Fast Forward is done at 16x speed from the starting point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                      </p><p>- XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.And query the speed to make sure dvr play back is success by using HNSource getSpeed() API, and verify the result and resulting speed should be in 16x rate.</p><p>10.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>11.On success of close,endtoend stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoend stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:right; width:0.5134in; " class="ce2"><p>4</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_04</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Fast Forward is done at 32x speed from the starting point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                      </p><p>- XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.And query the speed to make sure dvr play back is success by using HNSource getSpeed() API, and verify the result and resulting speed should be in 32x.</p><p>10.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>11.On success of close,endtoend stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoend stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:right; width:0.5134in; " class="ce2"><p>5</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_05</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Fast Forward is done at max speed 64x from the starting point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                      </p><p>- XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.And query the speed to make sure dvr play back is success by using HNSource getSpeed() API, and verify the result and resulting speed should be in 64x rate.</p><p>10.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>11.On success of close,endtoend stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoend stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>6</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_06</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Fast Forward is done at 4x speed from the middle of the playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                      </p><p>- XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for some duration and endtoendrmf stub agent will change the speed to 4x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in 4x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>7</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_07</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Fast Forward is done at 8x speed from the middle of the playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                      </p><p>- XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for some duration and endtoendrmf stub agent will change the speed to 8x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in 8x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>8</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_08</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Fast Forward is done at 16x speed from the middle of the playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                      </p><p>- XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for some duration and endtoendrmf stub agent will change the speed to 16x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in 16x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>9</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_09</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Fast Forward is done at 32x speed from the middle of the playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                      </p><p>- XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for some duration and endtoendrmf stub agent will change the speed to 32x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in 32x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>10</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_10</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Fast Forward is done at max speed 64x from the middle of the playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                      </p><p>- XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for some duration and endtoendrmf stub agent will change the speed to 64x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in 64x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce3"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>11</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_11</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify by playing a long duration video(say 2hrs), Fast Forward the video until 10 minutes and then play the video </p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for few(10) mins of duration and endtoendrmf stub agent will change the speed to normal rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in normal rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro4"><td style="text-align:right; width:0.5134in; " class="ce2"><p>12</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_12</p></td><td style="text-align:left;width:2.6in; " class="ce6"><p>To verify the video playback when it is at the ending point and doing Fast Forward to allow the video to forward and start from begining of the recording..</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFStateChangeReturn getState()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFStateChangeReturn getState:RMFState *,RMFState *</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for till the end point and endtoendrmf stub agent will change the speed to 4x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result.</p><p>11.After defined period of play,endtoendrmf stub agent will call</p><p>HNSource getState() to check the state whether Playing/Ready.</p><p>12.On success of getState() API, endtoendrmf stub agent will</p><p> HNSource close() API and check the status returned by the API.</p><p>13.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>14.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>15.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p><p>Checkpoint 3.Check the state returned by the getState API. </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce11"> </td><td style="text-align:left;width:0.8925in; " class="ce17"><p>Need to confirm whether it should start again from the begining of the recording or it should stop playing.</p></td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>13</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_13</p></td><td style="text-align:left;width:2.6in; " class="ce7"><p>To verify the video playback when Rewind is done at 4x speed from the middle of the playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for some duration and endtoendrmf stub agent will change the speed to -4x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in -4x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>14</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_14</p></td><td style="text-align:left;width:2.6in; " class="ce8"><p>To verify the video playback when Rewind is done at 8x speed from the middle of the playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for some duration and endtoendrmf stub agent will change the speed to -8x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in -8x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>15</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_15</p></td><td style="text-align:left;width:2.6in; " class="ce8"><p>To verify the video playback when Rewind is done at 16x speed from the middle of the playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for some duration and endtoendrmf stub agent will change the speed to -16x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in -16x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>16</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_16</p></td><td style="text-align:left;width:2.6in; " class="ce7"><p>To verify the video playback when Rewind is done at 32x speed from the middle of the playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HnSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoend stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for some duration and endtoendrmf stub agent will change the speed to -32x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in -32x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>17</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_17</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Rewind is done at 64x max speed from the middle of the playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for some duration and endtoendrmf stub agent will change the speed to -64x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in -64x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>18</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_18</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Rewind is done at 4x speed from the end point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HnSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for till end of the stream and endtoendrmf stub agent will change the speed to -4x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in -4x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>19</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_19</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Rewind is done at 8x speed from the end point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for till end of the stream and endtoendrmf stub agent will change the speed to -8x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in -8x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>20</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_20</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Rewind is done at 16x speed from the end point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for till end of the stream and endtoendrmf stub agent will change the speed to -16x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in -16x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>21</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_21</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Rewind is done at 32x speed from the end point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for till end of the stream and endtoendrmf stub agent will change the speed to -32x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in -32x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>22</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_22</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Rewind is done at 64x speed from the end point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.Let the video play for till end of the stream and endtoendrmf stub agent will change the speed to -64x rate by calling the HNSource setSpeed() API.</p><p>10.On success of setSpeed() API, endtoendrmf stub agent will query the speed to make sure dvr play back is playing in the specified rate by using HNSource getSpeed() API, and verify the result and resulting speed should be in -64x rate.</p><p>11.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:right; width:0.5134in; " class="ce2"><p>23</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_23</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the playback of a long duration video(say 2hrs) by playing it for few(15) mins and then doing Rewind at max(64x) speed until the starting point of the video is reached and then playing the video in the normal speed.</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.After defined period of playfor few mins,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 64x (rewind) and check the status returned by the API.</p><p>10. Onsuccess of setSpeed, endtoendrmf stub agent will call HNSource setSpeed() API to play it normal speed (1.0).</p><p>11.On success of setSpeed, endtoendrmf stub agent will call HNSource close() API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro6"><td style="text-align:right; width:0.5134in; " class="ce2"><p>24</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_24</p></td><td style="text-align:left;width:2.6in; " class="ce6"><p>To verify the video playback when there is no more  video to rewind(That is,  starting point of the recording content.)</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is -4x as appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource close() API and check the status returned by the API.</p><p>10.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>11.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>12.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro5"><td style="text-align:right; width:0.5134in; " class="ce2"><p>25</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_25</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify pause on a video which is being played.</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFStateChangeReturn getState()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFStateChangeReturn getState:RMFState *,RMFState *</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 0 (pause) and check the status returned by the API.</p><p>10. Onsuccess of setSpeed, endtoendrmf stub agent will call HNSource getState API() to check the pause was successful.</p><p>11.On success of getState, endtoendrmf stub agent will call HNSource close() API.</p><p>12.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>13.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>14.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the state returned by the getState API for pause state.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:right; width:0.5134in; " class="ce2"><p>26</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_26</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify play on a video which is paused.</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFStateChangeReturn getState()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFStateChangeReturn getState:RMFState *,RMFState *</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is 0 rate as appended in URL and check the status returned by the API.</p><p>9.On success of play, endtoendrmf stub agent will call HNSource getState() API and check the state.</p><p>10.After defined period,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 1.0 (play) and check the status returned by the API.</p><p>11.Onsuccess of setSpeed, endtoendrmf stub agent will call HNSource getState API() to check the play was successful.</p><p>12.On success of getState, endtoend stub agent will call HNSource close() API.</p><p>13.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>14.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>15.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the state returned by the getState API for pause state.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro7"><td style="text-align:right; width:0.5134in; " class="ce2"><p>27</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_27</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the pause and play by playing the video from the starting point and pausing it after sometime and then again playing it till the end</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFStateChangeReturn getState()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFStateChangeReturn getState:RMFState *,RMFState *</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 0 (pause) and check the status returned by the API.</p><p>10.Onsuccess of setSpeed, endtoendrmf stub agent will call HNSource getState API() to check the pause was successful.</p><p>11.On success of getState, endtoendrmf stub agent will call HNSource setSpeed() API by setting it 1.0 (play) and check the status returned by the API.</p><p>12.Onsuccess of setSpeed, endtoendrmf stub agent will call HNSource getState API() to check the play was successful.</p><p>13.On success of getState, endtoendrmf stub agent will call</p><p> HNSource close() API.</p><p>14.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>15.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>16.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the state returned by the getState API for pause state.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro8"><td style="text-align:right; width:0.5134in; " class="ce2"><p>28</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_28</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the pause/play in a video playback by doing pause and play multiple times between the starting and end point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFStateChangeReturn getState()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFStateChangeReturn getState:RMFState *,RMFState *</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 0 (pause) and check the status returned by the API.</p><p>10.Onsuccess of setSpeed, endtoendrmf stub agent will call HNSource getState API() to check the pause was successful.</p><p>11.On success of getState, endtoend stub agent will call HNSource setSpeed() API by setting it 1.0 (play) and check the status returned by the API.</p><p>12.Onsuccess of setSpeed, endtoendrmf stub agent will call HNSource getState API() to check the play was successful.</p><p>13.step from 10 to 12 repeat multiple times(TM passes the value for repeating) and returns the status to TM, then endtoendrmf stub agent will call HNSource close() API.</p><p>14.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>15.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>16.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the state returned by the getState API for pause state.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:right; width:0.5134in; " class="ce2"><p>29</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_29</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Skip forward is done once from the starting point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setMediaTime()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setMediaTime:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.On success of play,endtoendrmf stub agent will call HNSource setMediTime() API by setting it number of seconds to skip forward and check the status returned by the API.</p><p>10. Onsuccess of setMediTime(), endtoendrmf stub agent will call </p><p> HNSource close() API.</p><p>11.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:right; width:0.5134in; " class="ce2"><p>30</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_30</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Skip forward is done multiple times from the starting point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setMediaTime()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setMediaTime:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.On success of play,endtoendrmf stub agent will call HNSource setMediTime() API by setting it number of seconds to skip forward and check the status returned by the API.</p><p>10. Onsuccess of setMediTime(),and repeat step 9 multiple time(TM passes the value for repeating), endtoendrmf  stub agent will call HNSource close() API.</p><p>11.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:right; width:0.5134in; " class="ce2"><p>31</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_31</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Skip forward is done once from the middle of the video playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setMediaTime()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setMediaTime:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.On success of playand let video play for some time,endtoendrmf stub agent will call HNSource setMediTime() API by setting it number of seconds to skip forward and check the status returned by the API.</p><p>10. Onsuccess of setMediTime(), endtoendrmf stub agent will call </p><p> HNSource close() API.</p><p>11.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro11"><td style="text-align:right; width:0.5134in; " class="ce2"><p>32</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_32</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Skip forward is done multile times from the middle of the video playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setMediaTime()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setMediaTime:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.On success of playand let video play for some time,endtoendrmf stub agent will call HNSource setMediTime() API by setting it number of seconds to skip forward and check the status returned by the API.</p><p>10.Onsuccess of setMediTime(),and repeat step 9 multiple time(TM passes the value for repeating), endtoendrmf  stub agent will call HNSource close() API.</p><p>11.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:right; width:0.5134in; " class="ce2"><p>33</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_33</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Skip forward is done after the video has reached the end point</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setMediaTime()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setMediaTime:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.On success of play let the it play till it reaches end of the video, endtoendrmf stub agent will call HNSource setMediTime() API by setting it number of seconds to skip forward and check the status returned by the API.</p><p>10. Onsuccess of setMediTime(), endtoendrmf stub agent will call </p><p> HNSource close() API.</p><p>11.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:right; width:0.5134in; " class="ce2"><p>34</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_34</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Skip backward is done after the video has reached the end point</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setMediaTime()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setMediaTime:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.On success of play let the it play till it reaches end of the video, endtoendrmf stub agent will call HNSource setMediTime() API by setting it number of seconds to skip backward and check the status returned by the API.</p><p>10. Onsuccess of setMediTime(), endtoendrmf stub agent will call </p><p> HNSource close() API.</p><p>11.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro11"><td style="text-align:right; width:0.5134in; " class="ce2"><p>35</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_35</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Skip backward is done multiple times after the video has reached the end point</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setMediaTime()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setMediaTime:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.On success of play let the it play till it reaches end of the video, endtoendrmf stub agent will call HNSource setMediTime() API by setting it number of seconds to skip backward and check the status returned by the API.</p><p>10. Onsuccess of setMediTime() repeat the step 9 multiple times (TM passes the value for repeating), endtoendrmf stub agent will call HNSource close() API.</p><p>11.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro12"><td style="text-align:right; width:0.5134in; " class="ce2"><p>36</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_36</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Skip backward is done once from the middle of the video playback</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setMediaTime()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setMediaTime:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.On success of play, let video play for some time,endtoendrmf stub agent will call HNSource setMediTime() API by setting it number of seconds to skip backward and check the status returned by the API.</p><p>10. Onsuccess of setMediTime(), endtoendrmf stub agent will call </p><p> HNSource close() API.</p><p>11.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro9"><td style="text-align:right; width:0.5134in; " class="ce2"><p>37</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_37</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when Skip backward is done at the starting point of the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setMediaTime()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setMediaTime:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.On success of play,endtoendrmf stub agent will call HNSource setMediTime() API by setting it number of seconds to skip backward and check the status returned by the API.</p><p>10. Onsuccess of setMediTime(), endtoendrmf stub agent will call </p><p> HNSource close() API.</p><p>11.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro13"><td style="text-align:right; width:0.5134in; " class="ce2"><p>38</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_38</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the transition in the video playback by allowing the video to play for sometime and then rewind the video for sometime and then do Fast Forward at 4x speed</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is 0 rate as appended in URL and check the status returned by the API.</p><p>9.On success of play, let the video play for some time, endtoendrmf stub agent will call HNSource getSpeed() API and check the speed.</p><p>10.After defined period,endtoendrmf stub agent will call HNSource setSpeed() API by setting it -4x (rewind) and check the status returned by the API.</p><p>11.On success of setSpeed,let the video rewind  for some time, endtoendrmf stub agent will call HNSource getSpeed API() to check the speed.</p><p>12.On success of getSpeed, endtoendrmf stub agent will call HNSource setSpeed API() to forward in 4x rate and play it for some time.</p><p>13.On success of setSpeed API(), endtoendrmf stub agent will call getSpeed to verify the speed.</p><p>12.On success of getSpeed, endtoendrmf stub agent will call HNSource close() API.</p><p>13.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>14.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>15.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the state returned by the getState API for pause state. </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro14"><td style="text-align:right; width:0.5134in; " class="ce2"><p>39</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_39</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the transition in the video playback by allowing the video to play for sometime and then rewind the video to the starting point and then do Fast Forward at various speeds</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is 0 rate as appended in URL and check the status returned by the API.</p><p>9.On success of play, let the video play for some time, endtoendrmf stub agent will call HNSource getSpeed() API and check the speed.</p><p>10.After defined period,endtoendrmf stub agent will call HNSource setSpeed() API by setting it -4x (rewind) and check the status returned by the API.</p><p>11.On success of setSpeed,let the video rewind till starting point, endtoendrmf stub agent will call HNSource getSpeed API() to check the speed.</p><p>12.On success of getSpeed, endtoendrmf stub agent will call HNSource setSpeed API() to forward in 4x,8x,16x,32x,64x(provided by TM) rate and play it for some time.</p><p>13.On success of setSpeed API(), endtoendrmf stub agent will call getSpeed to verify the speed.</p><p>14.On success of getSpeed, endtoendrmf stub agent will call HNSource close() API.</p><p>15.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>16.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>17.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the state returned by the getState API for pause state. </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro15"><td style="text-align:right; width:0.5134in; " class="ce2"><p>40</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_40</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the transition in the video playback by allowing the video to play for sometime and then fast forward the video for sometime and then do rewind at 4x speed</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.On success of play, let the video play for some time, endtoendrmf stub agent will call HNSource getSpeed() API and check the speed.</p><p>10.After defined period,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 4x (forward) and check the status returned by the API.</p><p>11.On success of setSpeed,let the video forward  for some time, endtoendrmf stub agent will call HNSource getSpeed API() to check the speed.</p><p>12.On success of getSpeed, endtoendrmf stub agent will call HNSource setSpeed API() to rewind in 4x rate and play it for some time.</p><p>13.On success of setSpeed API(), endtoendrmf stub agent will call getSpeed to verify the speed.</p><p>12.On success of getSpeed, endtoendrmf stub agent will call HNSource close() API.</p><p>13.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>14.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>15.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the state returned by the getState API for pause state. </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro15"><td style="text-align:right; width:0.5134in; " class="ce2"><p>41</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_41</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the transition in the video playback by allowing the video to play for sometime and then do Fast Forward to the ending point and then do Rewind at various speeds</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce13"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is 0 rate as appended in URL and check the status returned by the API.</p><p>9.On success of play, let the video play for some time, endtoendrmf  stub agent will call HNSource getSpeed() API and check the speed.</p><p>10.After defined period,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 4x (forward) and check the status returned by the API.</p><p>11.On success of setSpeed,let the video forward till ending point, endtoendrmf stub agent will call HNSource getSpeed API() to check the speed.</p><p>12.On success of getSpeed, endtoend stub agent will call HNSource setSpeed API() to rewind in 4x,8x,16x,32x,64x(provided by TM) rate and play it for some time.</p><p>13.On success of setSpeed API(), endtoendrmf stub agent will call getSpeed to verify the speed.</p><p>12.On success of getSpeed, endtoendrmf stub agent will call HNSource close() API.</p><p>13.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>14.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>15.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the state returned by the getState API for pause state. </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro16"><td style="text-align:right; width:0.5134in; " class="ce2"><p>42</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_42</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the transition in the playback of a long duration video(2hrs) by doing (Fast Forward &lt;--&gt; play &lt;--&gt; Rewind) at specific intervals between the starting and end point of the video. </p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 4x (forward) and check the status returned by the API.</p><p>10. Onsuccess of setSpeed, endtoendrmf stub agent will call HNSource getSpeed API() to check the playback rate.</p><p>11.On success of getSpeed, endtoendrmf stub agent will call</p><p>SetSpeed() API to play it in a normal speed (1.0), and check the return.</p><p>12.On success of getSpeed, endtoendrmf stub agent will call </p><p>SetSpeed() API by setting it to -4x (rewind) and check the return.</p><p>13.On success of getSpeed, endtoendrmf stub agent will call</p><p> HNSource close() API.</p><p>14.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>15.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>16.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro15"><td style="text-align:right; width:0.5134in; " class="ce2"><p>43</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_43</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the transition in the video playback by allowing the video to play for sometime, then doing Fast Forward at 4x speed and then pause &amp; play the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFStateChangeReturn getState()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFStateChangeReturn getState:RMFState *, RMFState *</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 4x (forward) and check the status returned by the API.</p><p>10. On success of setSpeed, endtoendrmf stub agent will call HNSource getSpeed API() to check the playback rate.</p><p>11.On success of getSpeed, endtoendrmf stub agent will call</p><p>SetSpeed() API to pause by passing 0, and check the return value if the API.</p><p>12.On success of setSpeed, endtoendrmf stub agent will call </p><p>getState() API and check the return state to be pause.</p><p>13.On success of getState, endtoendrmf stub agent will call</p><p> HNSource setSpeed () API to play in normal speed 1.0..</p><p>14. On success of setSpeed, endtoendrmf stub agent will call getSpeed API and speed should be 1.0.</p><p>15. On success of getSpeed, endtoendrmf stub agent will call</p><p> HNSource close() API.</p><p>16.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>17.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>18.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p><p>Checkpoint 3.Check the state returned by the getState API for pause and play state. </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro15"><td style="text-align:right; width:0.5134in; " class="ce2"><p>44</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_44</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the transition in the video playback by allowing the video to play for sometime, then doing Rewind at 4x speed and then pause &amp; play the video</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFStateChangeReturn getState()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFStateChangeReturn getState:RMFState *, RMFState *</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it -4x (rewind) and check the status returned by the API.</p><p>10. On success of setSpeed, endtoendrmf stub agent will call HNSource getSpeed API() to check the playback rate.</p><p>11.On success of getSpeed, endtoendrmf stub agent will call</p><p>SetSpeed() API to pause by passing 0, and check the return value if the API.</p><p>12.On success of setSpeed, endtoendrmf stub agent will call </p><p>getState() API and check the return state to be pause.</p><p>13.On success of getState, endtoendrmf stub agent will call</p><p> HNSource setSpeed () API to play in normal speed 1.0..</p><p>14. On success of setSpeed, endtoendrmf stub agent will call getSpeed API and speed should be 1.0.</p><p>15. On success of getSpeed, endtoendrmf stub agent will call</p><p> HNSource close() API.</p><p>16.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>17.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>18.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p><p>Checkpoint 3.Check the state returned by the getState API for pause and play state. </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro16"><td style="text-align:right; width:0.5134in; " class="ce2"><p>45</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_45</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the transition in the video playback by allowing the video to play for sometime, then pause the video and then do Fast Forward at 4x speed while the video is paused</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFStateChangeReturn getState()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFStateChangeReturn getState:RMFState *, RMFState *</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 0 (pause) and check the status returned by the API.</p><p>10. On success of setSpeed, endtoendrmf stub agent will call HNSource getState API() to check the state.</p><p>11.On success of getState, endtoendrmf stub agent will call</p><p>SetSpeed() API to forward by passing 4x, and check the return value the API.</p><p>12.On success of setSpeed, endtoendrmf stub agent will call </p><p>getSpeed() API and check the return speed of  the play back.</p><p>13. On success of getSpeed, endtoendrmf stub agent will call</p><p> HNSource close() API.</p><p>14.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>15.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>16.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p><p>Checkpoint 3.Check the state returned by the getState API for pause and play state. </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro16"><td style="text-align:right; width:0.5134in; " class="ce2"><p>46</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_46</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the transition in the video playback by allowing the video to play for sometime, then pause the video and then do Fast Rewind at 4x speed while the video is paused</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFStateChangeReturn getState()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFStateChangeReturn getState:RMFState *, RMFState *</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 0 (pause) and check the status returned by the API.</p><p>10. On success of setSpeed, endtoendrmf stub agent will call HNSource getState API() to check the state.</p><p>11.On success of getState, endtoendrmf stub agent will call</p><p>SetSpeed() API to rewind by passing -4x, and check the return value the API.</p><p>12.On success of setSpeed, endtoendrmf stub agent will call </p><p>getSpeed() API and check the return speed of  the play back.</p><p>13. On success of getSpeed, endtoendrmf stub agent will call</p><p> HNSource close() API.</p><p>14.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>15.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>16.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p><p>Checkpoint 3.Check the state returned by the getState API for pause and play state. </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro15"><td style="text-align:right; width:0.5134in; " class="ce2"><p>47</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_47</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the transition in the playback of a long duration video(2hrs) by doing (Fast Forward &lt;--&gt; pause &lt;--&gt; play &lt;--&gt; Rewind) at specific intervals between the starting and end point of the video. </p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFStateChangeReturn getState()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFStateChangeReturn getState:RMFState *, RMFState *</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is 4x as appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 0 (pause) and check the status returned by the API.</p><p>10. On success of setSpeed, endtoendrmf stub agent will call HNSource getState API() to check the state.</p><p>11.On success of getState, endtoendrmf stub agent will call</p><p>SetSpeed() API to rewind by passing 1.0 to play in normal speed, and check the return value the API.</p><p>12.On success of setSpeed, endtoendrmf stub agent will call </p><p>getSpeed() API and check the return speed of  the play back.</p><p>13. On success of getSpeed, endtoendrmf stub agent will call</p><p>SetSpeed() by passing -4x (rewind) and check the return value.</p><p>14. On success of setSpeed, endtoendrmf stub agent will call </p><p>getSpeed() API and check the return speed of  the play back.</p><p>15. On success of setSpeed, endtoendrmf stub agent will call </p><p> HNSource close() API.</p><p>16.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>17.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>18.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p><p>Checkpoint 3.Check the state returned by the getState API for pause and play state. </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro16"><td style="text-align:right; width:0.5134in; " class="ce2"><p>48</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_48</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback by playing the video from the starting point and pausing it after sometime and again playing the video and then doing a (skip forward/skip backward) multiple times.</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFStateChangeReturn getState()</p><p>RMFResult setMediaTIme()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFStateChangeReturn getState:RMFState *, RMFState *</p><p>RMFResult setMediaTIme:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent. 2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”. 3.endtoendrmf stub agent will call init() of HNSource and return the status of the API. 4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API. 5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API. 6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API. 7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API. 8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API. 9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it 0 (pause) and check the status returned by the API. 10. On success of setSpeed, endtoendrmf stub agent will call HNSource getState API() to check the state. 11.On success of getState, endtoendrmf stub agent will call SetSpeed() API to play by passing 1.0 to play in normal speed, and check the return value the API. 12.On success of setSpeed, endtoendrmf stub agent will call  getSpeed() API and check the return speed of  the play back. 13. On success of getSpeed, endtoendrmf stub agent will call setMediaTime() by passing number of seconds to skip forward and check the return value. 14. On success of setMediaTime, endtoendrmf stub agent will call  Agian setMediaTime() API by passing number of seconds to skip backward and check the return value. 15. On success of setMediaTime, Repeat the step 13 and 14 multiple time (value given by TM),and  endtoendrmf stub agent will call  HNSource close() API. 16.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API. 17.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API. </p><p>18.endtoendrmf stub agent will send SUCCESS or FAILURE to TM. </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the state returned by the getState API for pause and play state. </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro17"><td style="text-align:right; width:0.5134in; " class="ce2"><p>49</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_49</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when (Fast Forward/Rewind) is done at 4x speed from the starting point of the video and then (Skip Forward/Skip Backward) is done once</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult setMediaTIme()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult setMediaTIme:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is 4x as appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it -4x (rewind) and check the status returned by the API.</p><p>10. On success of setSpeed, endtoendrmf stub agent will call HNSource setMediaTime API() by passing number of seconds to skip forward and check the return of the API</p><p>11.On success of setMediaTime, endtoendrmf stub agent will call</p><p>setMediaTime() API  by passing number of seconds to skip backward and check the return of the API</p><p>12. On success of setMediaTime, endtoendrmf stub agent will call </p><p> HNSource close() API.</p><p>13.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>14.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>15.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro16"><td style="text-align:right; width:0.5134in; " class="ce2"><p>50</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_50</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the video playback when (Fast Forward/Rewind) is done at 4x speed from the starting point of the video and then (Skip Forward/Skip Backward) is done multiple times</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult setMediaTIme()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult setMediaTIme:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is 4x as appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it -4x (rewind) and check the status returned by the API.</p><p>10. On success of setSpeed, endtoendrmf stub agent will call HNSource setMediaTime API() by passing number of seconds to skip forward and check the return of the API</p><p>11.On success of setMediaTime, endtoendrmf stub agent will call</p><p>setMediaTime() API  by passing number of seconds to skip backward and check the return of the API</p><p>12. On success of setMediaTime,Repeat the step 10 and 11 multiple times (TM passes the value for repeating), and endtoendrmf stub agent will call HNSource close() API.</p><p>13.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>14.On success of  term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>15.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro16"><td style="text-align:right; width:0.5134in; " class="ce2"><p>51</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_51</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the playback of a long duration video when (Fast Forward/Rewind) is done at various speeds from the starting point of the video and then (Skip Forward/Skip Backward) is done once</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult setMediaTIme()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult setMediaTIme:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content.</p><p>9. Speed will be in 4x rate as appended in URL and check the status returned by the API.</p><p>10.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API by setting it -4x (rewind) and check the status returned by the API.</p><p>11. On success of setSpeed, Repeat the step 9 and 10 multiple times (TM passes the value for repeating), and endtoendrmf stub agent will call HNSource setMediaTime API() by passing number of seconds to skip forward and check the return of the API</p><p>12.On success of setMediaTime, endtoendrmf stub agent will call</p><p>setMediaTime() API  by passing number of seconds to skip backward and check the return of the API</p><p>13. On success of setMediaTime, endtoendrmf stub agent will call </p><p> HNSource close() API.</p><p>14.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>15.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>16.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro8"><td style="text-align:right; width:0.5134in; " class="ce2"><p>52</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_52</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the playback of a long duration video when (Fast Forward/Rewind) is done at various speeds from the starting point of the video and then (Skip Forward/Skip Backward) is done multiple times</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Positive</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFResult setSpeed()</p><p>RMFResult getSpeed()</p><p>RMFResult setMediaTIme()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFResult setSpeed:float</p><p>RMFResult getSpeed:float</p><p>RMFResult setMediaTIme:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- At least one video must be selected for playing from recording list.                                                          - No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   - XG1 should have one or more recordings in it.</p><p>- Recording should be for long duration.</p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL and return the status of the API.</p><p>5.On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is 4x as appended in URL and check the status returned by the API.</p><p>9.After defined period of play,endtoendrmf stub agent will call HNSource setSpeed() API to set speed in different rate (4x, 8x, 16x, 32x 64x either forward/rewind) and check the status returned by the API.</p><p>10. On success of setSpeed, endtoendrmf stub agent will call HNSource setMediaTime API() by passing number of seconds to skip forward and check the return of the API</p><p>11.On success of setMediaTime, endtoendrmf stub agent will call</p><p>setMediaTime() API  by passing number of seconds to skip backward and check the return of the API</p><p>12. On success of setMediaTime,Repeat the step 10 and 11 multiple times (TM passes the value for repeating), and endtoendrmf stub agent will call HNSource close() API.</p><p>13.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>14.On success of  term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>15.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the speed retuned by HNSource getSpeed() API.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro10"><td style="text-align:right; width:0.5134in; " class="ce2"><p>53</p></td><td style="text-align:left;width:2.9929in; " class="ce4"><p>E2E_DVR_TrickPlay_53</p></td><td style="text-align:left;width:2.6in; " class="ce5"><p>To verify the dvr playback if the input url entered is wrong/recorded content is not avaliable.</p></td><td style="text-align:left;width:2.0862in; " class="ce9"><p>Negative</p></td><td style="text-align:left;width:2.0862in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init()</p><p>RMFResult open()</p><p>RMFResult play()</p><p>RMFResult term()</p><p>RMFResult SetVideoRectangle()</p><p>RMFResult setSource()</p><p>RMFStateChangeReturn getState()</p><p>RMFResult close()</p><p>RMFResult term()</p></td><td style="text-align:left;width:3.4736in; " class="ce11"><p>RMFResult init: None</p><p>RMFResult term: None</p><p>RMFResult open:Char *,Char *</p><p>RMFResult play:None</p><p>RMFResult setVideoRectangle: unsigned.</p><p>unsigned, unsigned, </p><p>unsigned, bool apply_now – x,y,h,w,false</p><p>RMFResult setSource:RMFMediaSourceBase*</p><p>RMFStateChangeReturn getState:RMFState *, RMFState *</p><p>RMFResult setMediaTIme:double</p><p>RMFResult close:None</p><p> </p></td><td style="text-align:left;width:3.4736in; " class="ce12"><p>- No other recording is scheduled to start during the test.                                                                       - XG1 and XI3 board should be up and running in same network                                                                   </p><p> </p></td><td style="text-align:left;width:4.2165in; " class="ce14"><p>1.TM loads endtoendrmf stub agent via the test agent.</p><p>2.TM will invoke “TestMgr_Dvr_Play_TrickPlay_FF_FR”.</p><p>3.endtoendrmf stub agent will call init() of HNSource and return the status of the API.</p><p>4.On success of init(),endtoendrmf stub agent will call the HNSource open() API by passing the URL(wrong recording id/invalid url) and API should return Failure/Invalid Argument.</p><p>5.On failure of open() API Goto step 11. On success of open(),endtoendrmf stub agent will call MP Sink init() API and return the status of the API.</p><p>6.On success of init(),endtoendrmf stub agent will call the MPSink setVideoRectangle() API by passing the  video co-ordinates and return the status returned by the API.</p><p>7.On success of setVideoRectangle(), endtoendrmf stub agent will call the MPSink setSource() API by passing the HNSource instance and  check the status returned by the API.</p><p>8.On success of SetSource(),endtoendrmf stub agent will call the HNSource play() API to play the recorded content in the speed which is appended in URL and check the status returned by the API.</p><p>9.endtoendrmf stub agent will call HNSource getState() API to querywhether video is playing or not and check the status returned by the API.</p><p>10. On Failure/success of getState, endtoendrmf stub agent will call HNSource close() API.</p><p>11.On success of close,endtoendrmf stub agent will call HNSource term() and check the status returned by the API.</p><p>12.On success of term(),endtoendrmf stub agent will call MPSink term() and check the status returned by the API.</p><p>13.endtoendrmf stub agent will send SUCCESS or FAILURE to TM.</p><p> </p></td><td style="text-align:left;width:2.0319in; " class="ce11"><p>Checkpoint 1.Check the return values of API's for success status.</p><p>Checkpoint 2.Check the state returned by the getState API for pause state.</p><p> </p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Medium</p></td><td style="text-align:left;width:1.922in; " class="ce11"><p>libendtoendrmfstub.so</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:0.5134in; " class="ce3"> </td><td style="text-align:left;width:2.9929in; " class="ce3"> </td><td style="text-align:left;width:2.6in; " class="ce3"> </td><td style="text-align:left;width:2.0862in; " class="ce3"> </td><td style="text-align:left;width:2.0862in; " class="ce3"> </td><td style="text-align:left;width:3.4736in; " class="ce3"> </td><td style="text-align:left;width:3.4736in; " class="ce3"> </td><td style="text-align:left;width:3.4736in; " class="ce3"> </td><td style="text-align:left;width:4.2165in; " class="ce3"> </td><td style="text-align:left;width:2.0319in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:1.922in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:0.5134in; " class="ce3"> </td><td style="text-align:left;width:2.9929in; " class="ce3"> </td><td style="text-align:left;width:2.6in; " class="ce3"> </td><td style="text-align:left;width:2.0862in; " class="ce3"> </td><td style="text-align:left;width:2.0862in; " class="ce3"> </td><td style="text-align:left;width:3.4736in; " class="ce3"> </td><td style="text-align:left;width:3.4736in; " class="ce3"> </td><td style="text-align:left;width:3.4736in; " class="ce3"> </td><td style="text-align:left;width:4.2165in; " class="ce3"> </td><td style="text-align:left;width:2.0319in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:1.922in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr></table><table border="0" cellspacing="0" cellpadding="0" class="ta2"><colgroup><col width="70"/><col width="158"/><col width="240"/><col width="99"/><col width="99"/><col width="273"/><col width="241"/><col width="99"/><col width="99"/></colgroup><tr class="ro19"><td style="text-align:left;width:0.6335in; " class="ce1"><p>Sl. No.</p></td><td style="text-align:left;width:1.4201in; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:2.1626in; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:0.8925in; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:0.8925in; " class="ce1"><p>Test Setup</p></td><td style="text-align:left;width:2.4575in; " class="ce1"><p>Pre-requisite</p></td><td style="text-align:left;width:2.1736in; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce15"><p>Exp Output</p></td><td style="text-align:left;width:0.8925in; " class="ce1"><p>Priority</p></td></tr><tr class="ro20"><td style="text-align:right; width:0.6335in; " class="ce2"><p>1</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_01</p></td><td style="text-align:left;width:2.1626in; " class="ce18"><p>To verify that all six client boxes  [XI3 ] can watch up to six linear TV channels simultaneously without any issues.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect six XI3 client boxes through XG1.                              2)Agent will be running in all the 6 xi3 boxes.              3)Framework schedules to select six linear TV channels in each box simultaneously.                    4)And request agent to tune to the requested channels.              5)There should not be any issue to watch six linear TV channels simultaneously                             (Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro21"><td style="text-align:right; width:0.6335in; " class="ce2"><p>2</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_02</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify one SD service &amp; 5 HD services are playing from six XI3 boxes simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect six XI3 client boxes through XG1.                              2)Agent will be running in all the 6 xi3 boxes.              3)Framework schedules to select six linear TV channels in each box simultaneously.                    4)And requests agent to tune to one SD and 5 HD channels.          5)There should not be any issue to watch six linear TV channels simultaneously                             (Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro21"><td style="text-align:right; width:0.6335in; " class="ce2"><p>3</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_03</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify 2 SD service &amp; 4 HD services are playing from six XI3 boxes simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect six XI3 client boxes through XG1.                              2)Agent will be running in all the 6 xi3 boxes.              3)Framework schedules to select six linear TV channels in each box simultaneously.                    4)And requests agent to tune to 2 SD and 4 HD channels.          5)There should not be any issue to watch six linear TV channels simultaneously                             (Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro21"><td style="text-align:right; width:0.6335in; " class="ce2"><p>4</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_04</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify 3 SD service &amp; 3 HD services are playing from six XI3 boxes simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect six XI3 client boxes through XG1.                              2)Agent will be running in all the 6 xi3 boxes.              3)Framework schedules to select six linear TV channels in each box simultaneously.                    4)And requests agent to tune to 3 SD and 3 HD channels.          5)There should not be any issue to watch six linear TV channels simultaneously                             (Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro21"><td style="text-align:right; width:0.6335in; " class="ce2"><p>5</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_05</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify 4 SD service &amp; 2 HD services are playing from six XI3 boxes simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect six XI3 client boxes through XG1.                              2)Agent will be running in all the 6 xi3 boxes.              3)Framework schedules to select six linear TV channels in each box simultaneously.                    4)And requests agent to tune to 4 SD and 2 HD channels.          5)There should not be any issue to watch six linear TV channels simultaneously                             (Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro21"><td style="text-align:right; width:0.6335in; " class="ce2"><p>6</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_06</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify 5 SD service &amp; 1 HD services are playing from six XI3 boxes simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect six XI3 client boxes through XG1.                              2)Agent will be running in all the 6 xi3 boxes.              3)Framework schedules to select six linear TV channels in each box simultaneously.                    4)And requests agent to tune to 5 SD and 1 HD channels.          5)There should not be any issue to watch six linear TV channels simultaneously                             (Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro21"><td style="text-align:right; width:0.6335in; " class="ce2"><p>7</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_07</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify 6 HD services are playing from six XI3 boxes simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect six XI3 client boxes through XG1.                              2)Agent will be running in all the 6 xi3 boxes.              3)Framework schedules to select six linear TV channels in each box simultaneously.                    4)And requests agent to tune to 6 HD channels.                       5)There should not be any issue to watch six linear TV channels simultaneously                             (Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro21"><td style="text-align:right; width:0.6335in; " class="ce2"><p>8</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_08</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify 6 SD services are playing from six XI3 boxes simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect six XI3 client boxes through XG1.                              2)Agent will be running in all the 6 xi3 boxes.              3)Framework schedules to select six linear TV channels in each box simultaneously.                    4)And requests agent to tune to 6 SD channels.                       5)There should not be any issue to watch six linear TV channels simultaneously                             (Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro22"><td style="text-align:right; width:0.6335in; " class="ce2"><p>9</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_09</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify tuning time for channel change.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agent to tune to a channel.                       4) And framework request the agent to change the channel and verify the tuning time for channel change.                           (Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro23"><td style="text-align:right; width:0.6335in; " class="ce2"><p>10</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_10</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify that all six QAM channels are locked, playing AV for long time. User shouldn't disturb the box for 10hrs,once all six QAM channels locked. XG1 Box is expected to decode AV even after 10hrs without any issues. </p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agent to tune to a channel.                       4) And framework request the agent to schedule the box for long time duration.                      (Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro24"><td style="text-align:right; width:0.6335in; " class="ce2"><p>11</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_11</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify that all 6 linear TV is decoding simultaneously amidst of the other functions. In this test other functions of XG1 are invoked while 6 channels are decoding lively. Other functions like Voice ( HD Voice, DECT phone, IP TV, Smart TV etc.). XG1 Box is expect to decode 6 channels while it services other functions as well. </p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agent to tune to a channel.                       4) And framework request the agent to schedule the box for long time duration.</p><p>5) schedule an DVR recording feature.                      (Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro23"><td style="text-align:right; width:0.6335in; " class="ce2"><p>12</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_12</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify that fast channel change feature supports in all five 5 linear TV signals tuned to XG1 from all five XI3 client boxes simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agent to tune to a channel.                       4) And framework request the agent to schedule the box for long time duration.                      (Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro22"><td style="text-align:right; width:0.6335in; " class="ce2"><p>13</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_13</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify that fast channel change feature supports in all five 5 linear TV signals tuned to XG1 from all five XI3 client boxes decoding only  SD services simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a SD channel.                       4) And framework schedules the agent to fast change the channel to another SD channel on the boxes(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro22"><td style="text-align:right; width:0.6335in; " class="ce2"><p>14</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_14</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify that fast channel change feature supports in all five 5 linear TV signals tuned to XG1 from all five XI3 client boxes decoding only  HD services simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel.                       4) And framework schedules the agent to fast change the channel to another HD channel on the boxes(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro21"><td style="text-align:right; width:0.6335in; " class="ce2"><p>15</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_15</p></td><td style="text-align:left;width:2.1626in; " class="ce18"><p>To verify the fast channel change when 3 SD services  &amp; 2 HD services  are decoded simultaneously. </p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel on 2 client boxes and 3 boxes with SD chanel.</p><p>4) And framework schedules the agent to fast change the channel to another HD channel on the boxes(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce2"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro24"><td style="text-align:right; width:0.6335in; " class="ce2"><p>16</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_16</p></td><td style="text-align:left;width:2.1626in; " class="ce18"><p>To verify the fast channel change when 4 SD services  &amp; 1 HD services  are decoded simultaneously. </p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel on 1 client box and 4 boxes with SD chanel.</p><p>4) And framework schedules the agent to fast change the channel to another HD channel on the boxes(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce2"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro24"><td style="text-align:right; width:0.6335in; " class="ce2"><p>17</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_17</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify the fast channel change when 3 HD services  &amp; 2 SD services  are decoded simultaneously. </p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel on 2 client box and 3 boxes with SD chanel.</p><p>4) And framework schedules the agent to fast change the channel to another HD channel on the boxes(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro24"><td style="text-align:right; width:0.6335in; " class="ce2"><p>18</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_18</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify the fast channel change when 4 HD services  &amp; 1 SD services  are decoded simultaneously. </p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel on 1 client box and 4 boxes with SD chanel.</p><p>4) And framework schedules the agent to fast change the channel to another HD channel on the boxes(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro22"><td style="text-align:right; width:0.6335in; " class="ce2"><p>19</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_19</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify the fast  channel change feature while XI3 Box is recording SD services. </p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a SD channel on 1 client box and start recording.</p><p>4) And framework schedules the agent to fast change the channel while recording is on(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro22"><td style="text-align:right; width:0.6335in; " class="ce2"><p>20</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_20</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify the fast  channel change feature while XI3 Box is recording HD services. </p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel on 1 client box and start recording.</p><p>4) And framework schedules the agent to fast change the channel while recording HD channel is on on(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro22"><td style="text-align:right; width:0.6335in; " class="ce2"><p>21</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_21</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify fast channel change feature is working fine when the SD content is scheduled to record. </p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a SD channel on 1 client box and start recording.</p><p>4) And framework schedules the agent to fast change the channel while recording SD Channel  is on(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro22"><td style="text-align:right; width:0.6335in; " class="ce2"><p>22</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_22</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify fast channel change feature is working fine when the HD content is scheduled to record. </p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel on 1 client box and start recording.</p><p>4) And framework schedules the agent to fast change the channel while recording HD channel is on on(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro24"><td style="text-align:right; width:0.6335in; " class="ce2"><p>23</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_23</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify that fast channel change feature  while all five XI3 are recording HD services simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel on 5client box and start recording.</p><p>4) And framework schedules the agent to fast change the channel while recording 5 HD channel is on on(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro21"><td style="text-align:right; width:0.6335in; " class="ce2"><p>24</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_24</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify the fast channel change while four XI3 boxes recording HD content  &amp; one XI3 box recording SD content simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel on 4 client box and SD channel on one client box and start recording on each box.</p><p>4) And framework schedules the agent to fast change the channel while recording  is  on(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro21"><td style="text-align:right; width:0.6335in; " class="ce2"><p>25</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_25</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify the fast channel change while three XI3 boxes are recording HD contents  &amp; two XI3 boxes are recording SD contents simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel on 3 client box and SD channel on 2 client box and start recording on each box.</p><p>4) And framework schedules the agent to fast change the channel while recording  is on(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro21"><td style="text-align:right; width:0.6335in; " class="ce2"><p>26</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_26</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify the fast channel change while two XI3 boxes are recording HD contents  &amp; three XI3 boxes are recording SD contents simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel on 2 client box and SD channel on 3 client box and start recording on each box.</p><p>4) And framework schedules the agent to fast change the channel while recording  is on(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro21"><td style="text-align:right; width:0.6335in; " class="ce2"><p>27</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_27</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify the fast channel change while one XI3 box recording HD content  &amp; four boxes are recording SD contents simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel on 1 client box and SD channel on 4 client box and start recording on each box.</p><p>4) And framework schedules the agent to fast change the channel while recording  is on(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro24"><td style="text-align:right; width:0.6335in; " class="ce2"><p>28</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_28</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify the fast channel change feature while all five XI3 boxes are recording SD services simultaneously.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce18"><p>1. Input RF link should have six different services simultaneously    (Active signal should be available)    2. XG1 is connected through XI3 client box through RF.                       3. XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                2)Agent will be running in the xi3 box.                   3)Framework requests agents to tune to a HD channel on 5client box and start recording.</p><p>4) And framework schedules the agent to fast change the channel while recording 5 HD channel is on on(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro25"><td style="text-align:right; width:0.6335in; " class="ce2"><p>29</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_29</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify SD content is Played back from various XI3 boxes  connected to  XG1 box.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce19"><p>1. There should be some SD DVR recordingsin the XG1  box  </p><p>2. XG1 is connected through XI3 client box.                                      </p><p>3. XG1 &amp; all XI3 boxes should be up &amp; running.</p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                </p><p>2)Agent will be running in the xi3 box.                   </p><p>3) And framework schedules the agent to play back the DVR  on each boxes(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro25"><td style="text-align:right; width:0.6335in; " class="ce2"><p>30</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_30</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify HD content is Played back from various XI3 boxes  connected to  XG1 box.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce19"><p>1. There should be some SD DVR recordings in the XG1  box  </p><p>2. XG1 is connected through XI3 client box.                                      </p><p>3. XG1 &amp; all XI3 boxes should be up &amp; running.</p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                </p><p>2)Agent will be running in the xi3 box.                   </p><p>3) And framework schedules the agent to play back the DVR  on each boxes(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro26"><td style="text-align:right; width:0.6335in; " class="ce2"><p>31</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_31</p></td><td style="text-align:left;width:2.1626in; " class="ce18"><p>To verify that both SD &amp; HD DVR contents are accessed( play back) from various XI3 client boxes across home  simultaneously through XG1 boxes.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce19"><p>1. There should be some SD  and HD DVR recordings in the XG1  box  </p><p>2. XG1 is connected through XI3 client box.                                      </p><p>3. XG1 &amp; all XI3 boxes should be up &amp; running.</p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                </p><p>2)Agent will be running in the xi3 box.                   </p><p>3) And framework schedules the agent to play back both the HD &amp; SD DVR recordings  on each boxes(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro26"><td style="text-align:right; width:0.6335in; " class="ce2"><p>32</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_32</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify that from DVR all XI3 client boxes can access ( Playback ) the SD content simultaneously with out any issues.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce19"><p>1. There should be some SD  DVR recordings in the XG1  box  </p><p>2. XG1 is connected through XI3 client box.                                      </p><p>3. XG1 &amp; all XI3 boxes should be up &amp; running.</p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                </p><p>2)Agent will be running in the xi3 box.                   </p><p>3) And framework schedules the agent to play back the same SD DVR recordings  on each boxes(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro26"><td style="text-align:right; width:0.6335in; " class="ce2"><p>33</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_33</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify that from DVR all XI3 client boxes can access ( Playback ) the HD content simultaneously with out any issues.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce19"><p>1. There should be some HD  DVR recordings in the XG1  box  </p><p>2. XG1 is connected through XI3 client box.                                      </p><p>3. XG1 &amp; all XI3 boxes should be up &amp; running.</p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                </p><p>2)Agent will be running in the xi3 box.                   </p><p>3) And framework schedules the agent to play back the same HD DVR recordings  on each boxes(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro23"><td style="text-align:right; width:0.6335in; " class="ce2"><p>34</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_34</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify that Record program list is getting updated if any one of the XI3 box is initiating the Record.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce19"><p>1. There should be some HD  DVR recordings in the XG1  box  </p><p>2. XG1 is connected through XI3 client box.                                      </p><p>3. XG1 &amp; all XI3 boxes should be up &amp; running.</p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                </p><p>2)Agent will be running in the xi3 box.                   </p><p>3) And framework schedules the agent to record the DVR and on other box fw will display the list of recording.verify the recordings are updated.(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro23"><td style="text-align:right; width:0.6335in; " class="ce2"><p>35</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_35</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>To verify that Delete program list is getting updated if any one of the XI3 box is deleting the existing program from the list.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce19"><p>1. There should be some  DVR recordings in the XG1  box  </p><p>2. XG1 is connected through XI3 client box.                                      </p><p>3. XG1 &amp; all XI3 boxes should be up &amp; running.</p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                </p><p>2)Agent will be running in the xi3 box.                   </p><p>3) And framework schedules the agent to delete a DVR reocording and on other box fw will display the list of recording.verify the recordings are updated.(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro26"><td style="text-align:right; width:0.6335in; " class="ce2"><p>36</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_36</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>When all the XI3 boxes are initiating the record options simultaneously, XG1 box should accept maximum number of possible inputs  without any issues.</p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce19"><p> </p><p>1. XG1 is connected through XI3 client box.                                      </p><p>2. XG1 &amp; all XI3 boxes should be up &amp; running.</p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                </p><p>2)Agent will be running in the xi3 box.                   </p><p>3) And framework schedules the agent to record the DVR recordings on all the boxes connected.(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro23"><td style="text-align:right; width:0.6335in; " class="ce2"><p>37</p></td><td style="text-align:left;width:1.4201in; " class="ce18"><p>E2E_RF_Video_37</p></td><td style="text-align:left;width:2.1626in; " class="ce19"><p>In gateway ecosystem, when four XI3  clients boxes initiating recording for linear TV and one XI3 initiating the playback, XG1 box should accept all the request and service accordingly with out any issues.  </p></td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:2.4575in; " class="ce19"><p> </p><p>1. XG1 is connected through XI3 client box.                                      </p><p>2. XG1 &amp; all XI3 boxes should be up &amp; running.</p></td><td style="text-align:left;width:2.1736in; " class="ce18"><p>1)Connect XI3 client box through XG1.                                </p><p>2)Agent will be running in the xi3 box.                   </p><p>3) And framework schedules the agent to record the DVR recordings on 4 of the boxes connected and initiate a playback on one of the box(Need to decide on approach)</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>Medium</p></td></tr><tr class="ro18"><td style="text-align:left;width:0.6335in; " class="ce3"> </td><td style="text-align:left;width:1.4201in; " class="ce3"> </td><td style="text-align:left;width:2.1626in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:2.4575in; " class="ce3"> </td><td style="text-align:left;width:2.1736in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:0.6335in; " class="ce3"> </td><td style="text-align:left;width:1.4201in; " class="ce3"> </td><td style="text-align:left;width:2.1626in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:2.4575in; " class="ce3"> </td><td style="text-align:left;width:2.1736in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr></table><table border="0" cellspacing="0" cellpadding="0" class="ta3"><colgroup><col width="99"/><col width="253"/><col width="392"/><col width="99"/><col width="99"/><col width="235"/><col width="261"/><col width="99"/><col width="99"/></colgroup><tr class="ro19"><td style="text-align:left;width:0.8925in; " class="ce1"><p>Sl. No.</p></td><td style="text-align:left;width:2.2835in; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:3.5283in; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:0.8925in; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:0.8925in; " class="ce1"><p>Test Setup</p></td><td style="text-align:left;width:2.1193in; " class="ce1"><p>Pre-requisite</p></td><td style="text-align:left;width:2.3484in; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce15"><p>Exp Output</p></td><td style="text-align:left;width:0.8925in; " class="ce1"><p>Priority</p></td></tr><tr class="ro27"><td style="text-align:right; width:0.8925in; " class="ce20"><p>1</p></td><td style="text-align:left;width:2.2835in; " class="ce16"><p>E2E_DVR_Conflict_01</p></td><td style="text-align:left;width:3.5283in; " class="ce20"><p>To verify when 1<span class="T1">st</span><span class="T2"> XI3 box is scheduled for one time recording to maximum tuner and when user tries to schedule one more recording on other device Xi3 for same time then recording conflict will should happen.</span></p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>XG1-1_XI3-2</p></td><td style="text-align:left;width:2.1193in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.3484in; " class="ce16"><p>Need to decide on approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce2"><p>High</p></td></tr><tr class="ro18"><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:2.2835in; " class="ce3"> </td><td style="text-align:left;width:3.5283in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:2.1193in; " class="ce3"> </td><td style="text-align:left;width:2.3484in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:2.2835in; " class="ce3"> </td><td style="text-align:left;width:3.5283in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:2.1193in; " class="ce3"> </td><td style="text-align:left;width:2.3484in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr></table><table border="0" cellspacing="0" cellpadding="0" class="ta4"><colgroup><col width="99"/><col width="291"/><col width="252"/><col width="137"/><col width="99"/><col width="207"/><col width="253"/><col width="99"/><col width="99"/></colgroup><tr class="ro19"><td style="text-align:left;width:0.8925in; " class="ce1"><p>Sl. No.</p></td><td style="text-align:left;width:2.6217in; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:2.272in; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:1.2339in; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:0.8925in; " class="ce1"><p>Test Setup</p></td><td style="text-align:left;width:1.8681in; " class="ce1"><p>Pre-requisite</p></td><td style="text-align:left;width:2.2835in; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce15"><p>Exp Output</p></td><td style="text-align:left;width:0.8925in; " class="ce1"><p>Priority</p></td></tr><tr class="ro28"><td style="text-align:right; width:0.8925in; " class="ce2"><p>1</p></td><td style="text-align:left;width:2.6217in; " class="ce22"><p>E2E_DVR_Recording_01</p></td><td style="text-align:left;width:2.272in; " class="ce23"><p>To verify and perform recording of  the live channel play back.</p></td><td style="text-align:left;width:1.2339in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:1.8681in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.2835in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro29"><td style="text-align:right; width:0.8925in; " class="ce2"><p>2</p></td><td style="text-align:left;width:2.6217in; " class="ce22"><p>E2E_DVR_Recording_02</p></td><td style="text-align:left;width:2.272in; " class="ce23"><p>To verify and perform stop the ongoing recording of  the live on going channel.</p></td><td style="text-align:left;width:1.2339in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:1.8681in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.2835in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro29"><td style="text-align:right; width:0.8925in; " class="ce2"><p>3</p></td><td style="text-align:left;width:2.6217in; " class="ce22"><p>E2E_DVR_Recording_03</p></td><td style="text-align:left;width:2.272in; " class="ce23"><p>To verify and perform recording of 2 SD channels simultaneously.</p></td><td style="text-align:left;width:1.2339in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:1.8681in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.2835in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro29"><td style="text-align:right; width:0.8925in; " class="ce2"><p>4</p></td><td style="text-align:left;width:2.6217in; " class="ce22"><p>E2E_DVR_Recording_04</p></td><td style="text-align:left;width:2.272in; " class="ce23"><p>To verify and perform recording of 1 SD and 1 HD channel simultaneously.</p></td><td style="text-align:left;width:1.2339in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:1.8681in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.2835in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro29"><td style="text-align:right; width:0.8925in; " class="ce2"><p>5</p></td><td style="text-align:left;width:2.6217in; " class="ce22"><p>E2E_DVR_Recording_05</p></td><td style="text-align:left;width:2.272in; " class="ce23"><p>To verify and perform recording of 2 HD channels simultaneously.</p></td><td style="text-align:left;width:1.2339in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:1.8681in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.2835in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro30"><td style="text-align:right; width:0.8925in; " class="ce2"><p>6</p></td><td style="text-align:left;width:2.6217in; " class="ce22"><p>E2E_DVR_Recording_06</p></td><td style="text-align:left;width:2.272in; " class="ce24"><p>To verify and perform recorded content can be deleted.</p></td><td style="text-align:left;width:1.2339in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:1.8681in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.2835in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro31"><td style="text-align:right; width:0.8925in; " class="ce2"><p>7</p></td><td style="text-align:left;width:2.6217in; " class="ce22"><p>E2E_DVR_Recording_07</p></td><td style="text-align:left;width:2.272in; " class="ce23"><p>To verify and perform deletion on recording which is deleted already. </p></td><td style="text-align:left;width:1.2339in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:1.8681in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:2.2835in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro18"><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:2.6217in; " class="ce3"> </td><td style="text-align:left;width:2.272in; " class="ce3"> </td><td style="text-align:left;width:1.2339in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:1.8681in; " class="ce3"> </td><td style="text-align:left;width:2.2835in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:2.6217in; " class="ce3"> </td><td style="text-align:left;width:2.272in; " class="ce3"> </td><td style="text-align:left;width:1.2339in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:1.8681in; " class="ce3"> </td><td style="text-align:left;width:2.2835in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr></table><table border="0" cellspacing="0" cellpadding="0" class="ta5"><colgroup><col width="99"/><col width="430"/><col width="474"/><col width="99"/><col width="99"/><col width="337"/><col width="222"/><col width="99"/><col width="99"/></colgroup><tr class="ro19"><td style="text-align:left;width:0.8925in; " class="ce1"><p>Sl. No.</p></td><td style="text-align:left;width:3.878in; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:4.2717in; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:0.8925in; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:0.8925in; " class="ce1"><p>Test Setup</p></td><td style="text-align:left;width:3.0366in; " class="ce1"><p>Pre-requisite</p></td><td style="text-align:left;width:1.9984in; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce15"><p>Exp Output</p></td><td style="text-align:left;width:0.8925in; " class="ce1"><p>Priority</p></td></tr><tr class="ro32"><td style="text-align:right; width:0.8925in; " class="ce2"><p>1</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_01</p></td><td style="text-align:left;width:4.2717in; " class="ce22"><p>To verify the pause operation on the live SD service playback.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro19"><td style="text-align:right; width:0.8925in; " class="ce2"><p>2</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_02</p></td><td style="text-align:left;width:4.2717in; " class="ce22"><p>To verify the pause operation on the live HD service playback.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network. </p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>3</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_03</p></td><td style="text-align:left;width:4.2717in; " class="ce22"><p>To verify the skip back operation after pause operation on the live SD service playback.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>4</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_04</p></td><td style="text-align:left;width:4.2717in; " class="ce22"><p>To verify the skip back operation after pause operation on the live HD service playback.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>5</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_05</p></td><td style="text-align:left;width:4.2717in; " class="ce22"><p>To verify the skip forward operation after pause operation on the live SD service playback.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>6</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_06</p></td><td style="text-align:left;width:4.2717in; " class="ce22"><p>To verify the skip forward operation after pause operation on the live HD service playback.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>7</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_07</p></td><td style="text-align:left;width:4.2717in; " class="ce22"><p>To verify the fast rewind operation after pause operation on the live SD service playback.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>8</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_08</p></td><td style="text-align:left;width:4.2717in; " class="ce22"><p>To verify the fast rewind operation after pause operation on the live HD service playback.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>9</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_09</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify the fast forward operation after pause operation on the live SD service playback.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>10</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_10</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify the fast forward operation after pause operation on the live HD service playback.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>11</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_11</p></td><td style="text-align:left;width:4.2717in; " class="ce22"><p>To verify and perfom Play on a Paused SD service.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>12</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_12</p></td><td style="text-align:left;width:4.2717in; " class="ce22"><p>To verify and perfom Play on a Paused HD service.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>13</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_13</p></td><td style="text-align:left;width:4.2717in; " class="ce22"><p>To verify and perfom Skip back from Play mode on a SD service.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>14</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_14</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip back from Play mode on a HD service.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>15</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_15</p></td><td style="text-align:left;width:4.2717in; " class="ce22"><p>To verify and perfom Skip forward from Play mode on a SD service.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>16</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_16</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip forward from Play mode on a HD service.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>17</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_17</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast rewind from Play mode on a SD service.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>18</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_18</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast rewind from Play mode on a HD service.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>19</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_19</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast forward from Play mode on a SD service.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>20</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_20</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast forward from Play mode on a HD service.</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>21</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_21</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform fast rewind on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>22</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_22</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform fast rewind on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>23</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_23</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform play form Rewind mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>24</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_24</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform play form Rewind mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>25</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_25</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform pause form Rewind mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>26</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_26</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform pause form Rewind mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>27</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_27</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform fast forward  form Rewind mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>28</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_28</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform fast forward  form Rewind mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>29</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_29</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip forward form Rewind mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>30</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_30</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip forward form Rewind mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>31</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_31</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip backward form Rewind mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>32</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_32</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip backward form Rewind mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>33</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_33</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast forward on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>34</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_34</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast forward on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>35</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_35</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Play from Fast forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>36</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_36</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Play from Fast forward mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>37</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_37</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Pause from Fast forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>38</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_38</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Pause from Fast forward mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>39</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_39</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip Forward from Fast forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>40</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_40</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip Forward from Fast forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>41</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_41</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip Back from Fast forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>42</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_42</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip Back from Fast forward mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>43</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_43</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Rewind from Fast forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>44</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_44</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Rewind from Fast forward mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>45</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_45</p></td><td style="text-align:left;width:4.2717in; " class="ce26"><p>To verify and perform Skip Back on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>46</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_46</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip Back on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>47</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_47</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Pause from Skip Back mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>48</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_48</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Pause from Skip Back mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>49</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_49</p></td><td style="text-align:left;width:4.2717in; " class="ce27"><p>To verify and perform Play from Skip Back mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>50</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_50</p></td><td style="text-align:left;width:4.2717in; " class="ce27"><p>To verify and perform Play from Skip Back mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>51</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_51</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and Rewind from Skip Back mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>52</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_52</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and Rewind from Skip Back mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>53</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_53</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast Forward from Skip Back mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>54</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_54</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast Forward from Skip Back mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>55</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_55</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip Forward from Skip Back mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>56</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_56</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip Forward from Skip Back mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>57</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_57</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip Forward on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>58</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_58</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip Forward on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>59</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_59</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Pause from Skip Forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>60</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_60</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Pause from Skip Forward mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>61</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_61</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Play from Skip Forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>62</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_62</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Play from Skip Forward mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>63</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_63</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Rewind from Skip Forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>64</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_64</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Rewind from Skip Forward mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>65</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_65</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast forward from Skip Forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>66</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_66</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast forward from Skip Forward mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>67</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_67</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform skip back from Skip Forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>68</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_68</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform skip back from Skip Forward mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>69</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_69</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Pause from Pause mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>70</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_70</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Pause from Pause mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>71</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_71</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Play from Play mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>72</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_72</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Play from Play mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>73</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_73</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Rewind from Rewind mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>74</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_74</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Rewind from Rewind mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>75</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_75</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast forward from fast forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>76</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_76</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast forward from fast forward mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>77</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_77</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast forward from fast forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>78</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_78</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Fast forward from fast forward mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>79</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_79</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip Forward from Skip forward mode on a SD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro33"><td style="text-align:right; width:0.8925in; " class="ce2"><p>80</p></td><td style="text-align:left;width:3.878in; " class="ce22"><p>E2E_TSB_TrickPlay_80</p></td><td style="text-align:left;width:4.2717in; " class="ce25"><p>To verify and perform Skip Forward from Skip forward mode on a HD service</p></td><td style="text-align:left;width:0.8925in; " class="ce16"><p>Positive</p></td><td style="text-align:left;width:0.8925in; " class="ce10"><p>XG1-XI3_1</p></td><td style="text-align:left;width:3.0366in; " class="ce21"><p>- XG1 and XI3 board should be up and running in same network.                                            - Pause the live playback to perform any trick play.</p></td><td style="text-align:left;width:1.9984in; " class="ce16"><p>Need to decide on Approach</p></td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce16"><p>High</p></td></tr><tr class="ro18"><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:3.878in; " class="ce3"> </td><td style="text-align:left;width:4.2717in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:3.0366in; " class="ce3"> </td><td style="text-align:left;width:1.9984in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr><tr class="ro18"><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:3.878in; " class="ce3"> </td><td style="text-align:left;width:4.2717in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:3.0366in; " class="ce3"> </td><td style="text-align:left;width:1.9984in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="ce3"> </td><td style="text-align:left;width:0.8925in; " class="Default"> </td></tr></table></body></html>
