<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="Anand P S"/><meta name="DCTERMS.issued" content="2014-10-10T08:54:24" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="Dinesh Pandian"/><meta name="DCTERMS.modified" content="2015-02-28T12:43:44" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:10pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.ta1 { writing-mode:lr-tb; }
	.ta2 { writing-mode:lr-tb; }
	.ta3 { writing-mode:lr-tb; }
	.Default { font-family:Arial; padding:0.028in; }
	.ce1 { background-color:#558ed5; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce10 { padding:0.028in; font-family:Arial; border-style:none; }
	.ce11 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:top; writing-mode:page; border-bottom-style:none; border-left-width:0.0133cm; border-left-style:solid; border-left-color:#000000; border-right-width:0.0133cm; border-right-style:solid; border-right-color:#000000; border-top-style:none; text-align:center ! important; }
	.ce12 { background-color:transparent; border-style:none; color:#000000; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce13 { background-color:transparent; border-style:none; color:#ffffff; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce14 { background-color:transparent; border-style:none; color:#000000; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce15 { padding:0.028in; font-family:Arial; }
	.ce16 { background-color:transparent; border-style:none; color:#000000; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:top; writing-mode:page; }
	.ce2 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce3 { background-color:transparent; border-style:none; color:#000000; font-size:11pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Calibri; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.ce4 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce5 { padding:0.028in; font-family:Arial; border-width:0.0133cm; border-style:solid; border-color:#000000; vertical-align:middle; text-align:left ! important; margin-left:0in; writing-mode:page; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	.ce6 { background-color:transparent; border-style:none; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce7 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:underline; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce8 { background-color:transparent; border-width:0.0133cm; border-style:solid; border-color:#000000; color:#000000; font-size:10pt; font-style:normal; font-weight:normal; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:left ! important; }
	.ce9 { background-color:#558ed5; border-style:none; color:#ffffff; font-size:10pt; font-style:normal; font-weight:bold; margin-left:0in; padding:0.028in; text-shadow:none; font-family:Arial; text-decoration:none ! important; vertical-align:middle; writing-mode:page; text-align:center ! important; }
	.co1 { width:1.2992in; }
	.co10 { width:1.5528in; }
	.co11 { width:1.4535in; }
	.co12 { width:2.2134in; }
	.co13 { width:1.2882in; }
	.co14 { width:3.1382in; }
	.co15 { width:0.7264in; }
	.co16 { width:0.6984in; }
	.co2 { width:2.5102in; }
	.co3 { width:0.9575in; }
	.co4 { width:1.4098in; }
	.co5 { width:1.3217in; }
	.co6 { width:1.5638in; }
	.co7 { width:2.4118in; }
	.co8 { width:1.7283in; }
	.co9 { width:0.7047in; }
	.ro1 { height:1.7189in; }
	.ro2 { height:0.2083in; }
	.ro3 { height:0.1772in; }
	.T1 { color:#ffffff; font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:underline; font-weight:bold; }
	.T2 { color:#ffffff; font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:bold; }
	.T3 { color:#000000; font-family:Arial; font-size:10pt; font-style:normal; text-shadow:none; text-decoration:none ! important; font-weight:normal; }
	<!-- ODF styles with no properties representable as CSS -->
	 { }
	</style></head><body dir="ltr" style="max-width:8.5in;margin-top:0.75in; margin-bottom:0.75in; margin-left:0.7in; margin-right:0.7in; writing-mode:lr-tb; "><table border="0" cellspacing="0" cellpadding="0" class="ta1"><colgroup><col width="144"/><col width="279"/><col width="106"/><col width="106"/><col width="156"/><col width="147"/><col width="174"/><col width="268"/><col width="192"/><col width="78"/><col width="172"/><col width="161"/><col width="246"/><col width="143"/><col width="348"/><col width="348"/></colgroup><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce1"><p>Test Case ID</p></td><td style="text-align:left;width:2.5102in; " class="ce1"><p>Test Objective</p></td><td style="text-align:left;width:0.9575in; " class="ce1"><p>Test Type</p></td><td style="text-align:left;width:0.9575in; " class="ce1"><p>Test Setup</p></td><td style="text-align:left;width:1.4098in; " class="ce1"><p>Pre-requisite</p></td><td style="text-align:left;width:1.3217in; " class="ce1"><p>API's / Interface Used</p></td><td style="text-align:left;width:1.5638in; " class="ce1"><p>Input Parameters</p><p>(<span class="T1">API name</span><span class="T2">: parameter type – value) / </span></p><p><span class="T2">Interface Input</span></p></td><td style="text-align:left;width:2.4118in; " class="ce1"><p>Automation Approach</p></td><td style="text-align:left;width:1.7283in; " class="ce1"><p>Exp Output</p></td><td style="text-align:left;width:0.7047in; " class="ce1"><p>Priority</p></td><td style="text-align:left;width:1.5528in; " class="ce1"><p>Test Stub Interface</p></td><td style="text-align:left;width:1.4535in; " class="ce1"><p>Test script</p></td><td style="text-align:left;width:2.2134in; " class="ce9"><p>Remarks</p></td><td style="text-align:left;width:1.2882in; " class="ce1"><p>Release version</p></td><td style="text-align:left;width:3.1382in; " class="ce13"> </td><td style="text-align:left;width:3.1382in; " class="ce13"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_01</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To initialize the DTCP-IP Manager sub-system.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>None</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrInitialize(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>None</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for intializing the DTCP</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_Init_01</p></td><td style="text-align:left;width:2.2134in; " class="ce6"><p>Note: TestMgr_DTCP_Test_Execute is a common function for all the DTCP APIs. The first parameter is function name followed by arguments/parameters.</p></td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce14"> </td><td style="text-align:left;width:3.1382in; " class="ce14"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_02</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To start DTCP-IP source and begins listening for AKE requests on the specified interface and port number.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>ifName':'lan0','port':5000</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method  to start source.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_StartSource_02</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce14"> </td><td style="text-align:left;width:3.1382in; " class="ce14"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_03</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To stop DTCP-IP source and remove AKE request listener added with StartSource()</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrStartSource</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>ifName':'lan0','port':5000</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method to stop encryprting or decrypting.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_StopSource_03</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce14"> </td><td style="text-align:left;width:3.1382in; " class="ce14"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_04</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To create a new authenticated session with a remote DTCP-IP sink.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>"sinkIp":'127.0.0.1',"keyLabel":0,"pcpPacketSize":0,"maxPacketSize":4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to create source session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_CreateSrcSess_04</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_05</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To create a new authenticated session with a remote DTCP-IP source.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrStartSource</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p> 'srcIp':lan0Ip,'srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to create sink session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_CreateSinkSess_05</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_06</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To process(encrypt) the provided buffers and create a DTCP-IP packet.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSourceSession</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrProcessPacket(DTCP_SESSION_HANDLE session, DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrReleasePacket(DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p> </p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>"sinkIp":'127.0.0.1',"keyLabel":0,"pcpPacketSize":0,"maxPacketSize":4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to process DTCP packet</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>Medium</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_ProcessSrcPacket_06</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_07</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To release source DTCP-IP packet. The processed packet may contain DTCP Manager allocated/owned buffers/memory - this call frees up these resources. </p><p> </p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSourceSession, DTCPMgrProcessPacket</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrProcessPacket(DTCP_SESSION_HANDLE session, DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrReleasePacket(DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p> </p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>"sinkIp":'127.0.0.1',"keyLabel":0,"pcpPacketSize":0,"maxPacketSize":4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to Release the packet.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_ReleaseSrcPacket_07</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce14"> </td><td style="text-align:left;width:3.1382in; " class="ce14"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_08</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To stop an active DTCP-IP source session.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSourceSession</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>"sinkIp":'127.0.0.1',"keyLabel":0,"pcpPacketSize":0,"maxPacketSize":4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_DeleteSrcSess_08</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_09</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To retrieve the total number of active sessions for the specified device type.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>int DTCPMgrGetNumSessions(DTCPDeviceType deviceType);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p> 'deviceType':2</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to get num of active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_GetNumSessions_09</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_10</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To retrieve information related to an active source session.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSourceSession</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrGetSessionInfo(DTCP_SESSION_HANDLE handle, DTCPIP_Session *session);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>"sinkIp":'127.0.0.1',"keyLabel":0,"pcpPacketSize":0,"maxPacketSize":4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to get session info</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_GetSrcSessInfo_10</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_11</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To set DTCP Manager's logging verbosity level.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrSetLogLevel(int level);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>"level":3</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to set the log level.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_SetLogLevel_11</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_12</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To retrieve information related to an active sink session.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p> XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSinkSession</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrGetSessionInfo(DTCP_SESSION_HANDLE handle, DTCPIP_Session *session);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p> 'srcIp':'127.0.0.1','srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_GetSinkSessInfo_12</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_13</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To create a new authenticated session with a remote DTCP-IP sink using invalid sink IP address.</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>"sinkIp":'0.42.42.42'</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_CreateSrcSess_InvalidIp_13</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_14</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To create a new authenticated session with a remote DTCP-IP source with an invalid source IP address.</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p> 'srcIp':'0.42.42.42'</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_CreateSinkSess_InvalidIp_14</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_15</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To retrieve the total number of active sessions for an invalid device type.</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>int DTCPMgrGetNumSessions(DTCPDeviceType deviceType);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>deviceType':3</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_GetNumSess_InvalidType_15</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_16</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To set DTCP Manager's logging verbosity level to an invalid value.</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrSetLogLevel(int level);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>"level":50</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_SetInvalidLogLevel_16</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_17</p></td><td style="text-align:left;width:2.5102in; " class="ce4"><p>To start and stop DTCP-IP source on multiple interfaces and port number.</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>ifName':["lan0","lo","eth1"],'port':[5000,5010,8080]</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_StartStopSrc_MultiIface_17</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_18</p></td><td style="text-align:left;width:2.5102in; " class="ce4"><p>To retrieve the total number of active sink sessions.</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>int DTCPMgrGetNumSessions(DTCPDeviceType deviceType);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>deviceType':1</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_GetNumSessions_Sink_18</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_19</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To retrieve the total number of active source sessions.</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>int DTCPMgrGetNumSessions(DTCPDeviceType deviceType);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>deviceType':0</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_GetNumSessions_Src_19</p></td><td style="text-align:left;width:2.2134in; " class="ce6"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_20</p></td><td style="text-align:left;width:2.5102in; " class="ce5"><p>To stop an active DTCP-IP sink session.</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce4"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSinkSession</p></td><td style="text-align:left;width:1.3217in; " class="ce5"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce5"><p>ifName':'lan0','port':5000</p><p>'srcIp':'127.0.0.1','srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce5"><p>DTCP_DeleteSinkSess_20</p></td><td style="text-align:left;width:2.2134in; " class="ce10"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_21</p></td><td style="text-align:left;width:2.5102in; " class="ce5"><p>To stop DTCP-IP source without adding AKE reques listeners with StartSource()</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce5"><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce5"><p>None</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce5"><p>DTCP_StopWithoutStartSrc_21</p></td><td style="text-align:left;width:2.2134in; " class="ce10"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_22</p></td><td style="text-align:left;width:2.5102in; " class="ce5"><p>To start DTCP-IP source on an invalid TCP/IP port number.</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce5"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p></td><td style="text-align:left;width:1.5638in; " class="ce5"><p>ifName':'lan0','port':23</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce8"><p>DTCP_StartSource_InvalidPort_22</p></td><td style="text-align:left;width:2.2134in; " class="ce10"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_23</p></td><td style="text-align:left;width:2.5102in; " class="ce5"><p>To start DTCP-IP source on an invalid interface name.</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce5"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p></td><td style="text-align:left;width:1.5638in; " class="ce5"><p>ifName':'127.0.0.1','port':5000</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce5"><p>DTCP_StartSource_InvalidIfName_23</p></td><td style="text-align:left;width:2.2134in; " class="ce10"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_24</p></td><td style="text-align:left;width:2.5102in; " class="ce5"><p>To retrieve information related to a null session handle.</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce5"><p>dtcp_result_t DTCPMgrGetSessionInfo(DTCP_SESSION_HANDLE handle, DTCPIP_Session *session);</p></td><td style="text-align:left;width:1.5638in; " class="ce5"><p>handle=0</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce5"><p>DTCP_GetSessInfo_Neg_24</p></td><td style="text-align:left;width:2.2134in; " class="ce10"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_25</p></td><td style="text-align:left;width:2.5102in; " class="ce5"><p>To create a new authenticated session with a remote DTCP-IP source using invalid TCP/IP port.</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrInitialize(void);</p><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p><p> </p></td><td style="text-align:left;width:1.5638in; " class="ce5"><p>srcIp':'127.0.0.1','srcPort':0,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce5"><p>DTCP_CreateSinkSess_InvalidPort_25</p></td><td style="text-align:left;width:2.2134in; " class="ce10"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce15"> </td><td style="text-align:left;width:3.1382in; " class="ce15"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_26</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To process null sink and source session handles.</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrProcessPacket(DTCP_SESSION_HANDLE session, DTCPIP_Packet *packet);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>session=0</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_ProcessPacket_Neg_26</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_27</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To process DTCP-IP packet and return decrypted buffers.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSinkSession</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrProcessPacket(DTCP_SESSION_HANDLE session, DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrReleasePacket(DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p><p> </p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>ifName':'lan0','port':5000</p><p>'srcIp':'127.0.0.1','srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_ProcessSinkPacket_27</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_28</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To release sink DTCP-IP packet. The processed packet may contain DTCP Manager allocated/owned buffers/memory - this call frees up these resources. </p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrCreateSinkSession, DTCPMgrProcessPacket</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrProcessPacket(DTCP_SESSION_HANDLE session, DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrReleasePacket(DTCPIP_Packet *packet);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p><p> </p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>ifName':'lan0','port':5000</p><p>'srcIp':'127.0.0.1','srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_ReleaseSinkPacket_28</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_29</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To stop a null DTCP-IP sink session.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>session=0</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_DeleteSinkSess_Neg_29</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_30</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To stop a null DTCP-IP source session.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>session=0</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_DeleteSrcSess_Neg_30</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_31</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To initialize the DTCP-IP Manager sub-system multiple times.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrInitialize(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>None</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_Init_Stress_31</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_32</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To stop DTCP-IP source without deleting active source and sink sessions. </p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>ifName':'lan0','port':5000</p><p>'srcIp':ip,'srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p><p>'sinkIp':ip,'keyLabel':0,'pcpPacketSize':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_StopSrcwithActiveSessions_32</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_33</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To create a new authenticated source session with a remote DTCP-IP sink without invoking StartSource().</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>sinkIp':ip,'keyLabel':0,'pcpPacketSize':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_CreateSrcSessWithoutStartSrc_33</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_34</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To create a new authenticated sink session with a remote DTCP-IP source without invoking StartSource().</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Negative</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>srcIp':ip,'srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_CreateSinkSessWithoutStartSrc_34</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_35</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To check that max of only 1 sink session is created since DTCP sink session is persistent and on every channel change dtcp uses the same session. </p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>ifName':'lan0','port':[5000,5009]</p><p>'srcIp':ip,'srcPort':port,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_CreateMaxSinkSess_35</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_36</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To check that max of 8 source sessions can be created if no sink sessions are there</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>sinkIp':lan0-ip,'keyLabel':0,'pcpPacketSize':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_CreateMaxSrcSess_36</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_37</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To start multiple DTCP-IP source listeners on different interfaces and ports.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>ifName':'lan0','port':[6000...6059]</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_MultiStartSource_37</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_38</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To create and remove multiple AKE request listeners using startsource/stopsource</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrStartSource</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>ifName':'lan0','port':[8000,8001,8002,8003,8004]</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_StopAllSources_38</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_39</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To create a new authenticated sink session with loopback IP address as remote DTCP-IP source.</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize, DTCPMgrStartSource</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>srcIp':'127.0.0.1','srcPort':5000,'uniqueKey':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_CreateSinkSessOnLoSrcIp_39</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce2"><p>CT_DTCP_40</p></td><td style="text-align:left;width:2.5102in; " class="ce2"><p>To verify successful exchange of key label from streaming request</p></td><td style="text-align:left;width:0.9575in; " class="ce2"><p>Positive</p></td><td style="text-align:left;width:0.9575in; " class="ce5"><p>XG1</p></td><td style="text-align:left;width:1.4098in; " class="ce2"><p>DTCPMgrInitialize</p></td><td style="text-align:left;width:1.3217in; " class="ce2"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p><p>dtcp_result_t DTCPMgrGetSessionInfo(DTCP_SESSION_HANDLE handle, DTCPIP_Session *session);</p><p>dtcp_result_t DTCPMgrStopSource(void);</p><p> </p></td><td style="text-align:left;width:1.5638in; " class="ce2"><p>ifName':'lan0','port':5000</p><p>'srcIp':lanip,'srcPort':5000,'uniqueKey':1,'maxPacketSize':4096</p><p>'sinkIp':'127.0.0.1','keyLabel':87,'pcpPacketSize':0,'maxPacketSize':4096</p></td><td style="text-align:left;width:2.4118in; " class="ce4"><p>1.TM loads DTCP_agent via the test agent. </p><p>2.The stub will invokes the RPC method for to stop active session.</p><p>3. The stub function will call the API and result will be shared back to TM</p><p>4. TM will receive and display the result.</p></td><td style="text-align:left;width:1.7283in; " class="ce7"><p>Checkpoint 1 <span class="T3">stub will check for the return value of the function.</span></p></td><td style="text-align:left;width:0.7047in; " class="ce2"><p>High</p></td><td style="text-align:left;width:1.5528in; " class="ce2"><p> </p><p>TestMgr_DTCP_Test_Execute</p></td><td style="text-align:left;width:1.4535in; " class="ce2"><p>DTCP_UniqueKeyExchange_40</p></td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce11"><p>M21</p></td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce3"> </td><td style="text-align:left;width:2.5102in; " class="ce3"> </td><td style="text-align:left;width:0.9575in; " class="ce3"> </td><td style="text-align:left;width:0.9575in; " class="ce3"> </td><td style="text-align:left;width:1.4098in; " class="ce3"> </td><td style="text-align:left;width:1.3217in; " class="ce6"> </td><td style="text-align:left;width:1.5638in; " class="ce3"> </td><td style="text-align:left;width:2.4118in; " class="ce3"> </td><td style="text-align:left;width:1.7283in; " class="ce3"> </td><td style="text-align:left;width:0.7047in; " class="ce6"> </td><td style="text-align:left;width:1.5528in; " class="ce3"> </td><td style="text-align:left;width:1.4535in; " class="ce3"> </td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr><tr class="ro1"><td style="text-align:left;width:1.2992in; " class="ce3"> </td><td style="text-align:left;width:2.5102in; " class="ce3"> </td><td style="text-align:left;width:0.9575in; " class="ce3"> </td><td style="text-align:left;width:0.9575in; " class="ce3"> </td><td style="text-align:left;width:1.4098in; " class="ce3"> </td><td style="text-align:left;width:1.3217in; " class="ce6"> </td><td style="text-align:left;width:1.5638in; " class="ce3"> </td><td style="text-align:left;width:2.4118in; " class="ce3"> </td><td style="text-align:left;width:1.7283in; " class="ce3"> </td><td style="text-align:left;width:0.7047in; " class="ce6"> </td><td style="text-align:left;width:1.5528in; " class="ce3"> </td><td style="text-align:left;width:1.4535in; " class="ce3"> </td><td style="text-align:left;width:2.2134in; " class="ce3"> </td><td style="text-align:left;width:1.2882in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="ce12"> </td><td style="text-align:left;width:3.1382in; " class="Default"> </td></tr></table><table border="0" cellspacing="0" cellpadding="0" class="ta2"><colgroup><col width="81"/><col width="81"/></colgroup><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"><p>dtcp_result_t DTCPMgrInitialize(void);</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"><p>dtcp_result_t DTCPMgrStartSource(char* ifName, int portNum);</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"><p>dtcp_result_t DTCPMgrStopSource(void);</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"><p>dtcp_result_t DTCPMgrCreateSourceSession(char *sinkIpAddress, int key_label, int PCPPacketSize, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"><p>dtcp_result_t DTCPMgrCreateSinkSession(char *srcIpAddress, int srcIpPort, BOOLEAN uniqueKey, int maxPacketSize, DTCP_SESSION_HANDLE *handle);</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"><p>dtcp_result_t DTCPMgrProcessPacket(DTCP_SESSION_HANDLE session, DTCPIP_Packet *packet);</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"><p>dtcp_result_t DTCPMgrReleasePacket(DTCPIP_Packet *packet);</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"><p>dtcp_result_t DTCPMgrDeleteDTCPSession(DTCP_SESSION_HANDLE session);</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"><p>int DTCPMgrGetNumSessions(DTCPDeviceType deviceType);</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"><p>dtcp_result_t DTCPMgrGetSessionInfo(DTCP_SESSION_HANDLE handle, DTCPIP_Session *session);</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"><p>dtcp_result_t DTCPMgrSetLogLevel(int level);</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>typedef enum {</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>        DTCP_SUCCESS                 = 0,  /**&lt; Operation successful, no errors.     */</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>        DTCP_ERR_NOT_INITIALIZED     = -1, /**&lt; DTCP Manager not initialized yet.    */</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>        DTCP_ERR_INVALID_PARAM       = -2, /**&lt; Invalid parameter supplied.          */</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>        DTCP_ERR_GENERAL             = -3, /**&lt; General unspecified error.           */</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>        DTCP_ERR_MEMORY_ALLOC        = -4, /**&lt; Memory allocation failure.           */</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>        DTCP_ERR_OUT_OF_SESSIONS     = -5, /**&lt; Too many active sessions.            */</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>        DTCP_ERR_INVALID_CERTIFICATE = -6, /**&lt; Invalid certificate.                 */</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>        DTCP_ERR_AKE                 = -7, /**&lt; Authorization/Key Exchange error.    */</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>        DTCP_ERR_CONT_KEY_REQ        = -8, /**&lt; Content key error.                   */</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>        DTCP_ERR_INVALID_KEY_LABEL   = -9, /**&lt; Invalid exchange key label supplied. */</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>        DTCP_ERR_INVALID_IP_ADDRESS      = -10, /**&lt; Invalid IP address supplied.         */</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>        DTCP_ERR_SERVER_NOT_REACHABLE   = -11  /**&lt; DTCP Server not reachable.           */</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"><p>} dtcp_result_t;</p></td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="ce15"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"> </td></tr><tr class="ro2"><td style="text-align:left;width:0.7264in; " class="ce16"> </td><td style="text-align:left;width:0.7264in; " class="Default"> </td></tr></table><table border="0" cellspacing="0" cellpadding="0" class="ta3"><colgroup><col width="78"/></colgroup><tr class="ro3"><td style="text-align:left;width:0.6984in; " class="Default"> </td></tr><tr class="ro3"><td style="text-align:left;width:0.6984in; " class="Default"> </td></tr></table></body></html>
